{
  "version": 3,
  "sources": ["../../rbush/rbush.min.js", "../../sat/SAT.js", "../../detect-collisions/dist/model.js", "../../detect-collisions/dist/optimized.js", "../../detect-collisions/dist/intersect.js", "../../detect-collisions/dist/utils.js", "../../detect-collisions/dist/bodies/circle.js", "../../poly-decomp/src/index.js", "../../detect-collisions/dist/bodies/polygon.js", "../../detect-collisions/dist/bodies/ellipse.js", "../../detect-collisions/dist/bodies/box.js", "../../detect-collisions/dist/bodies/point.js", "../../detect-collisions/dist/bodies/line.js", "../../detect-collisions/dist/base-system.js", "../../detect-collisions/dist/system.js", "../../detect-collisions/dist/index.js"],
  "sourcesContent": ["!function(t,i){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=i():\"function\"==typeof define&&define.amd?define(i):(t=t||self).RBush=i()}(this,function(){\"use strict\";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});\n", "// Version 0.9.0 - Copyright 2012 - 2021 -  Jim Riecken <jimr@jimr.ca>\n//\n// Released under the MIT License - https://github.com/jriecken/sat-js\n//\n// A simple library for determining intersections of circles and\n// polygons using the Separating Axis Theorem.\n/** @preserve SAT.js - Version 0.9.0 - Copyright 2012 - 2021 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js */\n\n/*global define: false, module: false*/\n/*jshint shadow:true, sub:true, forin:true, noarg:true, noempty:true,\n  eqeqeq:true, bitwise:true, strict:true, undef:true,\n  curly:true, browser:true */\n\n// Create a UMD wrapper for SAT. Works in:\n//\n//  - Plain browser via global SAT variable\n//  - AMD loader (like require.js)\n//  - Node.js\n//\n// The quoted properties all over the place are used so that the Closure Compiler\n// does not mangle the exposed API in advanced mode.\n/**\n * @param {*} root - The global scope\n * @param {Function} factory - Factory that creates SAT module\n */\n(function (root, factory) {\n  \"use strict\";\n  if (typeof define === 'function' && define['amd']) {\n    define(factory);\n  } else if (typeof exports === 'object') {\n    module['exports'] = factory();\n  } else {\n    root['SAT'] = factory();\n  }\n}(this, function () {\n  \"use strict\";\n\n  var SAT = {};\n\n  //\n  // ## Vector\n  //\n  // Represents a vector in two dimensions with `x` and `y` properties.\n\n\n  // Create a new Vector, optionally passing in the `x` and `y` coordinates. If\n  // a coordinate is not specified, it will be set to `0`\n  /**\n   * @param {?number=} x The x position.\n   * @param {?number=} y The y position.\n   * @constructor\n   */\n  function Vector(x, y) {\n    this['x'] = x || 0;\n    this['y'] = y || 0;\n  }\n  SAT['Vector'] = Vector;\n  // Alias `Vector` as `V`\n  SAT['V'] = Vector;\n\n\n  // Copy the values of another Vector into this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['copy'] = Vector.prototype.copy = function (other) {\n    this['x'] = other['x'];\n    this['y'] = other['y'];\n    return this;\n  };\n\n  // Create a new vector with the same coordinates as this on.\n  /**\n   * @return {Vector} The new cloned vector\n   */\n  Vector.prototype['clone'] = Vector.prototype.clone = function () {\n    return new Vector(this['x'], this['y']);\n  };\n\n  // Change this vector to be perpendicular to what it was before. (Effectively\n  // roatates it 90 degrees in a clockwise direction)\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['perp'] = Vector.prototype.perp = function () {\n    var x = this['x'];\n    this['x'] = this['y'];\n    this['y'] = -x;\n    return this;\n  };\n\n  // Rotate this vector (counter-clockwise) by the specified angle (in radians).\n  /**\n   * @param {number} angle The angle to rotate (in radians)\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['rotate'] = Vector.prototype.rotate = function (angle) {\n    var x = this['x'];\n    var y = this['y'];\n    this['x'] = x * Math.cos(angle) - y * Math.sin(angle);\n    this['y'] = x * Math.sin(angle) + y * Math.cos(angle);\n    return this;\n  };\n\n  // Reverse this vector.\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reverse'] = Vector.prototype.reverse = function () {\n    this['x'] = -this['x'];\n    this['y'] = -this['y'];\n    return this;\n  };\n\n\n  // Normalize this vector.  (make it have length of `1`)\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['normalize'] = Vector.prototype.normalize = function () {\n    var d = this.len();\n    if (d > 0) {\n      this['x'] = this['x'] / d;\n      this['y'] = this['y'] / d;\n    }\n    return this;\n  };\n\n  // Add another vector to this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['add'] = Vector.prototype.add = function (other) {\n    this['x'] += other['x'];\n    this['y'] += other['y'];\n    return this;\n  };\n\n  // Subtract another vector from this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaiing.\n   */\n  Vector.prototype['sub'] = Vector.prototype.sub = function (other) {\n    this['x'] -= other['x'];\n    this['y'] -= other['y'];\n    return this;\n  };\n\n  // Scale this vector. An independent scaling factor can be provided\n  // for each axis, or a single scaling factor that will scale both `x` and `y`.\n  /**\n   * @param {number} x The scaling factor in the x direction.\n   * @param {?number=} y The scaling factor in the y direction.  If this\n   *   is not specified, the x scaling factor will be used.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['scale'] = Vector.prototype.scale = function (x, y) {\n    this['x'] *= x;\n    this['y'] *= typeof y != 'undefined' ? y : x;\n    return this;\n  };\n\n  // Project this vector on to another vector.\n  /**\n   * @param {Vector} other The vector to project onto.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['project'] = Vector.prototype.project = function (other) {\n    var amt = this.dot(other) / other.len2();\n    this['x'] = amt * other['x'];\n    this['y'] = amt * other['y'];\n    return this;\n  };\n\n  // Project this vector onto a vector of unit length. This is slightly more efficient\n  // than `project` when dealing with unit vectors.\n  /**\n   * @param {Vector} other The unit vector to project onto.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['projectN'] = Vector.prototype.projectN = function (other) {\n    var amt = this.dot(other);\n    this['x'] = amt * other['x'];\n    this['y'] = amt * other['y'];\n    return this;\n  };\n\n  // Reflect this vector on an arbitrary axis.\n  /**\n   * @param {Vector} axis The vector representing the axis.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reflect'] = Vector.prototype.reflect = function (axis) {\n    var x = this['x'];\n    var y = this['y'];\n    this.project(axis).scale(2);\n    this['x'] -= x;\n    this['y'] -= y;\n    return this;\n  };\n\n  // Reflect this vector on an arbitrary axis (represented by a unit vector). This is\n  // slightly more efficient than `reflect` when dealing with an axis that is a unit vector.\n  /**\n   * @param {Vector} axis The unit vector representing the axis.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reflectN'] = Vector.prototype.reflectN = function (axis) {\n    var x = this['x'];\n    var y = this['y'];\n    this.projectN(axis).scale(2);\n    this['x'] -= x;\n    this['y'] -= y;\n    return this;\n  };\n\n  // Get the dot product of this vector and another.\n  /**\n   * @param {Vector}  other The vector to dot this one against.\n   * @return {number} The dot product.\n   */\n  Vector.prototype['dot'] = Vector.prototype.dot = function (other) {\n    return this['x'] * other['x'] + this['y'] * other['y'];\n  };\n\n  // Get the squared length of this vector.\n  /**\n   * @return {number} The length^2 of this vector.\n   */\n  Vector.prototype['len2'] = Vector.prototype.len2 = function () {\n    return this.dot(this);\n  };\n\n  // Get the length of this vector.\n  /**\n   * @return {number} The length of this vector.\n   */\n  Vector.prototype['len'] = Vector.prototype.len = function () {\n    return Math.sqrt(this.len2());\n  };\n\n  // ## Circle\n  //\n  // Represents a circle with a position and a radius.\n\n  // Create a new circle, optionally passing in a position and/or radius. If no position\n  // is given, the circle will be at `(0,0)`. If no radius is provided, the circle will\n  // have a radius of `0`.\n  /**\n   * @param {Vector=} pos A vector representing the position of the center of the circle\n   * @param {?number=} r The radius of the circle\n   * @constructor\n   */\n  function Circle(pos, r) {\n    this['pos'] = pos || new Vector();\n    this['r'] = r || 0;\n    this['offset'] = new Vector();\n  }\n  SAT['Circle'] = Circle;\n\n  // Compute the axis-aligned bounding box (AABB) of this Circle.\n  //\n  // Note: Returns a _new_ `Box` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Circle.prototype['getAABBAsBox'] = Circle.prototype.getAABBAsBox = function () {\n    var r = this['r'];\n    var corner = this['pos'].clone().add(this['offset']).sub(new Vector(r, r));\n    return new Box(corner, r * 2, r * 2);\n  };\n\n  // Compute the axis-aligned bounding box (AABB) of this Circle.\n  //\n  // Note: Returns a _new_ `Polygon` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Circle.prototype['getAABB'] = Circle.prototype.getAABB = function () {\n    return this.getAABBAsBox().toPolygon();\n  };\n\n  // Set the current offset to apply to the radius.\n  /**\n   * @param {Vector} offset The new offset vector.\n   * @return {Circle} This for chaining.\n   */\n  Circle.prototype['setOffset'] = Circle.prototype.setOffset = function (offset) {\n    this['offset'] = offset;\n    return this;\n  };\n\n  // ## Polygon\n  //\n  // Represents a *convex* polygon with any number of points (specified in counter-clockwise order)\n  //\n  // Note: Do _not_ manually change the `points`, `angle`, or `offset` properties. Use the\n  // provided setters. Otherwise the calculated properties will not be updated correctly.\n  //\n  // `pos` can be changed directly.\n\n  // Create a new polygon, passing in a position vector, and an array of points (represented\n  // by vectors relative to the position vector). If no position is passed in, the position\n  // of the polygon will be `(0,0)`.\n  /**\n   * @param {Vector=} pos A vector representing the origin of the polygon. (all other\n   *   points are relative to this one)\n   * @param {Array<Vector>=} points An array of vectors representing the points in the polygon,\n   *   in counter-clockwise order.\n   * @constructor\n   */\n  function Polygon(pos, points) {\n    this['pos'] = pos || new Vector();\n    this['angle'] = 0;\n    this['offset'] = new Vector();\n    this.setPoints(points || []);\n  }\n  SAT['Polygon'] = Polygon;\n\n  // Set the points of the polygon. Any consecutive duplicate points will be combined.\n  //\n  // Note: The points are counter-clockwise *with respect to the coordinate system*.\n  // If you directly draw the points on a screen that has the origin at the top-left corner\n  // it will _appear_ visually that the points are being specified clockwise. This is just\n  // because of the inversion of the Y-axis when being displayed.\n  /**\n   * @param {Array<Vector>=} points An array of vectors representing the points in the polygon,\n   *   in counter-clockwise order.\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['setPoints'] = Polygon.prototype.setPoints = function (points) {\n    // Only re-allocate if this is a new polygon or the number of points has changed.\n    var lengthChanged = !this['points'] || this['points'].length !== points.length;\n    if (lengthChanged) {\n      var i;\n      var calcPoints = this['calcPoints'] = [];\n      var edges = this['edges'] = [];\n      var normals = this['normals'] = [];\n      // Allocate the vector arrays for the calculated properties\n      for (i = 0; i < points.length; i++) {\n        // Remove consecutive duplicate points\n        var p1 = points[i];\n        var p2 = i < points.length - 1 ? points[i + 1] : points[0];\n        if (p1 !== p2 && p1.x === p2.x && p1.y === p2.y) {\n          points.splice(i, 1);\n          i -= 1;\n          continue;\n        }\n        calcPoints.push(new Vector());\n        edges.push(new Vector());\n        normals.push(new Vector());\n      }\n    }\n    this['points'] = points;\n    this._recalc();\n    return this;\n  };\n\n  // Set the current rotation angle of the polygon.\n  /**\n   * @param {number} angle The current rotation angle (in radians).\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['setAngle'] = Polygon.prototype.setAngle = function (angle) {\n    this['angle'] = angle;\n    this._recalc();\n    return this;\n  };\n\n  // Set the current offset to apply to the `points` before applying the `angle` rotation.\n  /**\n   * @param {Vector} offset The new offset vector.\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['setOffset'] = Polygon.prototype.setOffset = function (offset) {\n    this['offset'] = offset;\n    this._recalc();\n    return this;\n  };\n\n  // Rotates this polygon counter-clockwise around the origin of *its local coordinate system* (i.e. `pos`).\n  //\n  // Note: This changes the **original** points (so any `angle` will be applied on top of this rotation).\n  /**\n   * @param {number} angle The angle to rotate (in radians)\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['rotate'] = Polygon.prototype.rotate = function (angle) {\n    var points = this['points'];\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      points[i].rotate(angle);\n    }\n    this._recalc();\n    return this;\n  };\n\n  // Translates the points of this polygon by a specified amount relative to the origin of *its own coordinate\n  // system* (i.e. `pos`).\n  //\n  // This is most useful to change the \"center point\" of a polygon. If you just want to move the whole polygon, change\n  // the coordinates of `pos`.\n  //\n  // Note: This changes the **original** points (so any `offset` will be applied on top of this translation)\n  /**\n   * @param {number} x The horizontal amount to translate.\n   * @param {number} y The vertical amount to translate.\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['translate'] = Polygon.prototype.translate = function (x, y) {\n    var points = this['points'];\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      points[i]['x'] += x;\n      points[i]['y'] += y;\n    }\n    this._recalc();\n    return this;\n  };\n\n\n  // Computes the calculated collision polygon. Applies the `angle` and `offset` to the original points then recalculates the\n  // edges and normals of the collision polygon.\n  /**\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype._recalc = function () {\n    // Calculated points - this is what is used for underlying collisions and takes into account\n    // the angle/offset set on the polygon.\n    var calcPoints = this['calcPoints'];\n    // The edges here are the direction of the `n`th edge of the polygon, relative to\n    // the `n`th point. If you want to draw a given edge from the edge value, you must\n    // first translate to the position of the starting point.\n    var edges = this['edges'];\n    // The normals here are the direction of the normal for the `n`th edge of the polygon, relative\n    // to the position of the `n`th point. If you want to draw an edge normal, you must first\n    // translate to the position of the starting point.\n    var normals = this['normals'];\n    // Copy the original points array and apply the offset/angle\n    var points = this['points'];\n    var offset = this['offset'];\n    var angle = this['angle'];\n    var len = points.length;\n    var i;\n    for (i = 0; i < len; i++) {\n      var calcPoint = calcPoints[i].copy(points[i]);\n      calcPoint['x'] += offset['x'];\n      calcPoint['y'] += offset['y'];\n      if (angle !== 0) {\n        calcPoint.rotate(angle);\n      }\n    }\n    // Calculate the edges/normals\n    for (i = 0; i < len; i++) {\n      var p1 = calcPoints[i];\n      var p2 = i < len - 1 ? calcPoints[i + 1] : calcPoints[0];\n      var e = edges[i].copy(p2).sub(p1);\n      normals[i].copy(e).perp().normalize();\n    }\n    return this;\n  };\n\n\n  // Compute the axis-aligned bounding box. Any current state\n  // (translations/rotations) will be applied before constructing the AABB.\n  //\n  // Note: Returns a _new_ `Box` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Polygon.prototype['getAABBAsBox'] = Polygon.prototype.getAABBAsBox = function () {\n    var points = this['calcPoints'];\n    var len = points.length;\n    var xMin = points[0]['x'];\n    var yMin = points[0]['y'];\n    var xMax = points[0]['x'];\n    var yMax = points[0]['y'];\n    for (var i = 1; i < len; i++) {\n      var point = points[i];\n      if (point['x'] < xMin) {\n        xMin = point['x'];\n      }\n      else if (point['x'] > xMax) {\n        xMax = point['x'];\n      }\n      if (point['y'] < yMin) {\n        yMin = point['y'];\n      }\n      else if (point['y'] > yMax) {\n        yMax = point['y'];\n      }\n    }\n    return new Box(this['pos'].clone().add(new Vector(xMin, yMin)), xMax - xMin, yMax - yMin);\n  };\n\n\n  // Compute the axis-aligned bounding box. Any current state\n  // (translations/rotations) will be applied before constructing the AABB.\n  //\n  // Note: Returns a _new_ `Polygon` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Polygon.prototype['getAABB'] = Polygon.prototype.getAABB = function () {\n    return this.getAABBAsBox().toPolygon();\n  };\n\n  // Compute the centroid (geometric center) of the polygon. Any current state\n  // (translations/rotations) will be applied before computing the centroid.\n  //\n  // See https://en.wikipedia.org/wiki/Centroid#Centroid_of_a_polygon\n  //\n  // Note: Returns a _new_ `Vector` each time you call this.\n  /**\n   * @return {Vector} A Vector that contains the coordinates of the Centroid.\n   */\n  Polygon.prototype['getCentroid'] = Polygon.prototype.getCentroid = function () {\n    var points = this['calcPoints'];\n    var len = points.length;\n    var cx = 0;\n    var cy = 0;\n    var ar = 0;\n    for (var i = 0; i < len; i++) {\n      var p1 = points[i];\n      var p2 = i === len - 1 ? points[0] : points[i + 1]; // Loop around if last point\n      var a = p1['x'] * p2['y'] - p2['x'] * p1['y'];\n      cx += (p1['x'] + p2['x']) * a;\n      cy += (p1['y'] + p2['y']) * a;\n      ar += a;\n    }\n    ar = ar * 3; // we want 1 / 6 the area and we currently have 2*area\n    cx = cx / ar;\n    cy = cy / ar;\n    return new Vector(cx, cy);\n  };\n\n\n  // ## Box\n  //\n  // Represents an axis-aligned box, with a width and height.\n\n\n  // Create a new box, with the specified position, width, and height. If no position\n  // is given, the position will be `(0,0)`. If no width or height are given, they will\n  // be set to `0`.\n  /**\n   * @param {Vector=} pos A vector representing the bottom-left of the box (i.e. the smallest x and smallest y value).\n   * @param {?number=} w The width of the box.\n   * @param {?number=} h The height of the box.\n   * @constructor\n   */\n  function Box(pos, w, h) {\n    this['pos'] = pos || new Vector();\n    this['w'] = w || 0;\n    this['h'] = h || 0;\n  }\n  SAT['Box'] = Box;\n\n  // Returns a polygon whose edges are the same as this box.\n  /**\n   * @return {Polygon} A new Polygon that represents this box.\n   */\n  Box.prototype['toPolygon'] = Box.prototype.toPolygon = function () {\n    var pos = this['pos'];\n    var w = this['w'];\n    var h = this['h'];\n    return new Polygon(new Vector(pos['x'], pos['y']), [\n      new Vector(), new Vector(w, 0),\n      new Vector(w, h), new Vector(0, h)\n    ]);\n  };\n\n  // ## Response\n  //\n  // An object representing the result of an intersection. Contains:\n  //  - The two objects participating in the intersection\n  //  - The vector representing the minimum change necessary to extract the first object\n  //    from the second one (as well as a unit vector in that direction and the magnitude\n  //    of the overlap)\n  //  - Whether the first object is entirely inside the second, and vice versa.\n  /**\n   * @constructor\n   */\n  function Response() {\n    this['a'] = null;\n    this['b'] = null;\n    this['overlapN'] = new Vector();\n    this['overlapV'] = new Vector();\n    this.clear();\n  }\n  SAT['Response'] = Response;\n\n  // Set some values of the response back to their defaults.  Call this between tests if\n  // you are going to reuse a single Response object for multiple intersection tests (recommented\n  // as it will avoid allcating extra memory)\n  /**\n   * @return {Response} This for chaining\n   */\n  Response.prototype['clear'] = Response.prototype.clear = function () {\n    this['aInB'] = true;\n    this['bInA'] = true;\n    this['overlap'] = Number.MAX_VALUE;\n    return this;\n  };\n\n  // ## Object Pools\n\n  // A pool of `Vector` objects that are used in calculations to avoid\n  // allocating memory.\n  /**\n   * @type {Array<Vector>}\n   */\n  var T_VECTORS = [];\n  for (var i = 0; i < 10; i++) { T_VECTORS.push(new Vector()); }\n\n  // A pool of arrays of numbers used in calculations to avoid allocating\n  // memory.\n  /**\n   * @type {Array<Array<number>>}\n   */\n  var T_ARRAYS = [];\n  for (var i = 0; i < 5; i++) { T_ARRAYS.push([]); }\n\n  // Temporary response used for polygon hit detection.\n  /**\n   * @type {Response}\n   */\n  var T_RESPONSE = new Response();\n\n  // Tiny \"point\" polygon used for polygon hit detection.\n  /**\n   * @type {Polygon}\n   */\n  var TEST_POINT = new Box(new Vector(), 0.000001, 0.000001).toPolygon();\n\n  // ## Helper Functions\n\n  // Flattens the specified array of points onto a unit vector axis,\n  // resulting in a one dimensional range of the minimum and\n  // maximum value on that axis.\n  /**\n   * @param {Array<Vector>} points The points to flatten.\n   * @param {Vector} normal The unit vector axis to flatten on.\n   * @param {Array<number>} result An array.  After calling this function,\n   *   result[0] will be the minimum value,\n   *   result[1] will be the maximum value.\n   */\n  function flattenPointsOn(points, normal, result) {\n    var min = Number.MAX_VALUE;\n    var max = -Number.MAX_VALUE;\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      // The magnitude of the projection of the point onto the normal\n      var dot = points[i].dot(normal);\n      if (dot < min) { min = dot; }\n      if (dot > max) { max = dot; }\n    }\n    result[0] = min; result[1] = max;\n  }\n\n  // Check whether two convex polygons are separated by the specified\n  // axis (must be a unit vector).\n  /**\n   * @param {Vector} aPos The position of the first polygon.\n   * @param {Vector} bPos The position of the second polygon.\n   * @param {Array<Vector>} aPoints The points in the first polygon.\n   * @param {Array<Vector>} bPoints The points in the second polygon.\n   * @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons\n   *   will be projected onto this axis.\n   * @param {Response=} response A Response object (optional) which will be populated\n   *   if the axis is not a separating axis.\n   * @return {boolean} true if it is a separating axis, false otherwise.  If false,\n   *   and a response is passed in, information about how much overlap and\n   *   the direction of the overlap will be populated.\n   */\n  function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {\n    var rangeA = T_ARRAYS.pop();\n    var rangeB = T_ARRAYS.pop();\n    // The magnitude of the offset between the two polygons\n    var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);\n    var projectedOffset = offsetV.dot(axis);\n    // Project the polygons onto the axis.\n    flattenPointsOn(aPoints, axis, rangeA);\n    flattenPointsOn(bPoints, axis, rangeB);\n    // Move B's range to its position relative to A.\n    rangeB[0] += projectedOffset;\n    rangeB[1] += projectedOffset;\n    // Check if there is a gap. If there is, this is a separating axis and we can stop\n    if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {\n      T_VECTORS.push(offsetV);\n      T_ARRAYS.push(rangeA);\n      T_ARRAYS.push(rangeB);\n      return true;\n    }\n    // This is not a separating axis. If we're calculating a response, calculate the overlap.\n    if (response) {\n      var overlap = 0;\n      // A starts further left than B\n      if (rangeA[0] < rangeB[0]) {\n        response['aInB'] = false;\n        // A ends before B does. We have to pull A out of B\n        if (rangeA[1] < rangeB[1]) {\n          overlap = rangeA[1] - rangeB[0];\n          response['bInA'] = false;\n          // B is fully inside A.  Pick the shortest way out.\n        } else {\n          var option1 = rangeA[1] - rangeB[0];\n          var option2 = rangeB[1] - rangeA[0];\n          overlap = option1 < option2 ? option1 : -option2;\n        }\n        // B starts further left than A\n      } else {\n        response['bInA'] = false;\n        // B ends before A ends. We have to push A out of B\n        if (rangeA[1] > rangeB[1]) {\n          overlap = rangeA[0] - rangeB[1];\n          response['aInB'] = false;\n          // A is fully inside B.  Pick the shortest way out.\n        } else {\n          var option1 = rangeA[1] - rangeB[0];\n          var option2 = rangeB[1] - rangeA[0];\n          overlap = option1 < option2 ? option1 : -option2;\n        }\n      }\n      // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.\n      var absOverlap = Math.abs(overlap);\n      if (absOverlap < response['overlap']) {\n        response['overlap'] = absOverlap;\n        response['overlapN'].copy(axis);\n        if (overlap < 0) {\n          response['overlapN'].reverse();\n        }\n      }\n    }\n    T_VECTORS.push(offsetV);\n    T_ARRAYS.push(rangeA);\n    T_ARRAYS.push(rangeB);\n    return false;\n  }\n  SAT['isSeparatingAxis'] = isSeparatingAxis;\n\n  // Calculates which Voronoi region a point is on a line segment.\n  // It is assumed that both the line and the point are relative to `(0,0)`\n  //\n  //            |       (0)      |\n  //     (-1)  [S]--------------[E]  (1)\n  //            |       (0)      |\n  /**\n   * @param {Vector} line The line segment.\n   * @param {Vector} point The point.\n   * @return  {number} LEFT_VORONOI_REGION (-1) if it is the left region,\n   *          MIDDLE_VORONOI_REGION (0) if it is the middle region,\n   *          RIGHT_VORONOI_REGION (1) if it is the right region.\n   */\n  function voronoiRegion(line, point) {\n    var len2 = line.len2();\n    var dp = point.dot(line);\n    // If the point is beyond the start of the line, it is in the\n    // left voronoi region.\n    if (dp < 0) { return LEFT_VORONOI_REGION; }\n    // If the point is beyond the end of the line, it is in the\n    // right voronoi region.\n    else if (dp > len2) { return RIGHT_VORONOI_REGION; }\n    // Otherwise, it's in the middle one.\n    else { return MIDDLE_VORONOI_REGION; }\n  }\n  // Constants for Voronoi regions\n  /**\n   * @const\n   */\n  var LEFT_VORONOI_REGION = -1;\n  /**\n   * @const\n   */\n  var MIDDLE_VORONOI_REGION = 0;\n  /**\n   * @const\n   */\n  var RIGHT_VORONOI_REGION = 1;\n\n  // ## Collision Tests\n\n  // Check if a point is inside a circle.\n  /**\n   * @param {Vector} p The point to test.\n   * @param {Circle} c The circle to test.\n   * @return {boolean} true if the point is inside the circle, false if it is not.\n   */\n  function pointInCircle(p, c) {\n    var differenceV = T_VECTORS.pop().copy(p).sub(c['pos']).sub(c['offset']);\n    var radiusSq = c['r'] * c['r'];\n    var distanceSq = differenceV.len2();\n    T_VECTORS.push(differenceV);\n    // If the distance between is smaller than the radius then the point is inside the circle.\n    return distanceSq <= radiusSq;\n  }\n  SAT['pointInCircle'] = pointInCircle;\n\n  // Check if a point is inside a convex polygon.\n  /**\n   * @param {Vector} p The point to test.\n   * @param {Polygon} poly The polygon to test.\n   * @return {boolean} true if the point is inside the polygon, false if it is not.\n   */\n  function pointInPolygon(p, poly) {\n    TEST_POINT['pos'].copy(p);\n    T_RESPONSE.clear();\n    var result = testPolygonPolygon(TEST_POINT, poly, T_RESPONSE);\n    if (result) {\n      result = T_RESPONSE['aInB'];\n    }\n    return result;\n  }\n  SAT['pointInPolygon'] = pointInPolygon;\n\n  // Check if two circles collide.\n  /**\n   * @param {Circle} a The first circle.\n   * @param {Circle} b The second circle.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   the circles intersect.\n   * @return {boolean} true if the circles intersect, false if they don't.\n   */\n  function testCircleCircle(a, b, response) {\n    // Check if the distance between the centers of the two\n    // circles is greater than their combined radius.\n    var differenceV = T_VECTORS.pop().copy(b['pos']).add(b['offset']).sub(a['pos']).sub(a['offset']);\n    var totalRadius = a['r'] + b['r'];\n    var totalRadiusSq = totalRadius * totalRadius;\n    var distanceSq = differenceV.len2();\n    // If the distance is bigger than the combined radius, they don't intersect.\n    if (distanceSq > totalRadiusSq) {\n      T_VECTORS.push(differenceV);\n      return false;\n    }\n    // They intersect.  If we're calculating a response, calculate the overlap.\n    if (response) {\n      var dist = Math.sqrt(distanceSq);\n      response['a'] = a;\n      response['b'] = b;\n      response['overlap'] = totalRadius - dist;\n      response['overlapN'].copy(differenceV.normalize());\n      response['overlapV'].copy(differenceV).scale(response['overlap']);\n      response['aInB'] = a['r'] <= b['r'] && dist <= b['r'] - a['r'];\n      response['bInA'] = b['r'] <= a['r'] && dist <= a['r'] - b['r'];\n    }\n    T_VECTORS.push(differenceV);\n    return true;\n  }\n  SAT['testCircleCircle'] = testCircleCircle;\n\n  // Check if a polygon and a circle collide.\n  /**\n   * @param {Polygon} polygon The polygon.\n   * @param {Circle} circle The circle.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testPolygonCircle(polygon, circle, response) {\n    // Get the position of the circle relative to the polygon.\n    var circlePos = T_VECTORS.pop().copy(circle['pos']).add(circle['offset']).sub(polygon['pos']);\n    var radius = circle['r'];\n    var radius2 = radius * radius;\n    var points = polygon['calcPoints'];\n    var len = points.length;\n    var edge = T_VECTORS.pop();\n    var point = T_VECTORS.pop();\n\n    // For each edge in the polygon:\n    for (var i = 0; i < len; i++) {\n      var next = i === len - 1 ? 0 : i + 1;\n      var prev = i === 0 ? len - 1 : i - 1;\n      var overlap = 0;\n      var overlapN = null;\n\n      // Get the edge.\n      edge.copy(polygon['edges'][i]);\n      // Calculate the center of the circle relative to the starting point of the edge.\n      point.copy(circlePos).sub(points[i]);\n\n      // If the distance between the center of the circle and the point\n      // is bigger than the radius, the polygon is definitely not fully in\n      // the circle.\n      if (response && point.len2() > radius2) {\n        response['aInB'] = false;\n      }\n\n      // Calculate which Voronoi region the center of the circle is in.\n      var region = voronoiRegion(edge, point);\n      // If it's the left region:\n      if (region === LEFT_VORONOI_REGION) {\n        // We need to make sure we're in the RIGHT_VORONOI_REGION of the previous edge.\n        edge.copy(polygon['edges'][prev]);\n        // Calculate the center of the circle relative the starting point of the previous edge\n        var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);\n        region = voronoiRegion(edge, point2);\n        if (region === RIGHT_VORONOI_REGION) {\n          // It's in the region we want.  Check if the circle intersects the point.\n          var dist = point.len();\n          if (dist > radius) {\n            // No intersection\n            T_VECTORS.push(circlePos);\n            T_VECTORS.push(edge);\n            T_VECTORS.push(point);\n            T_VECTORS.push(point2);\n            return false;\n          } else if (response) {\n            // It intersects, calculate the overlap.\n            response['bInA'] = false;\n            overlapN = point.normalize();\n            overlap = radius - dist;\n          }\n        }\n        T_VECTORS.push(point2);\n        // If it's the right region:\n      } else if (region === RIGHT_VORONOI_REGION) {\n        // We need to make sure we're in the left region on the next edge\n        edge.copy(polygon['edges'][next]);\n        // Calculate the center of the circle relative to the starting point of the next edge.\n        point.copy(circlePos).sub(points[next]);\n        region = voronoiRegion(edge, point);\n        if (region === LEFT_VORONOI_REGION) {\n          // It's in the region we want.  Check if the circle intersects the point.\n          var dist = point.len();\n          if (dist > radius) {\n            // No intersection\n            T_VECTORS.push(circlePos);\n            T_VECTORS.push(edge);\n            T_VECTORS.push(point);\n            return false;\n          } else if (response) {\n            // It intersects, calculate the overlap.\n            response['bInA'] = false;\n            overlapN = point.normalize();\n            overlap = radius - dist;\n          }\n        }\n        // Otherwise, it's the middle region:\n      } else {\n        // Need to check if the circle is intersecting the edge,\n        // Change the edge into its \"edge normal\".\n        var normal = edge.perp().normalize();\n        // Find the perpendicular distance between the center of the\n        // circle and the edge.\n        var dist = point.dot(normal);\n        var distAbs = Math.abs(dist);\n        // If the circle is on the outside of the edge, there is no intersection.\n        if (dist > 0 && distAbs > radius) {\n          // No intersection\n          T_VECTORS.push(circlePos);\n          T_VECTORS.push(normal);\n          T_VECTORS.push(point);\n          return false;\n        } else if (response) {\n          // It intersects, calculate the overlap.\n          overlapN = normal;\n          overlap = radius - dist;\n          // If the center of the circle is on the outside of the edge, or part of the\n          // circle is on the outside, the circle is not fully inside the polygon.\n          if (dist >= 0 || overlap < 2 * radius) {\n            response['bInA'] = false;\n          }\n        }\n      }\n\n      // If this is the smallest overlap we've seen, keep it.\n      // (overlapN may be null if the circle was in the wrong Voronoi region).\n      if (overlapN && response && Math.abs(overlap) < Math.abs(response['overlap'])) {\n        response['overlap'] = overlap;\n        response['overlapN'].copy(overlapN);\n      }\n    }\n\n    // Calculate the final overlap vector - based on the smallest overlap.\n    if (response) {\n      response['a'] = polygon;\n      response['b'] = circle;\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n    }\n    T_VECTORS.push(circlePos);\n    T_VECTORS.push(edge);\n    T_VECTORS.push(point);\n    return true;\n  }\n  SAT['testPolygonCircle'] = testPolygonCircle;\n\n  // Check if a circle and a polygon collide.\n  //\n  // **NOTE:** This is slightly less efficient than polygonCircle as it just\n  // runs polygonCircle and reverses everything at the end.\n  /**\n   * @param {Circle} circle The circle.\n   * @param {Polygon} polygon The polygon.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testCirclePolygon(circle, polygon, response) {\n    // Test the polygon against the circle.\n    var result = testPolygonCircle(polygon, circle, response);\n    if (result && response) {\n      // Swap A and B in the response.\n      var a = response['a'];\n      var aInB = response['aInB'];\n      response['overlapN'].reverse();\n      response['overlapV'].reverse();\n      response['a'] = response['b'];\n      response['b'] = a;\n      response['aInB'] = response['bInA'];\n      response['bInA'] = aInB;\n    }\n    return result;\n  }\n  SAT['testCirclePolygon'] = testCirclePolygon;\n\n  // Checks whether polygons collide.\n  /**\n   * @param {Polygon} a The first polygon.\n   * @param {Polygon} b The second polygon.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testPolygonPolygon(a, b, response) {\n    var aPoints = a['calcPoints'];\n    var aLen = aPoints.length;\n    var bPoints = b['calcPoints'];\n    var bLen = bPoints.length;\n    // If any of the edge normals of A is a separating axis, no intersection.\n    for (var i = 0; i < aLen; i++) {\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, a['normals'][i], response)) {\n        return false;\n      }\n    }\n    // If any of the edge normals of B is a separating axis, no intersection.\n    for (var i = 0; i < bLen; i++) {\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, b['normals'][i], response)) {\n        return false;\n      }\n    }\n    // Since none of the edge normals of A or B are a separating axis, there is an intersection\n    // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the\n    // final overlap vector.\n    if (response) {\n      response['a'] = a;\n      response['b'] = b;\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n    }\n    return true;\n  }\n  SAT['testPolygonPolygon'] = testPolygonPolygon;\n\n  return SAT;\n}));\n", "\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BodyType = exports.SATCircle = exports.SATPolygon = exports.SATVector = exports.Response = exports.RBush = void 0;\nconst rbush_1 = __importDefault(require(\"rbush\"));\nObject.defineProperty(exports, \"RBush\", { enumerable: true, get: function () { return rbush_1.default; } });\nconst sat_1 = require(\"sat\");\nObject.defineProperty(exports, \"Response\", { enumerable: true, get: function () { return sat_1.Response; } });\nObject.defineProperty(exports, \"SATVector\", { enumerable: true, get: function () { return sat_1.Vector; } });\nObject.defineProperty(exports, \"SATPolygon\", { enumerable: true, get: function () { return sat_1.Polygon; } });\nObject.defineProperty(exports, \"SATCircle\", { enumerable: true, get: function () { return sat_1.Circle; } });\n/**\n * types\n */\nvar BodyType;\n(function (BodyType) {\n    BodyType[\"Ellipse\"] = \"Ellipse\";\n    BodyType[\"Line\"] = \"Line\";\n    BodyType[\"Circle\"] = \"Circle\";\n    BodyType[\"Box\"] = \"Box\";\n    BodyType[\"Point\"] = \"Point\";\n    BodyType[\"Polygon\"] = \"Polygon\";\n})(BodyType || (exports.BodyType = BodyType = {}));\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.map = exports.filter = exports.every = exports.some = exports.forEach = void 0;\n/**\n * 40-90% faster than built-in Array.forEach function.\n *\n * basic benchmark: https://jsbench.me/urle772xdn\n */\nconst forEach = (array, callback) => {\n    for (let i = 0, l = array.length; i < l; i++) {\n        callback(array[i], i);\n    }\n};\nexports.forEach = forEach;\n/**\n * 20-90% faster than built-in Array.some function.\n *\n * basic benchmark: https://jsbench.me/l0le7bnnsq\n */\nconst some = (array, callback) => {\n    for (let i = 0, l = array.length; i < l; i++) {\n        if (callback(array[i], i)) {\n            return true;\n        }\n    }\n    return false;\n};\nexports.some = some;\n/**\n * 20-40% faster than built-in Array.every function.\n *\n * basic benchmark: https://jsbench.me/unle7da29v\n */\nconst every = (array, callback) => {\n    for (let i = 0, l = array.length; i < l; i++) {\n        if (!callback(array[i], i)) {\n            return false;\n        }\n    }\n    return true;\n};\nexports.every = every;\n/**\n * 20-60% faster than built-in Array.filter function.\n *\n * basic benchmark: https://jsbench.me/o1le77ev4l\n */\nconst filter = (array, callback) => {\n    const output = [];\n    for (let i = 0, l = array.length; i < l; i++) {\n        const item = array[i];\n        if (callback(item, i)) {\n            output.push(item);\n        }\n    }\n    return output;\n};\nexports.filter = filter;\n/**\n * 20-70% faster than built-in Array.map\n *\n * basic benchmark: https://jsbench.me/oyle77vbpc\n */\nconst map = (array, callback) => {\n    const output = new Array(array.length);\n    for (let i = 0, l = array.length; i < l; i++) {\n        output[i] = callback(array[i], i);\n    }\n    return output;\n};\nexports.map = map;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.intersectLinePolygon = exports.intersectLineLine = exports.intersectLineLineFast = exports.intersectLineCircle = exports.circleOutsidePolygon = exports.circleInPolygon = exports.circleInCircle = exports.pointOnCircle = exports.polygonInPolygon = exports.pointInPolygon = exports.polygonInCircle = exports.ensureConvex = void 0;\nconst sat_1 = require(\"sat\");\nconst model_1 = require(\"./model\");\nconst optimized_1 = require(\"./optimized\");\n/**\n * replace body with array of related convex polygons\n */\nfunction ensureConvex(body) {\n    if (body.isConvex || body.type !== model_1.BodyType.Polygon) {\n        return [body];\n    }\n    return body.convexPolygons;\n}\nexports.ensureConvex = ensureConvex;\nfunction polygonInCircle(polygon, circle) {\n    return (0, optimized_1.every)(polygon.calcPoints, (p) => (0, sat_1.pointInCircle)({ x: p.x + polygon.pos.x, y: p.y + polygon.pos.y }, circle));\n}\nexports.polygonInCircle = polygonInCircle;\nfunction pointInPolygon(point, polygon) {\n    return (0, optimized_1.some)(ensureConvex(polygon), (convex) => (0, sat_1.pointInPolygon)(point, convex));\n}\nexports.pointInPolygon = pointInPolygon;\nfunction polygonInPolygon(polygonA, polygonB) {\n    return (0, optimized_1.every)(polygonA.calcPoints, (point) => pointInPolygon({ x: point.x + polygonA.pos.x, y: point.y + polygonA.pos.y }, polygonB));\n}\nexports.polygonInPolygon = polygonInPolygon;\n/**\n * https://stackoverflow.com/a/68197894/1749528\n */\nfunction pointOnCircle(point, circle) {\n    return ((point.x - circle.pos.x) * (point.x - circle.pos.x) +\n        (point.y - circle.pos.y) * (point.y - circle.pos.y) ===\n        circle.r * circle.r);\n}\nexports.pointOnCircle = pointOnCircle;\n/**\n * https://stackoverflow.com/a/68197894/1749528\n */\nfunction circleInCircle(a, b) {\n    const x1 = a.pos.x;\n    const y1 = a.pos.y;\n    const x2 = b.pos.x;\n    const y2 = b.pos.y;\n    const r1 = a.r;\n    const r2 = b.r;\n    const distSq = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    return distSq + r2 === r1 || distSq + r2 < r1;\n}\nexports.circleInCircle = circleInCircle;\n/**\n * https://stackoverflow.com/a/68197894/1749528\n */\nfunction circleInPolygon(circle, polygon) {\n    // Circle with radius 0 isn't a circle\n    if (circle.r === 0) {\n        return false;\n    }\n    // If the center of the circle is not within the polygon,\n    // then the circle may overlap, but it'll never be \"contained\"\n    // so return false\n    if (!pointInPolygon(circle.pos, polygon)) {\n        return false;\n    }\n    // Necessary add polygon pos to points\n    const points = (0, optimized_1.map)(polygon.calcPoints, ({ x, y }) => ({\n        x: x + polygon.pos.x,\n        y: y + polygon.pos.y,\n    }));\n    // If the center of the circle is within the polygon,\n    // the circle is not outside of the polygon completely.\n    // so return false.\n    if ((0, optimized_1.some)(points, (point) => (0, sat_1.pointInCircle)(point, circle))) {\n        return false;\n    }\n    // If any line-segment of the polygon intersects the circle,\n    // the circle is not \"contained\"\n    // so return false\n    if ((0, optimized_1.some)(points, (end, index) => {\n        const start = index\n            ? points[index - 1]\n            : points[points.length - 1];\n        return intersectLineCircle({ start, end }, circle).length > 0;\n    })) {\n        return false;\n    }\n    return true;\n}\nexports.circleInPolygon = circleInPolygon;\n/**\n * https://stackoverflow.com/a/68197894/1749528\n */\nfunction circleOutsidePolygon(circle, polygon) {\n    // Circle with radius 0 isn't a circle\n    if (circle.r === 0) {\n        return false;\n    }\n    // If the center of the circle is within the polygon,\n    // the circle is not outside of the polygon completely.\n    // so return false.\n    if (pointInPolygon(circle.pos, polygon)) {\n        return false;\n    }\n    // Necessary add polygon pos to points\n    const points = (0, optimized_1.map)(polygon.calcPoints, ({ x, y }) => ({\n        x: x + polygon.pos.x,\n        y: y + polygon.pos.y,\n    }));\n    // If the center of the circle is within the polygon,\n    // the circle is not outside of the polygon completely.\n    // so return false.\n    if ((0, optimized_1.some)(points, (point) => (0, sat_1.pointInCircle)(point, circle) || pointOnCircle(point, circle))) {\n        return false;\n    }\n    // If any line-segment of the polygon intersects the circle,\n    // the circle is not \"contained\"\n    // so return false\n    if ((0, optimized_1.some)(points, (end, index) => {\n        const start = index\n            ? points[index - 1]\n            : points[points.length - 1];\n        return intersectLineCircle({ start, end }, circle).length > 0;\n    })) {\n        return false;\n    }\n    return true;\n}\nexports.circleOutsidePolygon = circleOutsidePolygon;\n/**\n * https://stackoverflow.com/a/37225895/1749528\n */\nfunction intersectLineCircle(line, { pos, r }) {\n    const v1 = { x: line.end.x - line.start.x, y: line.end.y - line.start.y };\n    const v2 = { x: line.start.x - pos.x, y: line.start.y - pos.y };\n    const b = (v1.x * v2.x + v1.y * v2.y) * -2;\n    const c = (v1.x * v1.x + v1.y * v1.y) * 2;\n    const d = Math.sqrt(b * b - (v2.x * v2.x + v2.y * v2.y - r * r) * c * 2);\n    if (isNaN(d)) {\n        // no intercept\n        return [];\n    }\n    const u1 = (b - d) / c; // these represent the unit distance of point one and two on the line\n    const u2 = (b + d) / c;\n    const results = []; // return array\n    if (u1 <= 1 && u1 >= 0) {\n        // add point if on the line segment\n        results.push({ x: line.start.x + v1.x * u1, y: line.start.y + v1.y * u1 });\n    }\n    if (u2 <= 1 && u2 >= 0) {\n        // second add point if on the line segment\n        results.push({ x: line.start.x + v1.x * u2, y: line.start.y + v1.y * u2 });\n    }\n    return results;\n}\nexports.intersectLineCircle = intersectLineCircle;\n/**\n * helper for intersectLineLineFast\n */\nfunction isTurn(point1, point2, point3) {\n    const A = (point3.x - point1.x) * (point2.y - point1.y);\n    const B = (point2.x - point1.x) * (point3.y - point1.y);\n    return A > B + Number.EPSILON ? 1 : A + Number.EPSILON < B ? -1 : 0;\n}\n/**\n * faster implementation of intersectLineLine\n * https://stackoverflow.com/a/16725715/1749528\n */\nfunction intersectLineLineFast(line1, line2) {\n    return (isTurn(line1.start, line2.start, line2.end) !==\n        isTurn(line1.end, line2.start, line2.end) &&\n        isTurn(line1.start, line1.end, line2.start) !==\n            isTurn(line1.start, line1.end, line2.end));\n}\nexports.intersectLineLineFast = intersectLineLineFast;\n/**\n * returns the point of intersection\n * https://stackoverflow.com/a/24392281/1749528\n */\nfunction intersectLineLine(line1, line2) {\n    const dX = line1.end.x - line1.start.x;\n    const dY = line1.end.y - line1.start.y;\n    const determinant = dX * (line2.end.y - line2.start.y) - (line2.end.x - line2.start.x) * dY;\n    if (determinant === 0) {\n        return null;\n    }\n    const lambda = ((line2.end.y - line2.start.y) * (line2.end.x - line1.start.x) +\n        (line2.start.x - line2.end.x) * (line2.end.y - line1.start.y)) /\n        determinant;\n    const gamma = ((line1.start.y - line1.end.y) * (line2.end.x - line1.start.x) +\n        dX * (line2.end.y - line1.start.y)) /\n        determinant;\n    // check if there is an intersection\n    if (!(lambda >= 0 && lambda <= 1) || !(gamma >= 0 && gamma <= 1)) {\n        return null;\n    }\n    return { x: line1.start.x + lambda * dX, y: line1.start.y + lambda * dY };\n}\nexports.intersectLineLine = intersectLineLine;\nfunction intersectLinePolygon(line, polygon) {\n    const results = [];\n    (0, optimized_1.forEach)(polygon.calcPoints, (to, index) => {\n        const from = index\n            ? polygon.calcPoints[index - 1]\n            : polygon.calcPoints[polygon.calcPoints.length - 1];\n        const side = {\n            start: { x: from.x + polygon.pos.x, y: from.y + polygon.pos.y },\n            end: { x: to.x + polygon.pos.x, y: to.y + polygon.pos.y },\n        };\n        const hit = intersectLineLine(line, side);\n        if (hit) {\n            results.push(hit);\n        }\n    });\n    return results;\n}\nexports.intersectLinePolygon = intersectLinePolygon;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.drawBVH = exports.drawPolygon = exports.getSATTest = exports.getBounceDirection = exports.mapArrayToVector = exports.mapVectorToArray = exports.dashLineTo = exports.clonePointsArray = exports.checkAInB = exports.intersectAABB = exports.notIntersectAABB = exports.bodyMoved = exports.extendBody = exports.clockwise = exports.distance = exports.ensurePolygonPoints = exports.ensureVectorPoint = exports.createBox = exports.createEllipse = exports.rad2deg = exports.deg2rad = exports.RAD2DEG = exports.DEG2RAD = void 0;\nconst sat_1 = require(\"sat\");\nconst intersect_1 = require(\"./intersect\");\nconst model_1 = require(\"./model\");\nconst optimized_1 = require(\"./optimized\");\nexports.DEG2RAD = Math.PI / 180;\nexports.RAD2DEG = 180 / Math.PI;\n/**\n * convert from degrees to radians\n */\nfunction deg2rad(degrees) {\n    return degrees * exports.DEG2RAD;\n}\nexports.deg2rad = deg2rad;\n/**\n * convert from radians to degrees\n */\nfunction rad2deg(radians) {\n    return radians * exports.RAD2DEG;\n}\nexports.rad2deg = rad2deg;\n/**\n * creates ellipse-shaped polygon based on params\n */\nfunction createEllipse(radiusX, radiusY = radiusX, step = 1) {\n    const steps = Math.PI * Math.hypot(radiusX, radiusY) * 2;\n    const length = Math.max(8, Math.ceil(steps / Math.max(1, step)));\n    return Array.from({ length }, (_, index) => {\n        const value = (index / length) * 2 * Math.PI;\n        const x = Math.cos(value) * radiusX;\n        const y = Math.sin(value) * radiusY;\n        return new sat_1.Vector(x, y);\n    });\n}\nexports.createEllipse = createEllipse;\n/**\n * creates box polygon points\n */\nfunction createBox(width, height) {\n    return [\n        new sat_1.Vector(0, 0),\n        new sat_1.Vector(width, 0),\n        new sat_1.Vector(width, height),\n        new sat_1.Vector(0, height),\n    ];\n}\nexports.createBox = createBox;\n/**\n * ensure Vector point\n */\nfunction ensureVectorPoint(point = {}) {\n    return point instanceof sat_1.Vector\n        ? point\n        : new sat_1.Vector(point.x || 0, point.y || 0);\n}\nexports.ensureVectorPoint = ensureVectorPoint;\n/**\n * ensure Vector points (for polygon) in counter-clockwise order\n */\nfunction ensurePolygonPoints(points) {\n    if (!points) {\n        throw new Error(\"No points array provided\");\n    }\n    const polygonPoints = (0, optimized_1.map)(points, ensureVectorPoint);\n    return clockwise(polygonPoints) ? polygonPoints.reverse() : polygonPoints;\n}\nexports.ensurePolygonPoints = ensurePolygonPoints;\n/**\n * get distance between two Vector points\n */\nfunction distance(a, b) {\n    return Math.hypot(a.x - b.x, a.y - b.y);\n}\nexports.distance = distance;\n/**\n * check direction of polygon\n */\nfunction clockwise(points) {\n    let sum = 0;\n    for (let i = 0; i < points.length; i++) {\n        const v1 = points[i];\n        const v2 = points[(i + 1) % points.length];\n        sum += (v2.x - v1.x) * (v2.y + v1.y);\n    }\n    return sum > 0;\n}\nexports.clockwise = clockwise;\n/**\n * used for all types of bodies\n */\nfunction extendBody(body, options) {\n    body.isStatic = !!(options === null || options === void 0 ? void 0 : options.isStatic);\n    body.isTrigger = !!(options === null || options === void 0 ? void 0 : options.isTrigger);\n    body.padding = (options === null || options === void 0 ? void 0 : options.padding) || 0;\n    if (body.type !== model_1.BodyType.Circle) {\n        body.isCentered = (options === null || options === void 0 ? void 0 : options.isCentered) || false;\n    }\n    body.setAngle((options === null || options === void 0 ? void 0 : options.angle) || 0);\n}\nexports.extendBody = extendBody;\n/**\n * check if body moved outside of its padding\n */\nfunction bodyMoved(body) {\n    return (body.bbox.minX < body.minX ||\n        body.bbox.minY < body.minY ||\n        body.bbox.maxX > body.maxX ||\n        body.bbox.maxY > body.maxY);\n}\nexports.bodyMoved = bodyMoved;\n/**\n * returns true if two boxes not intersect\n */\nfunction notIntersectAABB(a, b) {\n    return (b.minX > a.maxX || b.minY > a.maxY || b.maxX < a.minX || b.maxY < a.minY);\n}\nexports.notIntersectAABB = notIntersectAABB;\n/**\n * checks if two boxes intersect\n */\nfunction intersectAABB(a, b) {\n    return !notIntersectAABB(a, b);\n}\nexports.intersectAABB = intersectAABB;\n/**\n * checks if body a is in body b\n */\nfunction checkAInB(a, b) {\n    if (a.type === model_1.BodyType.Circle) {\n        if (b.type !== model_1.BodyType.Circle) {\n            return (0, intersect_1.circleInPolygon)(a, b);\n        }\n        return (0, intersect_1.circleInCircle)(a, b);\n    }\n    if (b.type === model_1.BodyType.Circle) {\n        return (0, intersect_1.polygonInCircle)(a, b);\n    }\n    return (0, intersect_1.polygonInPolygon)(a, b);\n}\nexports.checkAInB = checkAInB;\n/**\n * clone sat vector points array into vector points array\n */\nfunction clonePointsArray(points) {\n    return (0, optimized_1.map)(points, ({ x, y }) => ({\n        x,\n        y,\n    }));\n}\nexports.clonePointsArray = clonePointsArray;\n/**\n * draws dashed line on canvas context\n */\nfunction dashLineTo(context, fromX, fromY, toX, toY, dash = 2, gap = 4) {\n    const xDiff = toX - fromX;\n    const yDiff = toY - fromY;\n    const arc = Math.atan2(yDiff, xDiff);\n    const offsetX = Math.cos(arc);\n    const offsetY = Math.sin(arc);\n    let posX = fromX;\n    let posY = fromY;\n    let dist = Math.hypot(xDiff, yDiff);\n    while (dist > 0) {\n        const step = Math.min(dist, dash);\n        context.moveTo(posX, posY);\n        context.lineTo(posX + offsetX * step, posY + offsetY * step);\n        posX += offsetX * (dash + gap);\n        posY += offsetY * (dash + gap);\n        dist -= dash + gap;\n    }\n}\nexports.dashLineTo = dashLineTo;\n/**\n * change format from poly-decomp to SAT.js\n */\nfunction mapVectorToArray({ x, y } = { x: 0, y: 0 }) {\n    return [x, y];\n}\nexports.mapVectorToArray = mapVectorToArray;\n/**\n * change format from SAT.js to poly-decomp\n */\nfunction mapArrayToVector([x, y] = [0, 0]) {\n    return { x, y };\n}\nexports.mapArrayToVector = mapArrayToVector;\n/**\n * given 2 bodies calculate vector of bounce assuming equal mass and they are circles\n */\nfunction getBounceDirection(body, collider) {\n    const v2 = new sat_1.Vector(collider.x - body.x, collider.y - body.y);\n    const v1 = new sat_1.Vector(body.x - collider.x, body.y - collider.y);\n    const len = v1.dot(v2.normalize()) * 2;\n    return new sat_1.Vector(v2.x * len - v1.x, v2.y * len - v1.y).normalize();\n}\nexports.getBounceDirection = getBounceDirection;\n/**\n * returns correct sat.js testing function based on body types\n */\nfunction getSATTest(body, wall) {\n    if (body.type === model_1.BodyType.Circle) {\n        return wall.type === model_1.BodyType.Circle ? sat_1.testCircleCircle : sat_1.testCirclePolygon;\n    }\n    return wall.type === model_1.BodyType.Circle ? sat_1.testPolygonCircle : sat_1.testPolygonPolygon;\n}\nexports.getSATTest = getSATTest;\n/**\n * draw polygon\n */\nfunction drawPolygon(context, { pos, calcPoints, }, isTrigger = false) {\n    const lastPoint = calcPoints[calcPoints.length - 1];\n    const fromX = pos.x + lastPoint.x;\n    const fromY = pos.y + lastPoint.y;\n    if (calcPoints.length === 1) {\n        context.arc(fromX, fromY, 1, 0, Math.PI * 2);\n    }\n    else {\n        context.moveTo(fromX, fromY);\n    }\n    (0, optimized_1.forEach)(calcPoints, (point, index) => {\n        const toX = pos.x + point.x;\n        const toY = pos.y + point.y;\n        if (isTrigger) {\n            const prev = calcPoints[index - 1] || lastPoint;\n            dashLineTo(context, pos.x + prev.x, pos.y + prev.y, toX, toY);\n        }\n        else {\n            context.lineTo(toX, toY);\n        }\n    });\n}\nexports.drawPolygon = drawPolygon;\n/**\n * draw body bounding body\n */\nfunction drawBVH(context, body) {\n    drawPolygon(context, {\n        pos: { x: body.minX, y: body.minY },\n        calcPoints: createBox(body.maxX - body.minX, body.maxY - body.minY),\n    });\n}\nexports.drawBVH = drawBVH;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Circle = void 0;\nconst sat_1 = require(\"sat\");\nconst model_1 = require(\"../model\");\nconst utils_1 = require(\"../utils\");\n/**\n * collider - circle\n */\nclass Circle extends sat_1.Circle {\n    /**\n     * collider - circle\n     */\n    constructor(position, radius, options) {\n        super((0, utils_1.ensureVectorPoint)(position), radius);\n        /**\n         * offset copy without angle applied\n         */\n        this.offsetCopy = { x: 0, y: 0 };\n        /**\n         * was the polygon modified and needs update in the next checkCollision\n         */\n        this.dirty = false;\n        /*\n         * circles are convex\n         */\n        this.isConvex = true;\n        /**\n         * circle type\n         */\n        this.type = model_1.BodyType.Circle;\n        /**\n         * always centered\n         */\n        this.isCentered = true;\n        (0, utils_1.extendBody)(this, options);\n        this.unscaledRadius = radius;\n    }\n    /**\n     * get this.pos.x\n     */\n    get x() {\n        return this.pos.x;\n    }\n    /**\n     * updating this.pos.x by this.x = x updates AABB\n     */\n    set x(x) {\n        this.pos.x = x;\n        this.dirty = true;\n    }\n    /**\n     * get this.pos.y\n     */\n    get y() {\n        return this.pos.y;\n    }\n    /**\n     * updating this.pos.y by this.y = y updates AABB\n     */\n    set y(y) {\n        this.pos.y = y;\n        this.dirty = true;\n    }\n    /**\n     * allow get scale\n     */\n    get scale() {\n        return this.r / this.unscaledRadius;\n    }\n    /**\n     * shorthand for setScale()\n     */\n    set scale(scale) {\n        this.setScale(scale);\n    }\n    /**\n     * scaleX = scale in case of Circles\n     */\n    get scaleX() {\n        return this.scale;\n    }\n    /**\n     * scaleY = scale in case of Circles\n     */\n    get scaleY() {\n        return this.scale;\n    }\n    /**\n     * update position\n     */\n    setPosition(x, y, update = true) {\n        this.pos.x = x;\n        this.pos.y = y;\n        this.dirty = true;\n        if (update) {\n            this.updateBody();\n        }\n        return this;\n    }\n    /**\n     * update scale\n     */\n    setScale(scaleX, _scaleY = scaleX, update = true) {\n        this.r = this.unscaledRadius * Math.abs(scaleX);\n        this.dirty = true;\n        if (update) {\n            this.updateBody();\n        }\n        return this;\n    }\n    /**\n     * set rotation\n     */\n    setAngle(angle, update = true) {\n        this.angle = angle;\n        const { x, y } = this.getOffsetWithAngle();\n        this.offset.x = x;\n        this.offset.y = y;\n        this.dirty = true;\n        if (update) {\n            this.updateBody();\n        }\n        return this;\n    }\n    /**\n     * set offset from center\n     */\n    setOffset(offset, update = true) {\n        this.offsetCopy.x = offset.x;\n        this.offsetCopy.y = offset.y;\n        const { x, y } = this.getOffsetWithAngle();\n        this.offset.x = x;\n        this.offset.y = y;\n        this.dirty = true;\n        if (update) {\n            this.updateBody();\n        }\n        return this;\n    }\n    /**\n     * get body bounding box, without padding\n     */\n    getAABBAsBBox() {\n        const x = this.pos.x + this.offset.x;\n        const y = this.pos.y + this.offset.y;\n        return {\n            minX: x - this.r,\n            maxX: x + this.r,\n            minY: y - this.r,\n            maxY: y + this.r,\n        };\n    }\n    /**\n     * Draws collider on a CanvasRenderingContext2D's current path\n     */\n    draw(context) {\n        const x = this.pos.x + this.offset.x;\n        const y = this.pos.y + this.offset.y;\n        const r = Math.abs(this.r);\n        if (this.isTrigger) {\n            const max = Math.max(8, this.r);\n            for (let i = 0; i < max; i++) {\n                const arc = (i / max) * 2 * Math.PI;\n                const arcPrev = ((i - 1) / max) * 2 * Math.PI;\n                const fromX = x + Math.cos(arcPrev) * this.r;\n                const fromY = y + Math.sin(arcPrev) * this.r;\n                const toX = x + Math.cos(arc) * this.r;\n                const toY = y + Math.sin(arc) * this.r;\n                (0, utils_1.dashLineTo)(context, fromX, fromY, toX, toY);\n            }\n        }\n        else {\n            context.moveTo(x + r, y);\n            context.arc(x, y, r, 0, Math.PI * 2);\n        }\n    }\n    /**\n     * Draws Bounding Box on canvas context\n     */\n    drawBVH(context) {\n        (0, utils_1.drawBVH)(context, this);\n    }\n    /**\n     * inner function for after position change update aabb in system\n     */\n    updateBody(update = this.dirty) {\n        var _a;\n        if (update) {\n            (_a = this.system) === null || _a === void 0 ? void 0 : _a.insert(this);\n            this.dirty = false;\n        }\n    }\n    /**\n     * update instantly or mark as dirty\n     */\n    markAsDirty(update) {\n        if (update) {\n            this.updateBody(true);\n        }\n        else {\n            this.dirty = true;\n        }\n    }\n    /**\n     * internal for getting offset with applied angle\n     */\n    getOffsetWithAngle() {\n        if ((!this.offsetCopy.x && !this.offsetCopy.y) || !this.angle) {\n            return this.offsetCopy;\n        }\n        const sin = Math.sin(this.angle);\n        const cos = Math.cos(this.angle);\n        const x = this.offsetCopy.x * cos - this.offsetCopy.y * sin;\n        const y = this.offsetCopy.x * sin + this.offsetCopy.y * cos;\n        return { x, y };\n    }\n}\nexports.Circle = Circle;\n", "module.exports = {\n    decomp: polygonDecomp,\n    quickDecomp: polygonQuickDecomp,\n    isSimple: polygonIsSimple,\n    removeCollinearPoints: polygonRemoveCollinearPoints,\n    removeDuplicatePoints: polygonRemoveDuplicatePoints,\n    makeCCW: polygonMakeCCW\n};\n\n/**\n * Compute the intersection between two lines.\n * @static\n * @method lineInt\n * @param  {Array}  l1          Line vector 1\n * @param  {Array}  l2          Line vector 2\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\n * @return {Array}              The intersection point.\n */\nfunction lineInt(l1,l2,precision){\n    precision = precision || 0;\n    var i = [0,0]; // point\n    var a1, b1, c1, a2, b2, c2, det; // scalars\n    a1 = l1[1][1] - l1[0][1];\n    b1 = l1[0][0] - l1[1][0];\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\n    a2 = l2[1][1] - l2[0][1];\n    b2 = l2[0][0] - l2[1][0];\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\n    det = a1 * b2 - a2*b1;\n    if (!scalar_eq(det, 0, precision)) { // lines are not parallel\n        i[0] = (b2 * c1 - b1 * c2) / det;\n        i[1] = (a1 * c2 - a2 * c1) / det;\n    }\n    return i;\n}\n\n/**\n * Checks if two line segments intersects.\n * @method segmentsIntersect\n * @param {Array} p1 The start vertex of the first line segment.\n * @param {Array} p2 The end vertex of the first line segment.\n * @param {Array} q1 The start vertex of the second line segment.\n * @param {Array} q2 The end vertex of the second line segment.\n * @return {Boolean} True if the two line segments intersect\n */\nfunction lineSegmentsIntersect(p1, p2, q1, q2){\n\tvar dx = p2[0] - p1[0];\n\tvar dy = p2[1] - p1[1];\n\tvar da = q2[0] - q1[0];\n\tvar db = q2[1] - q1[1];\n\n\t// segments are parallel\n\tif((da*dy - db*dx) === 0){\n\t\treturn false;\n\t}\n\n\tvar s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n\tvar t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n\n\treturn (s>=0 && s<=1 && t>=0 && t<=1);\n}\n\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @static\n * @method area\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return {Number}\n */\nfunction triangleArea(a,b,c){\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\n}\n\nfunction isLeft(a,b,c){\n    return triangleArea(a,b,c) > 0;\n}\n\nfunction isLeftOn(a,b,c) {\n    return triangleArea(a, b, c) >= 0;\n}\n\nfunction isRight(a,b,c) {\n    return triangleArea(a, b, c) < 0;\n}\n\nfunction isRightOn(a,b,c) {\n    return triangleArea(a, b, c) <= 0;\n}\n\nvar tmpPoint1 = [],\n    tmpPoint2 = [];\n\n/**\n * Check if three points are collinear\n * @method collinear\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return {Boolean}\n */\nfunction collinear(a,b,c,thresholdAngle) {\n    if(!thresholdAngle){\n        return triangleArea(a, b, c) === 0;\n    } else {\n        var ab = tmpPoint1,\n            bc = tmpPoint2;\n\n        ab[0] = b[0]-a[0];\n        ab[1] = b[1]-a[1];\n        bc[0] = c[0]-b[0];\n        bc[1] = c[1]-b[1];\n\n        var dot = ab[0]*bc[0] + ab[1]*bc[1],\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\n            angle = Math.acos(dot/(magA*magB));\n        return angle < thresholdAngle;\n    }\n}\n\nfunction sqdist(a,b){\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    return dx * dx + dy * dy;\n}\n\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @method at\n * @param  {Number} i\n * @return {Array}\n */\nfunction polygonAt(polygon, i){\n    var s = polygon.length;\n    return polygon[i < 0 ? i % s + s : i % s];\n}\n\n/**\n * Clear the polygon data\n * @method clear\n * @return {Array}\n */\nfunction polygonClear(polygon){\n    polygon.length = 0;\n}\n\n/**\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\n * @method append\n * @param {Polygon} poly The polygon to get points from.\n * @param {Number}  from The vertex index in \"poly\".\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n * @return {Array}\n */\nfunction polygonAppend(polygon, poly, from, to){\n    for(var i=from; i<to; i++){\n        polygon.push(poly[i]);\n    }\n}\n\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n * @method makeCCW\n */\nfunction polygonMakeCCW(polygon){\n    var br = 0,\n        v = polygon;\n\n    // find bottom right point\n    for (var i = 1; i < polygon.length; ++i) {\n        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {\n            br = i;\n        }\n    }\n\n    // reverse poly if clockwise\n    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n        polygonReverse(polygon);\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * Reverse the vertices in the polygon\n * @method reverse\n */\nfunction polygonReverse(polygon){\n    var tmp = [];\n    var N = polygon.length;\n    for(var i=0; i!==N; i++){\n        tmp.push(polygon.pop());\n    }\n    for(var i=0; i!==N; i++){\n\t\tpolygon[i] = tmp[i];\n    }\n}\n\n/**\n * Check if a point in the polygon is a reflex point\n * @method isReflex\n * @param  {Number}  i\n * @return {Boolean}\n */\nfunction polygonIsReflex(polygon, i){\n    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n}\n\nvar tmpLine1=[],\n    tmpLine2=[];\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee(polygon, a,b) {\n    var p, dist, l1=tmpLine1, l2=tmpLine2;\n\n    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\n        return false;\n    }\n    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n    for (var i = 0; i !== polygon.length; ++i) { // for each edge\n        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges\n            continue;\n        }\n        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge\n            l1[0] = polygonAt(polygon, a);\n            l1[1] = polygonAt(polygon, b);\n            l2[0] = polygonAt(polygon, i);\n            l2[1] = polygonAt(polygon, i + 1);\n            p = lineInt(l1,l2);\n            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee2\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee2(polygon, a,b) {\n    // for each edge\n    for (var i = 0; i !== polygon.length; ++i) {\n        // ignore incident edges\n        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b){\n            continue;\n        }\n        if( lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i+1)) ){\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Copy the polygon from vertex i to vertex j.\n * @method copy\n * @param  {Number} i\n * @param  {Number} j\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\n * @return {Polygon}                The resulting copy.\n */\nfunction polygonCopy(polygon, i,j,targetPoly){\n    var p = targetPoly || [];\n    polygonClear(p);\n    if (i < j) {\n        // Insert all vertices from i to j\n        for(var k=i; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n    } else {\n\n        // Insert vertices 0 to j\n        for(var k=0; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n        // Insert vertices i to end\n        for(var k=i; k<polygon.length; k++){\n            p.push(polygon[k]);\n        }\n    }\n\n    return p;\n}\n\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @method getCutEdges\n * @return {Array}\n */\nfunction polygonGetCutEdges(polygon) {\n    var min=[], tmp1=[], tmp2=[], tmpPoly = [];\n    var nDiags = Number.MAX_VALUE;\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(polygon, i)) {\n            for (var j = 0; j < polygon.length; ++j) {\n                if (polygonCanSee(polygon, i, j)) {\n                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n\n                    for(var k=0; k<tmp2.length; k++){\n                        tmp1.push(tmp2[k]);\n                    }\n\n                    if (tmp1.length < nDiags) {\n                        min = tmp1;\n                        nDiags = tmp1.length;\n                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\n                    }\n                }\n            }\n        }\n    }\n\n    return min;\n}\n\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @method decomp\n * @return {Array} An array or Polygon objects.\n */\nfunction polygonDecomp(polygon){\n    var edges = polygonGetCutEdges(polygon);\n    if(edges.length > 0){\n        return polygonSlice(polygon, edges);\n    } else {\n        return [polygon];\n    }\n}\n\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @method slice\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\n * @return {Array}\n */\nfunction polygonSlice(polygon, cutEdges){\n    if(cutEdges.length === 0){\n\t\treturn [polygon];\n    }\n    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){\n\n        var polys = [polygon];\n\n        for(var i=0; i<cutEdges.length; i++){\n            var cutEdge = cutEdges[i];\n            // Cut all polys\n            for(var j=0; j<polys.length; j++){\n                var poly = polys[j];\n                var result = polygonSlice(poly, cutEdge);\n                if(result){\n                    // Found poly! Cut and quit\n                    polys.splice(j,1);\n                    polys.push(result[0],result[1]);\n                    break;\n                }\n            }\n        }\n\n        return polys;\n    } else {\n\n        // Was given one edge\n        var cutEdge = cutEdges;\n        var i = polygon.indexOf(cutEdge[0]);\n        var j = polygon.indexOf(cutEdge[1]);\n\n        if(i !== -1 && j !== -1){\n            return [polygonCopy(polygon, i,j),\n                    polygonCopy(polygon, j,i)];\n        } else {\n            return false;\n        }\n    }\n}\n\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @method isSimple\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n * @return {Boolean}\n * @todo Should it check all segments with all others?\n */\nfunction polygonIsSimple(polygon){\n    var path = polygon, i;\n    // Check\n    for(i=0; i<path.length-1; i++){\n        for(var j=0; j<i-1; j++){\n            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\n                return false;\n            }\n        }\n    }\n\n    // Check the segment between the last and the first point to all others\n    for(i=1; i<path.length-2; i++){\n        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction getIntersectionPoint(p1, p2, q1, q2, delta){\n\tdelta = delta || 0;\n\tvar a1 = p2[1] - p1[1];\n\tvar b1 = p1[0] - p2[0];\n\tvar c1 = (a1 * p1[0]) + (b1 * p1[1]);\n\tvar a2 = q2[1] - q1[1];\n\tvar b2 = q1[0] - q2[0];\n\tvar c2 = (a2 * q1[0]) + (b2 * q1[1]);\n\tvar det = (a1 * b2) - (a2 * b1);\n\n\tif(!scalar_eq(det,0,delta)){\n\t\treturn [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];\n\t} else {\n\t\treturn [0,0];\n    }\n}\n\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @method quickDecomp\n * @param  {Array} result\n * @param  {Array} [reflexVertices]\n * @param  {Array} [steinerPoints]\n * @param  {Number} [delta]\n * @param  {Number} [maxlevel]\n * @param  {Number} [level]\n * @return {Array}\n */\nfunction polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){\n    maxlevel = maxlevel || 100;\n    level = level || 0;\n    delta = delta || 25;\n    result = typeof(result)!==\"undefined\" ? result : [];\n    reflexVertices = reflexVertices || [];\n    steinerPoints = steinerPoints || [];\n\n    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points\n    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars\n    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers\n    var lowerPoly=[], upperPoly=[]; // polygons\n    var poly = polygon,\n        v = polygon;\n\n    if(v.length < 3){\n\t\treturn result;\n    }\n\n    level++;\n    if(level > maxlevel){\n        console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\n        return result;\n    }\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(poly, i)) {\n            reflexVertices.push(poly[i]);\n            upperDist = lowerDist = Number.MAX_VALUE;\n\n\n            for (var j = 0; j < polygon.length; ++j) {\n                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge\n                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly\n                        d = sqdist(poly[i], p);\n                        if (d < lowerDist) { // keep only the closest intersection\n                            lowerDist = d;\n                            lowerInt = p;\n                            lowerIndex = j;\n                        }\n                    }\n                }\n                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n                        d = sqdist(poly[i], p);\n                        if (d < upperDist) {\n                            upperDist = d;\n                            upperInt = p;\n                            upperIndex = j;\n                        }\n                    }\n                }\n            }\n\n            // if there are no vertices to connect to, choose a point in the middle\n            if (lowerIndex === (upperIndex + 1) % polygon.length) {\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\n                steinerPoints.push(p);\n\n                if (i < upperIndex) {\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly, i, upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    if (lowerIndex !== 0){\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);\n                    }\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n                        polygonAppend(lowerPoly, poly,i,poly.length);\n                    }\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly,0,upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,lowerIndex,i+1);\n                }\n            } else {\n                // connect to the closest point within the triangle\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\n\n                if (lowerIndex > upperIndex) {\n                    upperIndex += polygon.length;\n                }\n                closestDist = Number.MAX_VALUE;\n\n                if(upperIndex < lowerIndex){\n                    return result;\n                }\n\n                for (var j = lowerIndex; j <= upperIndex; ++j) {\n                    if (\n                        isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) &&\n                        isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))\n                    ) {\n                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n                        if (d < closestDist && polygonCanSee2(poly, i, j)) {\n                            closestDist = d;\n                            closestIndex = j % polygon.length;\n                        }\n                    }\n                }\n\n                if (i < closestIndex) {\n                    polygonAppend(lowerPoly, poly,i,closestIndex+1);\n                    if (closestIndex !== 0){\n                        polygonAppend(upperPoly, poly,closestIndex,v.length);\n                    }\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        polygonAppend(lowerPoly, poly,i,v.length);\n                    }\n                    polygonAppend(lowerPoly, poly,0,closestIndex+1);\n                    polygonAppend(upperPoly, poly,closestIndex,i+1);\n                }\n            }\n\n            // solve smallest poly first\n            if (lowerPoly.length < upperPoly.length) {\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            } else {\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            }\n\n            return result;\n        }\n    }\n    result.push(polygon);\n\n    return result;\n}\n\n/**\n * Remove collinear points in the polygon.\n * @method removeCollinearPoints\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return {Number}           The number of points removed\n */\nfunction polygonRemoveCollinearPoints(polygon, precision){\n    var num = 0;\n    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){\n        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){\n            // Remove the middle point\n            polygon.splice(i%polygon.length,1);\n            num++;\n        }\n    }\n    return num;\n}\n\n/**\n * Remove duplicate points in the polygon.\n * @method removeDuplicatePoints\n * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.\n */\nfunction polygonRemoveDuplicatePoints(polygon, precision){\n    for(var i=polygon.length-1; i>=1; --i){\n        var pi = polygon[i];\n        for(var j=i-1; j>=0; --j){\n            if(points_eq(pi, polygon[j], precision)){\n                polygon.splice(i,1);\n                continue;\n            }\n        }\n    }\n}\n\n/**\n * Check if two scalars are equal\n * @static\n * @method eq\n * @param  {Number} a\n * @param  {Number} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction scalar_eq(a,b,precision){\n    precision = precision || 0;\n    return Math.abs(a-b) <= precision;\n}\n\n/**\n * Check if two points are equal\n * @static\n * @method points_eq\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction points_eq(a,b,precision){\n    return scalar_eq(a[0],b[0],precision) && scalar_eq(a[1],b[1],precision);\n}\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Polygon = exports.isSimple = void 0;\nconst poly_decomp_1 = require(\"poly-decomp\");\nObject.defineProperty(exports, \"isSimple\", { enumerable: true, get: function () { return poly_decomp_1.isSimple; } });\nconst sat_1 = require(\"sat\");\nconst model_1 = require(\"../model\");\nconst optimized_1 = require(\"../optimized\");\nconst utils_1 = require(\"../utils\");\n/**\n * collider - polygon\n */\nclass Polygon extends sat_1.Polygon {\n    /**\n     * collider - polygon\n     */\n    constructor(position, points, options) {\n        super((0, utils_1.ensureVectorPoint)(position), (0, utils_1.ensurePolygonPoints)(points));\n        /**\n         * was the polygon modified and needs update in the next checkCollision\n         */\n        this.dirty = false;\n        /**\n         * type of body\n         */\n        this.type = model_1.BodyType.Polygon;\n        /**\n         * is body centered\n         */\n        this.centered = false;\n        /**\n         * scale Vector of body\n         */\n        this.scaleVector = { x: 1, y: 1 };\n        if (!(points === null || points === void 0 ? void 0 : points.length)) {\n            throw new Error(\"No points in polygon\");\n        }\n        (0, utils_1.extendBody)(this, options);\n    }\n    /**\n     * flag to set is polygon centered\n     */\n    set isCentered(isCentered) {\n        if (this.centered === isCentered) {\n            return;\n        }\n        const centroid = this.getCentroidWithoutRotation();\n        const x = centroid.x * (isCentered ? 1 : -1);\n        const y = centroid.y * (isCentered ? 1 : -1);\n        this.translate(-x, -y);\n        this.centered = isCentered;\n    }\n    /**\n     * is polygon centered?\n     */\n    get isCentered() {\n        return this.centered;\n    }\n    get x() {\n        return this.pos.x;\n    }\n    /**\n     * updating this.pos.x by this.x = x updates AABB\n     */\n    set x(x) {\n        this.pos.x = x;\n        this.dirty = true;\n    }\n    get y() {\n        return this.pos.y;\n    }\n    /**\n     * updating this.pos.y by this.y = y updates AABB\n     */\n    set y(y) {\n        this.pos.y = y;\n        this.dirty = true;\n    }\n    /**\n     * allow exact getting of scale x - use setScale(x, y) to set\n     */\n    get scaleX() {\n        return this.scaleVector.x;\n    }\n    /**\n     * allow exact getting of scale y - use setScale(x, y) to set\n     */\n    get scaleY() {\n        return this.scaleVector.y;\n    }\n    /**\n     * allow approx getting of scale\n     */\n    get scale() {\n        return this.scaleVector.x;\n    }\n    /**\n     * allow easier setting of scale\n     */\n    set scale(scale) {\n        this.setScale(scale);\n    }\n    /**\n     * update position\n     */\n    setPosition(x, y, update = true) {\n        this.pos.x = x;\n        this.pos.y = y;\n        this.markAsDirty(update);\n        return this;\n    }\n    /**\n     * update scale\n     */\n    setScale(x, y = x, update = true) {\n        this.scaleVector.x = Math.abs(x);\n        this.scaleVector.y = Math.abs(y);\n        super.setPoints((0, optimized_1.map)(this.points, (point, index) => {\n            point.x = this.pointsBackup[index].x * this.scaleVector.x;\n            point.y = this.pointsBackup[index].y * this.scaleVector.y;\n            return point;\n        }));\n        this.markAsDirty(update);\n        return this;\n    }\n    setAngle(angle, update = true) {\n        super.setAngle(angle);\n        this.markAsDirty(update);\n        return this;\n    }\n    setOffset(offset, update = true) {\n        super.setOffset(offset);\n        this.markAsDirty(update);\n        return this;\n    }\n    /**\n     * get body bounding box, without padding\n     */\n    getAABBAsBBox() {\n        const { pos, w, h } = this.getAABBAsBox();\n        return {\n            minX: pos.x,\n            minY: pos.y,\n            maxX: pos.x + w,\n            maxY: pos.y + h,\n        };\n    }\n    /**\n     * Draws exact collider on canvas context\n     */\n    draw(context) {\n        (0, utils_1.drawPolygon)(context, this, this.isTrigger);\n    }\n    /**\n     * Draws Bounding Box on canvas context\n     */\n    drawBVH(context) {\n        (0, utils_1.drawBVH)(context, this);\n    }\n    /**\n     * get body centroid without applied angle\n     */\n    getCentroidWithoutRotation() {\n        // keep angle copy\n        const angle = this.angle;\n        // reset angle for get centroid\n        this.setAngle(0);\n        // get centroid\n        const centroid = this.getCentroid();\n        // revert angle change\n        this.setAngle(angle);\n        return centroid;\n    }\n    /**\n     * sets polygon points to new array of vectors\n     */\n    setPoints(points) {\n        super.setPoints(points);\n        this.updateIsConvex();\n        this.pointsBackup = (0, utils_1.clonePointsArray)(points);\n        return this;\n    }\n    /**\n     * translates polygon points in x, y direction\n     */\n    translate(x, y) {\n        super.translate(x, y);\n        this.pointsBackup = (0, utils_1.clonePointsArray)(this.points);\n        return this;\n    }\n    /**\n     * rotates polygon points by angle, in radians\n     */\n    rotate(angle) {\n        super.rotate(angle);\n        this.pointsBackup = (0, utils_1.clonePointsArray)(this.points);\n        return this;\n    }\n    /**\n     * if true, polygon is not an invalid, self-crossing polygon\n     */\n    isSimple() {\n        return (0, poly_decomp_1.isSimple)(this.calcPoints.map(utils_1.mapVectorToArray));\n    }\n    /**\n     * inner function for after position change update aabb in system and convex inner polygons\n     */\n    updateBody(update = this.dirty) {\n        var _a;\n        if (update) {\n            this.updateConvexPolygonPositions();\n            (_a = this.system) === null || _a === void 0 ? void 0 : _a.insert(this);\n            this.dirty = false;\n        }\n    }\n    /**\n     * update instantly or mark as dirty\n     */\n    markAsDirty(update) {\n        if (update) {\n            this.updateBody(true);\n        }\n        else {\n            this.dirty = true;\n        }\n    }\n    /**\n     * update the position of the decomposed convex polygons (if any), called\n     * after the position of the body has changed\n     */\n    updateConvexPolygonPositions() {\n        if (this.isConvex || !this.convexPolygons) {\n            return;\n        }\n        (0, optimized_1.forEach)(this.convexPolygons, (polygon) => {\n            polygon.pos.x = this.pos.x;\n            polygon.pos.y = this.pos.y;\n        });\n    }\n    /**\n     * returns body split into convex polygons, or empty array for convex bodies\n     */\n    getConvex() {\n        if ((this.type && this.type !== model_1.BodyType.Polygon) ||\n            this.points.length < 4) {\n            return [];\n        }\n        const points = (0, optimized_1.map)(this.calcPoints, utils_1.mapVectorToArray);\n        return (0, poly_decomp_1.quickDecomp)(points);\n    }\n    /**\n     * updates convex polygons cache in body\n     */\n    updateConvexPolygons(convex = this.getConvex()) {\n        if (this.isConvex) {\n            return;\n        }\n        if (!this.convexPolygons) {\n            this.convexPolygons = [];\n        }\n        (0, optimized_1.forEach)(convex, (points, index) => {\n            // lazy create\n            if (!this.convexPolygons[index]) {\n                this.convexPolygons[index] = new sat_1.Polygon();\n            }\n            this.convexPolygons[index].pos.x = this.pos.x;\n            this.convexPolygons[index].pos.y = this.pos.y;\n            this.convexPolygons[index].setPoints((0, utils_1.ensurePolygonPoints)((0, optimized_1.map)(points, utils_1.mapArrayToVector)));\n        });\n        // trim array length\n        this.convexPolygons.length = convex.length;\n    }\n    /**\n     * after points update set is convex\n     */\n    updateIsConvex() {\n        // all other types other than polygon are always convex\n        const convex = this.getConvex();\n        // everything with empty array or one element array\n        this.isConvex = convex.length <= 1;\n        this.updateConvexPolygons(convex);\n    }\n}\nexports.Polygon = Polygon;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Ellipse = void 0;\nconst model_1 = require(\"../model\");\nconst utils_1 = require(\"../utils\");\nconst polygon_1 = require(\"./polygon\");\n/**\n * collider - ellipse\n */\nclass Ellipse extends polygon_1.Polygon {\n    /**\n     * collider - ellipse\n     */\n    constructor(position, radiusX, radiusY = radiusX, step = (radiusX + radiusY) / Math.PI, options) {\n        super(position, (0, utils_1.createEllipse)(radiusX, radiusY, step), options);\n        /**\n         * ellipse type\n         */\n        this.type = model_1.BodyType.Ellipse;\n        /**\n         * ellipses are convex\n         */\n        this.isConvex = true;\n        this._radiusX = radiusX;\n        this._radiusY = radiusY;\n        this._step = step;\n    }\n    /**\n     * flag to set is body centered\n     */\n    set isCentered(_isCentered) { }\n    /**\n     * is body centered?\n     */\n    get isCentered() {\n        return true;\n    }\n    /**\n     * get ellipse step number\n     */\n    get step() {\n        return this._step;\n    }\n    /**\n     * set ellipse step number\n     */\n    set step(step) {\n        this._step = step;\n        this.setPoints((0, utils_1.createEllipse)(this._radiusX, this._radiusY, this._step));\n    }\n    /**\n     * get ellipse radiusX\n     */\n    get radiusX() {\n        return this._radiusX;\n    }\n    /**\n     * set ellipse radiusX, update points\n     */\n    set radiusX(radiusX) {\n        this._radiusX = radiusX;\n        this.setPoints((0, utils_1.createEllipse)(this._radiusX, this._radiusY, this._step));\n    }\n    /**\n     * get ellipse radiusY\n     */\n    get radiusY() {\n        return this._radiusY;\n    }\n    /**\n     * set ellipse radiusY, update points\n     */\n    set radiusY(radiusY) {\n        this._radiusY = radiusY;\n        this.setPoints((0, utils_1.createEllipse)(this._radiusX, this._radiusY, this._step));\n    }\n    /**\n     * do not attempt to use Polygon.center()\n     */\n    center() {\n        return;\n    }\n    /**\n     * do not attempt to use Polygon.updateIsConvex()\n     */\n    updateIsConvex() {\n        return;\n    }\n}\nexports.Ellipse = Ellipse;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Box = void 0;\nconst model_1 = require(\"../model\");\nconst utils_1 = require(\"../utils\");\nconst polygon_1 = require(\"./polygon\");\n/**\n * collider - box\n */\nclass Box extends polygon_1.Polygon {\n    /**\n     * collider - box\n     */\n    constructor(position, width, height, options) {\n        super(position, (0, utils_1.createBox)(width, height), options);\n        /**\n         * type of body\n         */\n        this.type = model_1.BodyType.Box;\n        /**\n         * boxes are convex\n         */\n        this.isConvex = true;\n        this._width = width;\n        this._height = height;\n    }\n    /**\n     * get box width\n     */\n    get width() {\n        return this._width;\n    }\n    /**\n     * set box width, update points\n     */\n    set width(width) {\n        this._width = width;\n        this.setPoints((0, utils_1.createBox)(this._width, this._height));\n    }\n    /**\n     * get box height\n     */\n    get height() {\n        return this._height;\n    }\n    /**\n     * set box height, update points\n     */\n    set height(height) {\n        this._height = height;\n        this.setPoints((0, utils_1.createBox)(this._width, this._height));\n    }\n    /**\n     * do not attempt to use Polygon.updateIsConvex()\n     */\n    updateIsConvex() {\n        return;\n    }\n}\nexports.Box = Box;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Point = void 0;\nconst model_1 = require(\"../model\");\nconst utils_1 = require(\"../utils\");\nconst box_1 = require(\"./box\");\n/**\n * collider - point (very tiny box)\n */\nclass Point extends box_1.Box {\n    /**\n     * collider - point (very tiny box)\n     */\n    constructor(position, options) {\n        super((0, utils_1.ensureVectorPoint)(position), 0.001, 0.001, options);\n        /**\n         * point type\n         */\n        this.type = model_1.BodyType.Point;\n    }\n}\nexports.Point = Point;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Line = void 0;\nconst sat_1 = require(\"sat\");\nconst model_1 = require(\"../model\");\nconst polygon_1 = require(\"./polygon\");\n/**\n * collider - line\n */\nclass Line extends polygon_1.Polygon {\n    /**\n     * collider - line from start to end\n     */\n    constructor(start, end, options) {\n        super(start, [\n            { x: 0, y: 0 },\n            { x: end.x - start.x, y: end.y - start.y },\n        ], options);\n        /**\n         * line type\n         */\n        this.type = model_1.BodyType.Line;\n        /**\n         * line is convex\n         */\n        this.isConvex = true;\n        if (this.calcPoints.length === 1 || !end) {\n            console.error({ start, end });\n            throw new Error(\"No end point for line provided\");\n        }\n    }\n    get start() {\n        return {\n            x: this.x + this.calcPoints[0].x,\n            y: this.y + this.calcPoints[0].y,\n        };\n    }\n    set start({ x, y }) {\n        this.x = x;\n        this.y = y;\n    }\n    get end() {\n        return {\n            x: this.x + this.calcPoints[1].x,\n            y: this.y + this.calcPoints[1].y,\n        };\n    }\n    set end({ x, y }) {\n        this.points[1].x = x - this.start.x;\n        this.points[1].y = y - this.start.y;\n        this.setPoints(this.points);\n    }\n    getCentroid() {\n        return new sat_1.Vector((this.end.x - this.start.x) / 2, (this.end.y - this.start.y) / 2);\n    }\n    /**\n     * do not attempt to use Polygon.updateIsConvex()\n     */\n    updateIsConvex() {\n        return;\n    }\n}\nexports.Line = Line;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseSystem = void 0;\nconst box_1 = require(\"./bodies/box\");\nconst circle_1 = require(\"./bodies/circle\");\nconst ellipse_1 = require(\"./bodies/ellipse\");\nconst line_1 = require(\"./bodies/line\");\nconst point_1 = require(\"./bodies/point\");\nconst polygon_1 = require(\"./bodies/polygon\");\nconst model_1 = require(\"./model\");\nconst optimized_1 = require(\"./optimized\");\nconst utils_1 = require(\"./utils\");\n/**\n * very base collision system\n */\nclass BaseSystem extends model_1.RBush {\n    /**\n     * draw exact bodies colliders outline\n     */\n    draw(context) {\n        (0, optimized_1.forEach)(this.all(), (body) => {\n            body.draw(context);\n        });\n    }\n    /**\n     * draw bounding boxes hierarchy outline\n     */\n    drawBVH(context) {\n        const drawChildren = (body) => {\n            (0, utils_1.drawBVH)(context, body);\n            if (body.children) {\n                (0, optimized_1.forEach)(body.children, drawChildren);\n            }\n        };\n        (0, optimized_1.forEach)(this.data.children, drawChildren);\n    }\n    /**\n     * create point at position with options and add to system\n     */\n    createPoint(position, options) {\n        const point = new point_1.Point(position, options);\n        this.insert(point);\n        return point;\n    }\n    /**\n     * create line at position with options and add to system\n     */\n    createLine(start, end, options) {\n        const line = new line_1.Line(start, end, options);\n        this.insert(line);\n        return line;\n    }\n    /**\n     * create circle at position with options and add to system\n     */\n    createCircle(position, radius, options) {\n        const circle = new circle_1.Circle(position, radius, options);\n        this.insert(circle);\n        return circle;\n    }\n    /**\n     * create box at position with options and add to system\n     */\n    createBox(position, width, height, options) {\n        const box = new box_1.Box(position, width, height, options);\n        this.insert(box);\n        return box;\n    }\n    /**\n     * create ellipse at position with options and add to system\n     */\n    createEllipse(position, radiusX, radiusY = radiusX, step, options) {\n        const ellipse = new ellipse_1.Ellipse(position, radiusX, radiusY, step, options);\n        this.insert(ellipse);\n        return ellipse;\n    }\n    /**\n     * create polygon at position with options and add to system\n     */\n    createPolygon(position, points, options) {\n        const polygon = new polygon_1.Polygon(position, points, options);\n        this.insert(polygon);\n        return polygon;\n    }\n}\nexports.BaseSystem = BaseSystem;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.System = void 0;\nconst base_system_1 = require(\"./base-system\");\nconst line_1 = require(\"./bodies/line\");\nconst model_1 = require(\"./model\");\nconst utils_1 = require(\"./utils\");\nconst intersect_1 = require(\"./intersect\");\nconst optimized_1 = require(\"./optimized\");\n/**\n * collision system\n */\nclass System extends base_system_1.BaseSystem {\n    constructor() {\n        super(...arguments);\n        /**\n         * the last collision result\n         */\n        this.response = new model_1.Response();\n    }\n    /**\n     * remove body aabb from collision tree\n     */\n    remove(body, equals) {\n        body.system = undefined;\n        return super.remove(body, equals);\n    }\n    /**\n     * re-insert body into collision tree and update its aabb\n     * every body can be part of only one system\n     */\n    insert(body) {\n        body.bbox = body.getAABBAsBBox();\n        if (body.system) {\n            // allow end if body inserted and not moved\n            if (!(0, utils_1.bodyMoved)(body)) {\n                return this;\n            }\n            // old bounding box *needs* to be removed\n            body.system.remove(body);\n        }\n        // only then we update min, max\n        body.minX = body.bbox.minX - body.padding;\n        body.minY = body.bbox.minY - body.padding;\n        body.maxX = body.bbox.maxX + body.padding;\n        body.maxY = body.bbox.maxY + body.padding;\n        // set system for later body.system.updateBody(body)\n        body.system = this;\n        // reinsert bounding box to collision tree\n        return super.insert(body);\n    }\n    /**\n     * updates body in collision tree\n     */\n    updateBody(body) {\n        body.updateBody();\n    }\n    /**\n     * update all bodies aabb\n     */\n    update() {\n        (0, optimized_1.forEach)(this.all(), (body) => {\n            this.updateBody(body);\n        });\n    }\n    /**\n     * separate (move away) colliders\n     */\n    separate() {\n        this.checkAll(({ a, overlapV }) => {\n            // static bodies and triggers do not move back / separate\n            if (a.isTrigger) {\n                return false;\n            }\n            a.setPosition(a.x - overlapV.x, a.y - overlapV.y);\n        });\n    }\n    /**\n     * check one collider collisions with callback\n     */\n    checkOne(body, callback = () => true, response = this.response) {\n        // no need to check static body collision\n        if (body.isStatic) {\n            return false;\n        }\n        const bodies = this.search(body);\n        const checkCollision = (candidate) => {\n            if (candidate !== body &&\n                this.checkCollision(body, candidate, response)) {\n                return callback(response);\n            }\n        };\n        return (0, optimized_1.some)(bodies, checkCollision);\n    }\n    /**\n     * check all colliders collisions with callback\n     */\n    checkAll(callback, response = this.response) {\n        const bodies = this.all();\n        const checkOne = (body) => {\n            return this.checkOne(body, callback, response);\n        };\n        return (0, optimized_1.some)(bodies, checkOne);\n    }\n    /**\n     * get object potential colliders\n     * @deprecated because it's slower to use than checkOne() or checkAll()\n     */\n    getPotentials(body) {\n        // filter here is required as collides with self\n        return (0, optimized_1.filter)(this.search(body), (candidate) => candidate !== body);\n    }\n    /**\n     * check do 2 objects collide\n     */\n    checkCollision(bodyA, bodyB, response = this.response) {\n        // if any of bodies has padding, we can short return false by assesing the bbox without padding\n        if ((bodyA.padding || bodyB.padding) &&\n            (0, utils_1.notIntersectAABB)(bodyA.bbox || bodyA, bodyB.bbox || bodyB)) {\n            return false;\n        }\n        const sat = (0, utils_1.getSATTest)(bodyA, bodyB);\n        // 99% of cases\n        if (bodyA.isConvex && bodyB.isConvex) {\n            response.clear();\n            return sat(bodyA, bodyB, response);\n        }\n        // more complex (non convex) cases\n        const convexBodiesA = (0, intersect_1.ensureConvex)(bodyA);\n        const convexBodiesB = (0, intersect_1.ensureConvex)(bodyB);\n        const overlapV = new model_1.SATVector();\n        let collided = false;\n        (0, optimized_1.forEach)(convexBodiesA, (convexBodyA) => {\n            (0, optimized_1.forEach)(convexBodiesB, (convexBodyB) => {\n                response.clear();\n                if (sat(convexBodyA, convexBodyB, response)) {\n                    collided = true;\n                    overlapV.add(response.overlapV);\n                }\n            });\n        });\n        if (collided) {\n            response.a = bodyA;\n            response.b = bodyB;\n            response.overlapV = overlapV;\n            response.overlapN = overlapV.clone().normalize();\n            response.overlap = overlapV.len();\n            response.aInB = (0, utils_1.checkAInB)(bodyA, bodyB);\n            response.bInA = (0, utils_1.checkAInB)(bodyB, bodyA);\n        }\n        return collided;\n    }\n    /**\n     * raycast to get collider of ray from start to end\n     */\n    raycast(start, end, allow = () => true) {\n        let minDistance = Infinity;\n        let result = null;\n        if (!this.ray) {\n            this.ray = new line_1.Line(start, end, { isTrigger: true });\n        }\n        else {\n            this.ray.start = start;\n            this.ray.end = end;\n        }\n        this.insert(this.ray);\n        this.checkOne(this.ray, ({ b: body }) => {\n            if (!allow(body)) {\n                return false;\n            }\n            const points = body.type === model_1.BodyType.Circle\n                ? (0, intersect_1.intersectLineCircle)(this.ray, body)\n                : (0, intersect_1.intersectLinePolygon)(this.ray, body);\n            (0, optimized_1.forEach)(points, (point) => {\n                const pointDistance = (0, utils_1.distance)(start, point);\n                if (pointDistance < minDistance) {\n                    minDistance = pointDistance;\n                    result = { point, body };\n                }\n            });\n        });\n        this.remove(this.ray);\n        return result;\n    }\n    /**\n     * used to find body deep inside data with finder function returning boolean found or not\n     */\n    traverse(find, { children } = this.data) {\n        return children === null || children === void 0 ? void 0 : children.find((body, index) => {\n            if (!body) {\n                return false;\n            }\n            if (body.type && find(body, children, index)) {\n                return true;\n            }\n            // if callback returns true, ends forEach\n            if (body.children) {\n                this.traverse(find, body);\n            }\n        });\n    }\n}\nexports.System = System;\n", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./model\"), exports);\n__exportStar(require(\"./bodies/circle\"), exports);\n__exportStar(require(\"./bodies/ellipse\"), exports);\n__exportStar(require(\"./bodies/polygon\"), exports);\n__exportStar(require(\"./bodies/box\"), exports);\n__exportStar(require(\"./bodies/point\"), exports);\n__exportStar(require(\"./bodies/line\"), exports);\n__exportStar(require(\"./system\"), exports);\n__exportStar(require(\"./utils\"), exports);\n__exportStar(require(\"./intersect\"), exports);\n"],
  "mappings": ";;;;;AAAA;AAAA;AAAA,KAAC,SAAS,GAAE,GAAE;AAAC,kBAAU,OAAO,WAAS,eAAa,OAAO,SAAO,OAAO,UAAQ,EAAE,IAAE,cAAY,OAAO,UAAQ,OAAO,MAAI,OAAO,CAAC,KAAG,IAAE,KAAG,MAAM,QAAM,EAAE;AAAA,IAAC,EAAE,SAAK,WAAU;AAAC;AAAa,eAAS,EAAEA,IAAEC,IAAEC,IAAEC,IAAEC,IAAE;AAAC,SAAC,SAASJ,GAAEK,IAAEJ,IAAEC,IAAEC,IAAEC,IAAE;AAAC,iBAAKD,KAAED,MAAG;AAAC,gBAAGC,KAAED,KAAE,KAAI;AAAC,kBAAII,KAAEH,KAAED,KAAE,GAAEK,KAAEN,KAAEC,KAAE,GAAEM,KAAE,KAAK,IAAIF,EAAC,GAAEG,KAAE,MAAG,KAAK,IAAI,IAAED,KAAE,CAAC,GAAEE,KAAE,MAAG,KAAK,KAAKF,KAAEC,MAAGH,KAAEG,MAAGH,EAAC,KAAGC,KAAED,KAAE,IAAE,IAAE,KAAG,IAAGK,KAAE,KAAK,IAAIT,IAAE,KAAK,MAAMD,KAAEM,KAAEE,KAAEH,KAAEI,EAAC,CAAC,GAAEE,KAAE,KAAK,IAAIT,IAAE,KAAK,MAAMF,MAAGK,KAAEC,MAAGE,KAAEH,KAAEI,EAAC,CAAC;AAAE,cAAAV,GAAEK,IAAEJ,IAAEU,IAAEC,IAAER,EAAC;AAAA,YAAC;AAAC,gBAAIS,KAAER,GAAEJ,EAAC,GAAEa,KAAEZ,IAAE,IAAEC;AAAE,iBAAI,EAAEE,IAAEH,IAAED,EAAC,GAAEG,GAAEC,GAAEF,EAAC,GAAEU,EAAC,IAAE,KAAG,EAAER,IAAEH,IAAEC,EAAC,GAAEW,KAAE,KAAG;AAAC,mBAAI,EAAET,IAAES,IAAE,CAAC,GAAEA,MAAI,KAAIV,GAAEC,GAAES,EAAC,GAAED,EAAC,IAAE;AAAG,gBAAAC;AAAI,qBAAKV,GAAEC,GAAE,CAAC,GAAEQ,EAAC,IAAE;AAAG;AAAA,YAAG;AAAC,kBAAIT,GAAEC,GAAEH,EAAC,GAAEW,EAAC,IAAE,EAAER,IAAEH,IAAE,CAAC,IAAE,EAAEG,IAAE,EAAE,GAAEF,EAAC,GAAE,KAAGF,OAAIC,KAAE,IAAE,IAAGD,MAAG,MAAIE,KAAE,IAAE;AAAA,UAAE;AAAA,QAAC,EAAEH,IAAEC,IAAEC,MAAG,GAAEC,MAAGH,GAAE,SAAO,GAAEI,MAAG,CAAC;AAAA,MAAC;AAAC,eAAS,EAAEJ,IAAEe,IAAEV,IAAE;AAAC,YAAIJ,KAAED,GAAEe,EAAC;AAAE,QAAAf,GAAEe,EAAC,IAAEf,GAAEK,EAAC,GAAEL,GAAEK,EAAC,IAAEJ;AAAA,MAAC;AAAC,eAAS,EAAED,IAAEe,IAAE;AAAC,eAAOf,KAAEe,KAAE,KAAGf,KAAEe,KAAE,IAAE;AAAA,MAAC;AAAC,UAAI,IAAE,SAASf,IAAE;AAAC,mBAASA,OAAIA,KAAE,IAAG,KAAK,cAAY,KAAK,IAAI,GAAEA,EAAC,GAAE,KAAK,cAAY,KAAK,IAAI,GAAE,KAAK,KAAK,MAAG,KAAK,WAAW,CAAC,GAAE,KAAK,MAAM;AAAA,MAAC;AAAE,eAAS,EAAEA,IAAEe,IAAEV,IAAE;AAAC,YAAG,CAACA;AAAE,iBAAOU,GAAE,QAAQf,EAAC;AAAE,iBAAQC,KAAE,GAAEA,KAAEc,GAAE,QAAOd;AAAI,cAAGI,GAAEL,IAAEe,GAAEd,EAAC,CAAC;AAAE,mBAAOA;AAAE,eAAM;AAAA,MAAE;AAAC,eAAS,EAAED,IAAEe,IAAE;AAAC,UAAEf,IAAE,GAAEA,GAAE,SAAS,QAAOe,IAAEf,EAAC;AAAA,MAAC;AAAC,eAAS,EAAEA,IAAEe,IAAEV,IAAEJ,IAAEC,IAAE;AAAC,QAAAA,OAAIA,KAAE,EAAE,IAAI,IAAGA,GAAE,OAAK,IAAE,GAAEA,GAAE,OAAK,IAAE,GAAEA,GAAE,OAAK,KAAG,GAAEA,GAAE,OAAK,KAAG;AAAE,iBAAQC,KAAEY,IAAEZ,KAAEE,IAAEF,MAAI;AAAC,cAAIC,KAAEJ,GAAE,SAASG,EAAC;AAAE,YAAED,IAAEF,GAAE,OAAKC,GAAEG,EAAC,IAAEA,EAAC;AAAA,QAAC;AAAC,eAAOF;AAAA,MAAC;AAAC,eAAS,EAAEF,IAAEe,IAAE;AAAC,eAAOf,GAAE,OAAK,KAAK,IAAIA,GAAE,MAAKe,GAAE,IAAI,GAAEf,GAAE,OAAK,KAAK,IAAIA,GAAE,MAAKe,GAAE,IAAI,GAAEf,GAAE,OAAK,KAAK,IAAIA,GAAE,MAAKe,GAAE,IAAI,GAAEf,GAAE,OAAK,KAAK,IAAIA,GAAE,MAAKe,GAAE,IAAI,GAAEf;AAAA,MAAC;AAAC,eAAS,EAAEA,IAAEe,IAAE;AAAC,eAAOf,GAAE,OAAKe,GAAE;AAAA,MAAI;AAAC,eAAS,EAAEf,IAAEe,IAAE;AAAC,eAAOf,GAAE,OAAKe,GAAE;AAAA,MAAI;AAAC,eAAS,EAAEf,IAAE;AAAC,gBAAOA,GAAE,OAAKA,GAAE,SAAOA,GAAE,OAAKA,GAAE;AAAA,MAAK;AAAC,eAAS,EAAEA,IAAE;AAAC,eAAOA,GAAE,OAAKA,GAAE,QAAMA,GAAE,OAAKA,GAAE;AAAA,MAAK;AAAC,eAAS,EAAEA,IAAEe,IAAE;AAAC,eAAOf,GAAE,QAAMe,GAAE,QAAMf,GAAE,QAAMe,GAAE,QAAMA,GAAE,QAAMf,GAAE,QAAMe,GAAE,QAAMf,GAAE;AAAA,MAAI;AAAC,eAAS,EAAEA,IAAEe,IAAE;AAAC,eAAOA,GAAE,QAAMf,GAAE,QAAMe,GAAE,QAAMf,GAAE,QAAMe,GAAE,QAAMf,GAAE,QAAMe,GAAE,QAAMf,GAAE;AAAA,MAAI;AAAC,eAAS,EAAEA,IAAE;AAAC,eAAM,EAAC,UAASA,IAAE,QAAO,GAAE,MAAK,MAAG,MAAK,IAAE,GAAE,MAAK,IAAE,GAAE,MAAK,KAAG,GAAE,MAAK,KAAG,EAAC;AAAA,MAAC;AAAC,eAAS,EAAEe,IAAEV,IAAEJ,IAAEC,IAAEC,IAAE;AAAC,iBAAQC,KAAE,CAACC,IAAEJ,EAAC,GAAEG,GAAE;AAAQ,cAAG,GAAGH,KAAEG,GAAE,IAAI,MAAIC,KAAED,GAAE,IAAI,MAAIF,KAAG;AAAC,gBAAII,KAAED,KAAE,KAAK,MAAMJ,KAAEI,MAAGH,KAAE,CAAC,IAAEA;AAAE,cAAEa,IAAET,IAAED,IAAEJ,IAAEE,EAAC,GAAEC,GAAE,KAAKC,IAAEC,IAAEA,IAAEL,EAAC;AAAA,UAAC;AAAA,MAAC;AAAC,aAAO,EAAE,UAAU,MAAI,WAAU;AAAC,eAAO,KAAK,KAAK,KAAK,MAAK,CAAC,CAAC;AAAA,MAAC,GAAE,EAAE,UAAU,SAAO,SAASD,IAAE;AAAC,YAAIe,KAAE,KAAK,MAAKV,KAAE,CAAC;AAAE,YAAG,CAAC,EAAEL,IAAEe,EAAC;AAAE,iBAAOV;AAAE,iBAAQJ,KAAE,KAAK,QAAOC,KAAE,CAAC,GAAEa,MAAG;AAAC,mBAAQZ,KAAE,GAAEA,KAAEY,GAAE,SAAS,QAAOZ,MAAI;AAAC,gBAAIC,KAAEW,GAAE,SAASZ,EAAC,GAAEG,KAAES,GAAE,OAAKd,GAAEG,EAAC,IAAEA;AAAE,cAAEJ,IAAEM,EAAC,MAAIS,GAAE,OAAKV,GAAE,KAAKD,EAAC,IAAE,EAAEJ,IAAEM,EAAC,IAAE,KAAK,KAAKF,IAAEC,EAAC,IAAEH,GAAE,KAAKE,EAAC;AAAA,UAAE;AAAC,UAAAW,KAAEb,GAAE,IAAI;AAAA,QAAC;AAAC,eAAOG;AAAA,MAAC,GAAE,EAAE,UAAU,WAAS,SAASL,IAAE;AAAC,YAAIe,KAAE,KAAK;AAAK,YAAG,CAAC,EAAEf,IAAEe,EAAC;AAAE,iBAAM;AAAG,iBAAQV,KAAE,CAAC,GAAEU,MAAG;AAAC,mBAAQd,KAAE,GAAEA,KAAEc,GAAE,SAAS,QAAOd,MAAI;AAAC,gBAAIC,KAAEa,GAAE,SAASd,EAAC,GAAEE,KAAEY,GAAE,OAAK,KAAK,OAAOb,EAAC,IAAEA;AAAE,gBAAG,EAAEF,IAAEG,EAAC,GAAE;AAAC,kBAAGY,GAAE,QAAM,EAAEf,IAAEG,EAAC;AAAE,uBAAM;AAAG,cAAAE,GAAE,KAAKH,EAAC;AAAA,YAAC;AAAA,UAAC;AAAC,UAAAa,KAAEV,GAAE,IAAI;AAAA,QAAC;AAAC,eAAM;AAAA,MAAE,GAAE,EAAE,UAAU,OAAK,SAASL,IAAE;AAAC,YAAG,CAACA,MAAG,CAACA,GAAE;AAAO,iBAAO;AAAK,YAAGA,GAAE,SAAO,KAAK,aAAY;AAAC,mBAAQe,KAAE,GAAEA,KAAEf,GAAE,QAAOe;AAAI,iBAAK,OAAOf,GAAEe,EAAC,CAAC;AAAE,iBAAO;AAAA,QAAI;AAAC,YAAIV,KAAE,KAAK,OAAOL,GAAE,MAAM,GAAE,GAAEA,GAAE,SAAO,GAAE,CAAC;AAAE,YAAG,KAAK,KAAK,SAAS;AAAO,cAAG,KAAK,KAAK,WAASK,GAAE;AAAO,iBAAK,WAAW,KAAK,MAAKA,EAAC;AAAA,eAAM;AAAC,gBAAG,KAAK,KAAK,SAAOA,GAAE,QAAO;AAAC,kBAAIJ,KAAE,KAAK;AAAK,mBAAK,OAAKI,IAAEA,KAAEJ;AAAA,YAAC;AAAC,iBAAK,QAAQI,IAAE,KAAK,KAAK,SAAOA,GAAE,SAAO,GAAE,IAAE;AAAA,UAAC;AAAA;AAAM,eAAK,OAAKA;AAAE,eAAO;AAAA,MAAI,GAAE,EAAE,UAAU,SAAO,SAASL,IAAE;AAAC,eAAOA,MAAG,KAAK,QAAQA,IAAE,KAAK,KAAK,SAAO,CAAC,GAAE;AAAA,MAAI,GAAE,EAAE,UAAU,QAAM,WAAU;AAAC,eAAO,KAAK,OAAK,EAAE,CAAC,CAAC,GAAE;AAAA,MAAI,GAAE,EAAE,UAAU,SAAO,SAASA,IAAEe,IAAE;AAAC,YAAG,CAACf;AAAE,iBAAO;AAAK,iBAAQK,IAAEJ,IAAEE,IAAEC,KAAE,KAAK,MAAKE,KAAE,KAAK,OAAON,EAAC,GAAEO,KAAE,CAAC,GAAEC,KAAE,CAAC,GAAEJ,MAAGG,GAAE,UAAQ;AAAC,cAAGH,OAAIA,KAAEG,GAAE,IAAI,GAAEN,KAAEM,GAAEA,GAAE,SAAO,CAAC,GAAEF,KAAEG,GAAE,IAAI,GAAEL,KAAE,OAAIC,GAAE,MAAK;AAAC,gBAAIK,KAAE,EAAET,IAAEI,GAAE,UAASW,EAAC;AAAE,gBAAG,OAAKN;AAAE,qBAAOL,GAAE,SAAS,OAAOK,IAAE,CAAC,GAAEF,GAAE,KAAKH,EAAC,GAAE,KAAK,UAAUG,EAAC,GAAE;AAAA,UAAI;AAAC,UAAAJ,MAAGC,GAAE,QAAM,CAAC,EAAEA,IAAEE,EAAC,IAAEL,MAAGI,MAAID,KAAEH,GAAE,SAASI,EAAC,GAAEF,KAAE,SAAIC,KAAE,QAAMG,GAAE,KAAKH,EAAC,GAAEI,GAAE,KAAKH,EAAC,GAAEA,KAAE,GAAEJ,KAAEG,IAAEA,KAAEA,GAAE,SAAS,CAAC;AAAA,QAAE;AAAC,eAAO;AAAA,MAAI,GAAE,EAAE,UAAU,SAAO,SAASJ,IAAE;AAAC,eAAOA;AAAA,MAAC,GAAE,EAAE,UAAU,cAAY,SAASA,IAAEe,IAAE;AAAC,eAAOf,GAAE,OAAKe,GAAE;AAAA,MAAI,GAAE,EAAE,UAAU,cAAY,SAASf,IAAEe,IAAE;AAAC,eAAOf,GAAE,OAAKe,GAAE;AAAA,MAAI,GAAE,EAAE,UAAU,SAAO,WAAU;AAAC,eAAO,KAAK;AAAA,MAAI,GAAE,EAAE,UAAU,WAAS,SAASf,IAAE;AAAC,eAAO,KAAK,OAAKA,IAAE;AAAA,MAAI,GAAE,EAAE,UAAU,OAAK,SAASA,IAAEe,IAAE;AAAC,iBAAQV,KAAE,CAAC,GAAEL;AAAG,UAAAA,GAAE,OAAKe,GAAE,KAAK,MAAMA,IAAEf,GAAE,QAAQ,IAAEK,GAAE,KAAK,MAAMA,IAAEL,GAAE,QAAQ,GAAEA,KAAEK,GAAE,IAAI;AAAE,eAAOU;AAAA,MAAC,GAAE,EAAE,UAAU,SAAO,SAASf,IAAEe,IAAEV,IAAEJ,IAAE;AAAC,YAAIC,IAAEE,KAAEC,KAAEU,KAAE,GAAET,KAAE,KAAK;AAAY,YAAGF,MAAGE;AAAE,iBAAO,EAAEJ,KAAE,EAAEF,GAAE,MAAMe,IAAEV,KAAE,CAAC,CAAC,GAAE,KAAK,MAAM,GAAEH;AAAE,QAAAD,OAAIA,KAAE,KAAK,KAAK,KAAK,IAAIG,EAAC,IAAE,KAAK,IAAIE,EAAC,CAAC,GAAEA,KAAE,KAAK,KAAKF,KAAE,KAAK,IAAIE,IAAEL,KAAE,CAAC,CAAC,KAAIC,KAAE,EAAE,CAAC,CAAC,GAAG,OAAK,OAAGA,GAAE,SAAOD;AAAE,YAAIM,KAAE,KAAK,KAAKH,KAAEE,EAAC,GAAEE,KAAED,KAAE,KAAK,KAAK,KAAK,KAAKD,EAAC,CAAC;AAAE,UAAEN,IAAEe,IAAEV,IAAEG,IAAE,KAAK,WAAW;AAAE,iBAAQC,KAAEM,IAAEN,MAAGJ,IAAEI,MAAGD,IAAE;AAAC,cAAIE,KAAE,KAAK,IAAID,KAAED,KAAE,GAAEH,EAAC;AAAE,YAAEL,IAAES,IAAEC,IAAEH,IAAE,KAAK,WAAW;AAAE,mBAAQI,KAAEF,IAAEE,MAAGD,IAAEC,MAAGJ,IAAE;AAAC,gBAAIK,KAAE,KAAK,IAAID,KAAEJ,KAAE,GAAEG,EAAC;AAAE,YAAAR,GAAE,SAAS,KAAK,KAAK,OAAOF,IAAEW,IAAEC,IAAEX,KAAE,CAAC,CAAC;AAAA,UAAC;AAAA,QAAC;AAAC,eAAO,EAAEC,IAAE,KAAK,MAAM,GAAEA;AAAA,MAAC,GAAE,EAAE,UAAU,iBAAe,SAASF,IAAEe,IAAEV,IAAEJ,IAAE;AAAC,eAAKA,GAAE,KAAKc,EAAC,GAAE,CAACA,GAAE,QAAMd,GAAE,SAAO,MAAII,MAAG;AAAC,mBAAQH,KAAE,IAAE,GAAEC,KAAE,IAAE,GAAEC,KAAE,QAAOE,KAAE,GAAEA,KAAES,GAAE,SAAS,QAAOT,MAAI;AAAC,gBAAIC,KAAEQ,GAAE,SAAST,EAAC,GAAEE,KAAE,EAAED,EAAC,GAAEG,MAAGC,KAAEX,IAAEY,KAAEL,KAAG,KAAK,IAAIK,GAAE,MAAKD,GAAE,IAAI,IAAE,KAAK,IAAIC,GAAE,MAAKD,GAAE,IAAI,MAAI,KAAK,IAAIC,GAAE,MAAKD,GAAE,IAAI,IAAE,KAAK,IAAIC,GAAE,MAAKD,GAAE,IAAI,KAAGH;AAAG,YAAAE,KAAEP,MAAGA,KAAEO,IAAER,KAAEM,KAAEN,KAAEM,KAAEN,IAAEE,KAAEG,MAAGG,OAAIP,MAAGK,KAAEN,OAAIA,KAAEM,IAAEJ,KAAEG;AAAA,UAAE;AAAC,UAAAQ,KAAEX,MAAGW,GAAE,SAAS,CAAC;AAAA,QAAC;AAAC,YAAIJ,IAAEC;AAAE,eAAOG;AAAA,MAAC,GAAE,EAAE,UAAU,UAAQ,SAASf,IAAEe,IAAEV,IAAE;AAAC,YAAIJ,KAAEI,KAAEL,KAAE,KAAK,OAAOA,EAAC,GAAEE,KAAE,CAAC,GAAEC,KAAE,KAAK,eAAeF,IAAE,KAAK,MAAKc,IAAEb,EAAC;AAAE,aAAIC,GAAE,SAAS,KAAKH,EAAC,GAAE,EAAEG,IAAEF,EAAC,GAAEc,MAAG,KAAGb,GAAEa,EAAC,EAAE,SAAS,SAAO,KAAK;AAAa,eAAK,OAAOb,IAAEa,EAAC,GAAEA;AAAI,aAAK,oBAAoBd,IAAEC,IAAEa,EAAC;AAAA,MAAC,GAAE,EAAE,UAAU,SAAO,SAASf,IAAEe,IAAE;AAAC,YAAIV,KAAEL,GAAEe,EAAC,GAAEd,KAAEI,GAAE,SAAS,QAAOH,KAAE,KAAK;AAAY,aAAK,iBAAiBG,IAAEH,IAAED,EAAC;AAAE,YAAIG,KAAE,KAAK,kBAAkBC,IAAEH,IAAED,EAAC,GAAEK,KAAE,EAAED,GAAE,SAAS,OAAOD,IAAEC,GAAE,SAAS,SAAOD,EAAC,CAAC;AAAE,QAAAE,GAAE,SAAOD,GAAE,QAAOC,GAAE,OAAKD,GAAE,MAAK,EAAEA,IAAE,KAAK,MAAM,GAAE,EAAEC,IAAE,KAAK,MAAM,GAAES,KAAEf,GAAEe,KAAE,CAAC,EAAE,SAAS,KAAKT,EAAC,IAAE,KAAK,WAAWD,IAAEC,EAAC;AAAA,MAAC,GAAE,EAAE,UAAU,aAAW,SAASN,IAAEe,IAAE;AAAC,aAAK,OAAK,EAAE,CAACf,IAAEe,EAAC,CAAC,GAAE,KAAK,KAAK,SAAOf,GAAE,SAAO,GAAE,KAAK,KAAK,OAAK,OAAG,EAAE,KAAK,MAAK,KAAK,MAAM;AAAA,MAAC,GAAE,EAAE,UAAU,oBAAkB,SAASA,IAAEe,IAAEV,IAAE;AAAC,iBAAQJ,IAAEC,IAAEC,IAAEG,IAAEC,IAAEC,IAAEE,IAAEC,KAAE,IAAE,GAAEC,KAAE,IAAE,GAAEC,KAAEE,IAAEF,MAAGR,KAAEU,IAAEF,MAAI;AAAC,cAAIC,KAAE,EAAEd,IAAE,GAAEa,IAAE,KAAK,MAAM,GAAE,IAAE,EAAEb,IAAEa,IAAER,IAAE,KAAK,MAAM,GAAE,KAAGH,KAAEY,IAAEX,KAAE,GAAEG,KAAE,QAAOC,KAAE,QAAOC,KAAE,QAAOE,KAAE,QAAOJ,KAAE,KAAK,IAAIJ,GAAE,MAAKC,GAAE,IAAI,GAAEI,KAAE,KAAK,IAAIL,GAAE,MAAKC,GAAE,IAAI,GAAEK,KAAE,KAAK,IAAIN,GAAE,MAAKC,GAAE,IAAI,GAAEO,KAAE,KAAK,IAAIR,GAAE,MAAKC,GAAE,IAAI,GAAE,KAAK,IAAI,GAAEK,KAAEF,EAAC,IAAE,KAAK,IAAI,GAAEI,KAAEH,EAAC,IAAG,IAAE,EAAEO,EAAC,IAAE,EAAE,CAAC;AAAE,cAAEH,MAAGA,KAAE,GAAEV,KAAEY,IAAED,KAAE,IAAEA,KAAE,IAAEA,MAAG,MAAID,MAAG,IAAEC,OAAIA,KAAE,GAAEX,KAAEY;AAAA,QAAE;AAAC,eAAOZ,MAAGI,KAAEU;AAAA,MAAC,GAAE,EAAE,UAAU,mBAAiB,SAASf,IAAEe,IAAEV,IAAE;AAAC,YAAIJ,KAAED,GAAE,OAAK,KAAK,cAAY,GAAEE,KAAEF,GAAE,OAAK,KAAK,cAAY;AAAE,aAAK,eAAeA,IAAEe,IAAEV,IAAEJ,EAAC,IAAE,KAAK,eAAeD,IAAEe,IAAEV,IAAEH,EAAC,KAAGF,GAAE,SAAS,KAAKC,EAAC;AAAA,MAAC,GAAE,EAAE,UAAU,iBAAe,SAASD,IAAEe,IAAEV,IAAEJ,IAAE;AAAC,QAAAD,GAAE,SAAS,KAAKC,EAAC;AAAE,iBAAQC,KAAE,KAAK,QAAOC,KAAE,EAAEH,IAAE,GAAEe,IAAEb,EAAC,GAAEK,KAAE,EAAEP,IAAEK,KAAEU,IAAEV,IAAEH,EAAC,GAAEM,KAAE,EAAEL,EAAC,IAAE,EAAEI,EAAC,GAAEE,KAAEM,IAAEN,KAAEJ,KAAEU,IAAEN,MAAI;AAAC,cAAIE,KAAEX,GAAE,SAASS,EAAC;AAAE,YAAEN,IAAEH,GAAE,OAAKE,GAAES,EAAC,IAAEA,EAAC,GAAEH,MAAG,EAAEL,EAAC;AAAA,QAAC;AAAC,iBAAQS,KAAEP,KAAEU,KAAE,GAAEH,MAAGG,IAAEH,MAAI;AAAC,cAAIC,KAAEb,GAAE,SAASY,EAAC;AAAE,YAAEL,IAAEP,GAAE,OAAKE,GAAEW,EAAC,IAAEA,EAAC,GAAEL,MAAG,EAAED,EAAC;AAAA,QAAC;AAAC,eAAOC;AAAA,MAAC,GAAE,EAAE,UAAU,sBAAoB,SAASR,IAAEe,IAAEV,IAAE;AAAC,iBAAQJ,KAAEI,IAAEJ,MAAG,GAAEA;AAAI,YAAEc,GAAEd,EAAC,GAAED,EAAC;AAAA,MAAC,GAAE,EAAE,UAAU,YAAU,SAASA,IAAE;AAAC,iBAAQe,KAAEf,GAAE,SAAO,GAAEK,KAAE,QAAOU,MAAG,GAAEA;AAAI,gBAAIf,GAAEe,EAAC,EAAE,SAAS,SAAOA,KAAE,KAAGV,KAAEL,GAAEe,KAAE,CAAC,EAAE,UAAU,OAAOV,GAAE,QAAQL,GAAEe,EAAC,CAAC,GAAE,CAAC,IAAE,KAAK,MAAM,IAAE,EAAEf,GAAEe,EAAC,GAAE,KAAK,MAAM;AAAA,MAAC,GAAE;AAAA,IAAC,CAAC;AAAA;AAAA;;;ACA7zM;AAAA;AAyBA,KAAC,SAAU,MAAM,SAAS;AACxB;AACA,UAAI,OAAO,WAAW,cAAc,OAAO,KAAK,GAAG;AACjD,eAAO,OAAO;AAAA,MAChB,WAAW,OAAO,YAAY,UAAU;AACtC,eAAO,SAAS,IAAI,QAAQ;AAAA,MAC9B,OAAO;AACL,aAAK,KAAK,IAAI,QAAQ;AAAA,MACxB;AAAA,IACF,GAAE,SAAM,WAAY;AAClB;AAEA,UAAI,MAAM,CAAC;AAeX,eAAS,OAAO,GAAG,GAAG;AACpB,aAAK,GAAG,IAAI,KAAK;AACjB,aAAK,GAAG,IAAI,KAAK;AAAA,MACnB;AACA,UAAI,QAAQ,IAAI;AAEhB,UAAI,GAAG,IAAI;AAQX,aAAO,UAAU,MAAM,IAAI,OAAO,UAAU,OAAO,SAAU,OAAO;AAClE,aAAK,GAAG,IAAI,MAAM,GAAG;AACrB,aAAK,GAAG,IAAI,MAAM,GAAG;AACrB,eAAO;AAAA,MACT;AAMA,aAAO,UAAU,OAAO,IAAI,OAAO,UAAU,QAAQ,WAAY;AAC/D,eAAO,IAAI,OAAO,KAAK,GAAG,GAAG,KAAK,GAAG,CAAC;AAAA,MACxC;AAOA,aAAO,UAAU,MAAM,IAAI,OAAO,UAAU,OAAO,WAAY;AAC7D,YAAI,IAAI,KAAK,GAAG;AAChB,aAAK,GAAG,IAAI,KAAK,GAAG;AACpB,aAAK,GAAG,IAAI,CAAC;AACb,eAAO;AAAA,MACT;AAOA,aAAO,UAAU,QAAQ,IAAI,OAAO,UAAU,SAAS,SAAU,OAAO;AACtE,YAAI,IAAI,KAAK,GAAG;AAChB,YAAI,IAAI,KAAK,GAAG;AAChB,aAAK,GAAG,IAAI,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,KAAK,IAAI,KAAK;AACpD,aAAK,GAAG,IAAI,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,KAAK,IAAI,KAAK;AACpD,eAAO;AAAA,MACT;AAMA,aAAO,UAAU,SAAS,IAAI,OAAO,UAAU,UAAU,WAAY;AACnE,aAAK,GAAG,IAAI,CAAC,KAAK,GAAG;AACrB,aAAK,GAAG,IAAI,CAAC,KAAK,GAAG;AACrB,eAAO;AAAA,MACT;AAOA,aAAO,UAAU,WAAW,IAAI,OAAO,UAAU,YAAY,WAAY;AACvE,YAAI,IAAI,KAAK,IAAI;AACjB,YAAI,IAAI,GAAG;AACT,eAAK,GAAG,IAAI,KAAK,GAAG,IAAI;AACxB,eAAK,GAAG,IAAI,KAAK,GAAG,IAAI;AAAA,QAC1B;AACA,eAAO;AAAA,MACT;AAOA,aAAO,UAAU,KAAK,IAAI,OAAO,UAAU,MAAM,SAAU,OAAO;AAChE,aAAK,GAAG,KAAK,MAAM,GAAG;AACtB,aAAK,GAAG,KAAK,MAAM,GAAG;AACtB,eAAO;AAAA,MACT;AAOA,aAAO,UAAU,KAAK,IAAI,OAAO,UAAU,MAAM,SAAU,OAAO;AAChE,aAAK,GAAG,KAAK,MAAM,GAAG;AACtB,aAAK,GAAG,KAAK,MAAM,GAAG;AACtB,eAAO;AAAA,MACT;AAUA,aAAO,UAAU,OAAO,IAAI,OAAO,UAAU,QAAQ,SAAU,GAAG,GAAG;AACnE,aAAK,GAAG,KAAK;AACb,aAAK,GAAG,KAAK,OAAO,KAAK,cAAc,IAAI;AAC3C,eAAO;AAAA,MACT;AAOA,aAAO,UAAU,SAAS,IAAI,OAAO,UAAU,UAAU,SAAU,OAAO;AACxE,YAAI,MAAM,KAAK,IAAI,KAAK,IAAI,MAAM,KAAK;AACvC,aAAK,GAAG,IAAI,MAAM,MAAM,GAAG;AAC3B,aAAK,GAAG,IAAI,MAAM,MAAM,GAAG;AAC3B,eAAO;AAAA,MACT;AAQA,aAAO,UAAU,UAAU,IAAI,OAAO,UAAU,WAAW,SAAU,OAAO;AAC1E,YAAI,MAAM,KAAK,IAAI,KAAK;AACxB,aAAK,GAAG,IAAI,MAAM,MAAM,GAAG;AAC3B,aAAK,GAAG,IAAI,MAAM,MAAM,GAAG;AAC3B,eAAO;AAAA,MACT;AAOA,aAAO,UAAU,SAAS,IAAI,OAAO,UAAU,UAAU,SAAU,MAAM;AACvE,YAAI,IAAI,KAAK,GAAG;AAChB,YAAI,IAAI,KAAK,GAAG;AAChB,aAAK,QAAQ,IAAI,EAAE,MAAM,CAAC;AAC1B,aAAK,GAAG,KAAK;AACb,aAAK,GAAG,KAAK;AACb,eAAO;AAAA,MACT;AAQA,aAAO,UAAU,UAAU,IAAI,OAAO,UAAU,WAAW,SAAU,MAAM;AACzE,YAAI,IAAI,KAAK,GAAG;AAChB,YAAI,IAAI,KAAK,GAAG;AAChB,aAAK,SAAS,IAAI,EAAE,MAAM,CAAC;AAC3B,aAAK,GAAG,KAAK;AACb,aAAK,GAAG,KAAK;AACb,eAAO;AAAA,MACT;AAOA,aAAO,UAAU,KAAK,IAAI,OAAO,UAAU,MAAM,SAAU,OAAO;AAChE,eAAO,KAAK,GAAG,IAAI,MAAM,GAAG,IAAI,KAAK,GAAG,IAAI,MAAM,GAAG;AAAA,MACvD;AAMA,aAAO,UAAU,MAAM,IAAI,OAAO,UAAU,OAAO,WAAY;AAC7D,eAAO,KAAK,IAAI,IAAI;AAAA,MACtB;AAMA,aAAO,UAAU,KAAK,IAAI,OAAO,UAAU,MAAM,WAAY;AAC3D,eAAO,KAAK,KAAK,KAAK,KAAK,CAAC;AAAA,MAC9B;AAcA,eAAS,OAAO,KAAK,GAAG;AACtB,aAAK,KAAK,IAAI,OAAO,IAAI,OAAO;AAChC,aAAK,GAAG,IAAI,KAAK;AACjB,aAAK,QAAQ,IAAI,IAAI,OAAO;AAAA,MAC9B;AACA,UAAI,QAAQ,IAAI;AAQhB,aAAO,UAAU,cAAc,IAAI,OAAO,UAAU,eAAe,WAAY;AAC7E,YAAI,IAAI,KAAK,GAAG;AAChB,YAAI,SAAS,KAAK,KAAK,EAAE,MAAM,EAAE,IAAI,KAAK,QAAQ,CAAC,EAAE,IAAI,IAAI,OAAO,GAAG,CAAC,CAAC;AACzE,eAAO,IAAI,IAAI,QAAQ,IAAI,GAAG,IAAI,CAAC;AAAA,MACrC;AAQA,aAAO,UAAU,SAAS,IAAI,OAAO,UAAU,UAAU,WAAY;AACnE,eAAO,KAAK,aAAa,EAAE,UAAU;AAAA,MACvC;AAOA,aAAO,UAAU,WAAW,IAAI,OAAO,UAAU,YAAY,SAAU,QAAQ;AAC7E,aAAK,QAAQ,IAAI;AACjB,eAAO;AAAA,MACT;AAqBA,eAAS,QAAQ,KAAK,QAAQ;AAC5B,aAAK,KAAK,IAAI,OAAO,IAAI,OAAO;AAChC,aAAK,OAAO,IAAI;AAChB,aAAK,QAAQ,IAAI,IAAI,OAAO;AAC5B,aAAK,UAAU,UAAU,CAAC,CAAC;AAAA,MAC7B;AACA,UAAI,SAAS,IAAI;AAajB,cAAQ,UAAU,WAAW,IAAI,QAAQ,UAAU,YAAY,SAAU,QAAQ;AAE/E,YAAI,gBAAgB,CAAC,KAAK,QAAQ,KAAK,KAAK,QAAQ,EAAE,WAAW,OAAO;AACxE,YAAI,eAAe;AACjB,cAAIC;AACJ,cAAI,aAAa,KAAK,YAAY,IAAI,CAAC;AACvC,cAAI,QAAQ,KAAK,OAAO,IAAI,CAAC;AAC7B,cAAI,UAAU,KAAK,SAAS,IAAI,CAAC;AAEjC,eAAKA,KAAI,GAAGA,KAAI,OAAO,QAAQA,MAAK;AAElC,gBAAI,KAAK,OAAOA,EAAC;AACjB,gBAAI,KAAKA,KAAI,OAAO,SAAS,IAAI,OAAOA,KAAI,CAAC,IAAI,OAAO,CAAC;AACzD,gBAAI,OAAO,MAAM,GAAG,MAAM,GAAG,KAAK,GAAG,MAAM,GAAG,GAAG;AAC/C,qBAAO,OAAOA,IAAG,CAAC;AAClB,cAAAA,MAAK;AACL;AAAA,YACF;AACA,uBAAW,KAAK,IAAI,OAAO,CAAC;AAC5B,kBAAM,KAAK,IAAI,OAAO,CAAC;AACvB,oBAAQ,KAAK,IAAI,OAAO,CAAC;AAAA,UAC3B;AAAA,QACF;AACA,aAAK,QAAQ,IAAI;AACjB,aAAK,QAAQ;AACb,eAAO;AAAA,MACT;AAOA,cAAQ,UAAU,UAAU,IAAI,QAAQ,UAAU,WAAW,SAAU,OAAO;AAC5E,aAAK,OAAO,IAAI;AAChB,aAAK,QAAQ;AACb,eAAO;AAAA,MACT;AAOA,cAAQ,UAAU,WAAW,IAAI,QAAQ,UAAU,YAAY,SAAU,QAAQ;AAC/E,aAAK,QAAQ,IAAI;AACjB,aAAK,QAAQ;AACb,eAAO;AAAA,MACT;AASA,cAAQ,UAAU,QAAQ,IAAI,QAAQ,UAAU,SAAS,SAAU,OAAO;AACxE,YAAI,SAAS,KAAK,QAAQ;AAC1B,YAAI,MAAM,OAAO;AACjB,iBAASA,KAAI,GAAGA,KAAI,KAAKA,MAAK;AAC5B,iBAAOA,EAAC,EAAE,OAAO,KAAK;AAAA,QACxB;AACA,aAAK,QAAQ;AACb,eAAO;AAAA,MACT;AAcA,cAAQ,UAAU,WAAW,IAAI,QAAQ,UAAU,YAAY,SAAU,GAAG,GAAG;AAC7E,YAAI,SAAS,KAAK,QAAQ;AAC1B,YAAI,MAAM,OAAO;AACjB,iBAASA,KAAI,GAAGA,KAAI,KAAKA,MAAK;AAC5B,iBAAOA,EAAC,EAAE,GAAG,KAAK;AAClB,iBAAOA,EAAC,EAAE,GAAG,KAAK;AAAA,QACpB;AACA,aAAK,QAAQ;AACb,eAAO;AAAA,MACT;AAQA,cAAQ,UAAU,UAAU,WAAY;AAGtC,YAAI,aAAa,KAAK,YAAY;AAIlC,YAAI,QAAQ,KAAK,OAAO;AAIxB,YAAI,UAAU,KAAK,SAAS;AAE5B,YAAI,SAAS,KAAK,QAAQ;AAC1B,YAAI,SAAS,KAAK,QAAQ;AAC1B,YAAI,QAAQ,KAAK,OAAO;AACxB,YAAI,MAAM,OAAO;AACjB,YAAIA;AACJ,aAAKA,KAAI,GAAGA,KAAI,KAAKA,MAAK;AACxB,cAAI,YAAY,WAAWA,EAAC,EAAE,KAAK,OAAOA,EAAC,CAAC;AAC5C,oBAAU,GAAG,KAAK,OAAO,GAAG;AAC5B,oBAAU,GAAG,KAAK,OAAO,GAAG;AAC5B,cAAI,UAAU,GAAG;AACf,sBAAU,OAAO,KAAK;AAAA,UACxB;AAAA,QACF;AAEA,aAAKA,KAAI,GAAGA,KAAI,KAAKA,MAAK;AACxB,cAAI,KAAK,WAAWA,EAAC;AACrB,cAAI,KAAKA,KAAI,MAAM,IAAI,WAAWA,KAAI,CAAC,IAAI,WAAW,CAAC;AACvD,cAAI,IAAI,MAAMA,EAAC,EAAE,KAAK,EAAE,EAAE,IAAI,EAAE;AAChC,kBAAQA,EAAC,EAAE,KAAK,CAAC,EAAE,KAAK,EAAE,UAAU;AAAA,QACtC;AACA,eAAO;AAAA,MACT;AAUA,cAAQ,UAAU,cAAc,IAAI,QAAQ,UAAU,eAAe,WAAY;AAC/E,YAAI,SAAS,KAAK,YAAY;AAC9B,YAAI,MAAM,OAAO;AACjB,YAAI,OAAO,OAAO,CAAC,EAAE,GAAG;AACxB,YAAI,OAAO,OAAO,CAAC,EAAE,GAAG;AACxB,YAAI,OAAO,OAAO,CAAC,EAAE,GAAG;AACxB,YAAI,OAAO,OAAO,CAAC,EAAE,GAAG;AACxB,iBAASA,KAAI,GAAGA,KAAI,KAAKA,MAAK;AAC5B,cAAI,QAAQ,OAAOA,EAAC;AACpB,cAAI,MAAM,GAAG,IAAI,MAAM;AACrB,mBAAO,MAAM,GAAG;AAAA,UAClB,WACS,MAAM,GAAG,IAAI,MAAM;AAC1B,mBAAO,MAAM,GAAG;AAAA,UAClB;AACA,cAAI,MAAM,GAAG,IAAI,MAAM;AACrB,mBAAO,MAAM,GAAG;AAAA,UAClB,WACS,MAAM,GAAG,IAAI,MAAM;AAC1B,mBAAO,MAAM,GAAG;AAAA,UAClB;AAAA,QACF;AACA,eAAO,IAAI,IAAI,KAAK,KAAK,EAAE,MAAM,EAAE,IAAI,IAAI,OAAO,MAAM,IAAI,CAAC,GAAG,OAAO,MAAM,OAAO,IAAI;AAAA,MAC1F;AAUA,cAAQ,UAAU,SAAS,IAAI,QAAQ,UAAU,UAAU,WAAY;AACrE,eAAO,KAAK,aAAa,EAAE,UAAU;AAAA,MACvC;AAWA,cAAQ,UAAU,aAAa,IAAI,QAAQ,UAAU,cAAc,WAAY;AAC7E,YAAI,SAAS,KAAK,YAAY;AAC9B,YAAI,MAAM,OAAO;AACjB,YAAI,KAAK;AACT,YAAI,KAAK;AACT,YAAI,KAAK;AACT,iBAASA,KAAI,GAAGA,KAAI,KAAKA,MAAK;AAC5B,cAAI,KAAK,OAAOA,EAAC;AACjB,cAAI,KAAKA,OAAM,MAAM,IAAI,OAAO,CAAC,IAAI,OAAOA,KAAI,CAAC;AACjD,cAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG;AAC5C,iBAAO,GAAG,GAAG,IAAI,GAAG,GAAG,KAAK;AAC5B,iBAAO,GAAG,GAAG,IAAI,GAAG,GAAG,KAAK;AAC5B,gBAAM;AAAA,QACR;AACA,aAAK,KAAK;AACV,aAAK,KAAK;AACV,aAAK,KAAK;AACV,eAAO,IAAI,OAAO,IAAI,EAAE;AAAA,MAC1B;AAiBA,eAAS,IAAI,KAAK,GAAG,GAAG;AACtB,aAAK,KAAK,IAAI,OAAO,IAAI,OAAO;AAChC,aAAK,GAAG,IAAI,KAAK;AACjB,aAAK,GAAG,IAAI,KAAK;AAAA,MACnB;AACA,UAAI,KAAK,IAAI;AAMb,UAAI,UAAU,WAAW,IAAI,IAAI,UAAU,YAAY,WAAY;AACjE,YAAI,MAAM,KAAK,KAAK;AACpB,YAAI,IAAI,KAAK,GAAG;AAChB,YAAI,IAAI,KAAK,GAAG;AAChB,eAAO,IAAI,QAAQ,IAAI,OAAO,IAAI,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG;AAAA,UACjD,IAAI,OAAO;AAAA,UAAG,IAAI,OAAO,GAAG,CAAC;AAAA,UAC7B,IAAI,OAAO,GAAG,CAAC;AAAA,UAAG,IAAI,OAAO,GAAG,CAAC;AAAA,QACnC,CAAC;AAAA,MACH;AAaA,eAAS,WAAW;AAClB,aAAK,GAAG,IAAI;AACZ,aAAK,GAAG,IAAI;AACZ,aAAK,UAAU,IAAI,IAAI,OAAO;AAC9B,aAAK,UAAU,IAAI,IAAI,OAAO;AAC9B,aAAK,MAAM;AAAA,MACb;AACA,UAAI,UAAU,IAAI;AAQlB,eAAS,UAAU,OAAO,IAAI,SAAS,UAAU,QAAQ,WAAY;AACnE,aAAK,MAAM,IAAI;AACf,aAAK,MAAM,IAAI;AACf,aAAK,SAAS,IAAI,OAAO;AACzB,eAAO;AAAA,MACT;AASA,UAAI,YAAY,CAAC;AACjB,eAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAAE,kBAAU,KAAK,IAAI,OAAO,CAAC;AAAA,MAAG;AAO7D,UAAI,WAAW,CAAC;AAChB,eAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAAE,iBAAS,KAAK,CAAC,CAAC;AAAA,MAAG;AAMjD,UAAI,aAAa,IAAI,SAAS;AAM9B,UAAI,aAAa,IAAI,IAAI,IAAI,OAAO,GAAG,MAAU,IAAQ,EAAE,UAAU;AAcrE,eAAS,gBAAgB,QAAQ,QAAQ,QAAQ;AAC/C,YAAI,MAAM,OAAO;AACjB,YAAI,MAAM,CAAC,OAAO;AAClB,YAAI,MAAM,OAAO;AACjB,iBAASA,KAAI,GAAGA,KAAI,KAAKA,MAAK;AAE5B,cAAI,MAAM,OAAOA,EAAC,EAAE,IAAI,MAAM;AAC9B,cAAI,MAAM,KAAK;AAAE,kBAAM;AAAA,UAAK;AAC5B,cAAI,MAAM,KAAK;AAAE,kBAAM;AAAA,UAAK;AAAA,QAC9B;AACA,eAAO,CAAC,IAAI;AAAK,eAAO,CAAC,IAAI;AAAA,MAC/B;AAiBA,eAAS,iBAAiB,MAAM,MAAM,SAAS,SAAS,MAAM,UAAU;AACtE,YAAI,SAAS,SAAS,IAAI;AAC1B,YAAI,SAAS,SAAS,IAAI;AAE1B,YAAI,UAAU,UAAU,IAAI,EAAE,KAAK,IAAI,EAAE,IAAI,IAAI;AACjD,YAAI,kBAAkB,QAAQ,IAAI,IAAI;AAEtC,wBAAgB,SAAS,MAAM,MAAM;AACrC,wBAAgB,SAAS,MAAM,MAAM;AAErC,eAAO,CAAC,KAAK;AACb,eAAO,CAAC,KAAK;AAEb,YAAI,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK,OAAO,CAAC,IAAI,OAAO,CAAC,GAAG;AAClD,oBAAU,KAAK,OAAO;AACtB,mBAAS,KAAK,MAAM;AACpB,mBAAS,KAAK,MAAM;AACpB,iBAAO;AAAA,QACT;AAEA,YAAI,UAAU;AACZ,cAAI,UAAU;AAEd,cAAI,OAAO,CAAC,IAAI,OAAO,CAAC,GAAG;AACzB,qBAAS,MAAM,IAAI;AAEnB,gBAAI,OAAO,CAAC,IAAI,OAAO,CAAC,GAAG;AACzB,wBAAU,OAAO,CAAC,IAAI,OAAO,CAAC;AAC9B,uBAAS,MAAM,IAAI;AAAA,YAErB,OAAO;AACL,kBAAI,UAAU,OAAO,CAAC,IAAI,OAAO,CAAC;AAClC,kBAAI,UAAU,OAAO,CAAC,IAAI,OAAO,CAAC;AAClC,wBAAU,UAAU,UAAU,UAAU,CAAC;AAAA,YAC3C;AAAA,UAEF,OAAO;AACL,qBAAS,MAAM,IAAI;AAEnB,gBAAI,OAAO,CAAC,IAAI,OAAO,CAAC,GAAG;AACzB,wBAAU,OAAO,CAAC,IAAI,OAAO,CAAC;AAC9B,uBAAS,MAAM,IAAI;AAAA,YAErB,OAAO;AACL,kBAAI,UAAU,OAAO,CAAC,IAAI,OAAO,CAAC;AAClC,kBAAI,UAAU,OAAO,CAAC,IAAI,OAAO,CAAC;AAClC,wBAAU,UAAU,UAAU,UAAU,CAAC;AAAA,YAC3C;AAAA,UACF;AAEA,cAAI,aAAa,KAAK,IAAI,OAAO;AACjC,cAAI,aAAa,SAAS,SAAS,GAAG;AACpC,qBAAS,SAAS,IAAI;AACtB,qBAAS,UAAU,EAAE,KAAK,IAAI;AAC9B,gBAAI,UAAU,GAAG;AACf,uBAAS,UAAU,EAAE,QAAQ;AAAA,YAC/B;AAAA,UACF;AAAA,QACF;AACA,kBAAU,KAAK,OAAO;AACtB,iBAAS,KAAK,MAAM;AACpB,iBAAS,KAAK,MAAM;AACpB,eAAO;AAAA,MACT;AACA,UAAI,kBAAkB,IAAI;AAe1B,eAAS,cAAc,MAAM,OAAO;AAClC,YAAI,OAAO,KAAK,KAAK;AACrB,YAAI,KAAK,MAAM,IAAI,IAAI;AAGvB,YAAI,KAAK,GAAG;AAAE,iBAAO;AAAA,QAAqB,WAGjC,KAAK,MAAM;AAAE,iBAAO;AAAA,QAAsB,OAE9C;AAAE,iBAAO;AAAA,QAAuB;AAAA,MACvC;AAKA,UAAI,sBAAsB;AAI1B,UAAI,wBAAwB;AAI5B,UAAI,uBAAuB;AAU3B,eAAS,cAAc,GAAG,GAAG;AAC3B,YAAI,cAAc,UAAU,IAAI,EAAE,KAAK,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,EAAE,IAAI,EAAE,QAAQ,CAAC;AACvE,YAAI,WAAW,EAAE,GAAG,IAAI,EAAE,GAAG;AAC7B,YAAI,aAAa,YAAY,KAAK;AAClC,kBAAU,KAAK,WAAW;AAE1B,eAAO,cAAc;AAAA,MACvB;AACA,UAAI,eAAe,IAAI;AAQvB,eAAS,eAAe,GAAG,MAAM;AAC/B,mBAAW,KAAK,EAAE,KAAK,CAAC;AACxB,mBAAW,MAAM;AACjB,YAAI,SAAS,mBAAmB,YAAY,MAAM,UAAU;AAC5D,YAAI,QAAQ;AACV,mBAAS,WAAW,MAAM;AAAA,QAC5B;AACA,eAAO;AAAA,MACT;AACA,UAAI,gBAAgB,IAAI;AAUxB,eAAS,iBAAiB,GAAG,GAAG,UAAU;AAGxC,YAAI,cAAc,UAAU,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,IAAI,EAAE,QAAQ,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,EAAE,IAAI,EAAE,QAAQ,CAAC;AAC/F,YAAI,cAAc,EAAE,GAAG,IAAI,EAAE,GAAG;AAChC,YAAI,gBAAgB,cAAc;AAClC,YAAI,aAAa,YAAY,KAAK;AAElC,YAAI,aAAa,eAAe;AAC9B,oBAAU,KAAK,WAAW;AAC1B,iBAAO;AAAA,QACT;AAEA,YAAI,UAAU;AACZ,cAAI,OAAO,KAAK,KAAK,UAAU;AAC/B,mBAAS,GAAG,IAAI;AAChB,mBAAS,GAAG,IAAI;AAChB,mBAAS,SAAS,IAAI,cAAc;AACpC,mBAAS,UAAU,EAAE,KAAK,YAAY,UAAU,CAAC;AACjD,mBAAS,UAAU,EAAE,KAAK,WAAW,EAAE,MAAM,SAAS,SAAS,CAAC;AAChE,mBAAS,MAAM,IAAI,EAAE,GAAG,KAAK,EAAE,GAAG,KAAK,QAAQ,EAAE,GAAG,IAAI,EAAE,GAAG;AAC7D,mBAAS,MAAM,IAAI,EAAE,GAAG,KAAK,EAAE,GAAG,KAAK,QAAQ,EAAE,GAAG,IAAI,EAAE,GAAG;AAAA,QAC/D;AACA,kBAAU,KAAK,WAAW;AAC1B,eAAO;AAAA,MACT;AACA,UAAI,kBAAkB,IAAI;AAU1B,eAAS,kBAAkB,SAAS,QAAQ,UAAU;AAEpD,YAAI,YAAY,UAAU,IAAI,EAAE,KAAK,OAAO,KAAK,CAAC,EAAE,IAAI,OAAO,QAAQ,CAAC,EAAE,IAAI,QAAQ,KAAK,CAAC;AAC5F,YAAI,SAAS,OAAO,GAAG;AACvB,YAAI,UAAU,SAAS;AACvB,YAAI,SAAS,QAAQ,YAAY;AACjC,YAAI,MAAM,OAAO;AACjB,YAAI,OAAO,UAAU,IAAI;AACzB,YAAI,QAAQ,UAAU,IAAI;AAG1B,iBAASA,KAAI,GAAGA,KAAI,KAAKA,MAAK;AAC5B,cAAI,OAAOA,OAAM,MAAM,IAAI,IAAIA,KAAI;AACnC,cAAI,OAAOA,OAAM,IAAI,MAAM,IAAIA,KAAI;AACnC,cAAI,UAAU;AACd,cAAI,WAAW;AAGf,eAAK,KAAK,QAAQ,OAAO,EAAEA,EAAC,CAAC;AAE7B,gBAAM,KAAK,SAAS,EAAE,IAAI,OAAOA,EAAC,CAAC;AAKnC,cAAI,YAAY,MAAM,KAAK,IAAI,SAAS;AACtC,qBAAS,MAAM,IAAI;AAAA,UACrB;AAGA,cAAI,SAAS,cAAc,MAAM,KAAK;AAEtC,cAAI,WAAW,qBAAqB;AAElC,iBAAK,KAAK,QAAQ,OAAO,EAAE,IAAI,CAAC;AAEhC,gBAAI,SAAS,UAAU,IAAI,EAAE,KAAK,SAAS,EAAE,IAAI,OAAO,IAAI,CAAC;AAC7D,qBAAS,cAAc,MAAM,MAAM;AACnC,gBAAI,WAAW,sBAAsB;AAEnC,kBAAI,OAAO,MAAM,IAAI;AACrB,kBAAI,OAAO,QAAQ;AAEjB,0BAAU,KAAK,SAAS;AACxB,0BAAU,KAAK,IAAI;AACnB,0BAAU,KAAK,KAAK;AACpB,0BAAU,KAAK,MAAM;AACrB,uBAAO;AAAA,cACT,WAAW,UAAU;AAEnB,yBAAS,MAAM,IAAI;AACnB,2BAAW,MAAM,UAAU;AAC3B,0BAAU,SAAS;AAAA,cACrB;AAAA,YACF;AACA,sBAAU,KAAK,MAAM;AAAA,UAEvB,WAAW,WAAW,sBAAsB;AAE1C,iBAAK,KAAK,QAAQ,OAAO,EAAE,IAAI,CAAC;AAEhC,kBAAM,KAAK,SAAS,EAAE,IAAI,OAAO,IAAI,CAAC;AACtC,qBAAS,cAAc,MAAM,KAAK;AAClC,gBAAI,WAAW,qBAAqB;AAElC,kBAAI,OAAO,MAAM,IAAI;AACrB,kBAAI,OAAO,QAAQ;AAEjB,0BAAU,KAAK,SAAS;AACxB,0BAAU,KAAK,IAAI;AACnB,0BAAU,KAAK,KAAK;AACpB,uBAAO;AAAA,cACT,WAAW,UAAU;AAEnB,yBAAS,MAAM,IAAI;AACnB,2BAAW,MAAM,UAAU;AAC3B,0BAAU,SAAS;AAAA,cACrB;AAAA,YACF;AAAA,UAEF,OAAO;AAGL,gBAAI,SAAS,KAAK,KAAK,EAAE,UAAU;AAGnC,gBAAI,OAAO,MAAM,IAAI,MAAM;AAC3B,gBAAI,UAAU,KAAK,IAAI,IAAI;AAE3B,gBAAI,OAAO,KAAK,UAAU,QAAQ;AAEhC,wBAAU,KAAK,SAAS;AACxB,wBAAU,KAAK,MAAM;AACrB,wBAAU,KAAK,KAAK;AACpB,qBAAO;AAAA,YACT,WAAW,UAAU;AAEnB,yBAAW;AACX,wBAAU,SAAS;AAGnB,kBAAI,QAAQ,KAAK,UAAU,IAAI,QAAQ;AACrC,yBAAS,MAAM,IAAI;AAAA,cACrB;AAAA,YACF;AAAA,UACF;AAIA,cAAI,YAAY,YAAY,KAAK,IAAI,OAAO,IAAI,KAAK,IAAI,SAAS,SAAS,CAAC,GAAG;AAC7E,qBAAS,SAAS,IAAI;AACtB,qBAAS,UAAU,EAAE,KAAK,QAAQ;AAAA,UACpC;AAAA,QACF;AAGA,YAAI,UAAU;AACZ,mBAAS,GAAG,IAAI;AAChB,mBAAS,GAAG,IAAI;AAChB,mBAAS,UAAU,EAAE,KAAK,SAAS,UAAU,CAAC,EAAE,MAAM,SAAS,SAAS,CAAC;AAAA,QAC3E;AACA,kBAAU,KAAK,SAAS;AACxB,kBAAU,KAAK,IAAI;AACnB,kBAAU,KAAK,KAAK;AACpB,eAAO;AAAA,MACT;AACA,UAAI,mBAAmB,IAAI;AAa3B,eAAS,kBAAkB,QAAQ,SAAS,UAAU;AAEpD,YAAI,SAAS,kBAAkB,SAAS,QAAQ,QAAQ;AACxD,YAAI,UAAU,UAAU;AAEtB,cAAI,IAAI,SAAS,GAAG;AACpB,cAAI,OAAO,SAAS,MAAM;AAC1B,mBAAS,UAAU,EAAE,QAAQ;AAC7B,mBAAS,UAAU,EAAE,QAAQ;AAC7B,mBAAS,GAAG,IAAI,SAAS,GAAG;AAC5B,mBAAS,GAAG,IAAI;AAChB,mBAAS,MAAM,IAAI,SAAS,MAAM;AAClC,mBAAS,MAAM,IAAI;AAAA,QACrB;AACA,eAAO;AAAA,MACT;AACA,UAAI,mBAAmB,IAAI;AAU3B,eAAS,mBAAmB,GAAG,GAAG,UAAU;AAC1C,YAAI,UAAU,EAAE,YAAY;AAC5B,YAAI,OAAO,QAAQ;AACnB,YAAI,UAAU,EAAE,YAAY;AAC5B,YAAI,OAAO,QAAQ;AAEnB,iBAASA,KAAI,GAAGA,KAAI,MAAMA,MAAK;AAC7B,cAAI,iBAAiB,EAAE,KAAK,GAAG,EAAE,KAAK,GAAG,SAAS,SAAS,EAAE,SAAS,EAAEA,EAAC,GAAG,QAAQ,GAAG;AACrF,mBAAO;AAAA,UACT;AAAA,QACF;AAEA,iBAASA,KAAI,GAAGA,KAAI,MAAMA,MAAK;AAC7B,cAAI,iBAAiB,EAAE,KAAK,GAAG,EAAE,KAAK,GAAG,SAAS,SAAS,EAAE,SAAS,EAAEA,EAAC,GAAG,QAAQ,GAAG;AACrF,mBAAO;AAAA,UACT;AAAA,QACF;AAIA,YAAI,UAAU;AACZ,mBAAS,GAAG,IAAI;AAChB,mBAAS,GAAG,IAAI;AAChB,mBAAS,UAAU,EAAE,KAAK,SAAS,UAAU,CAAC,EAAE,MAAM,SAAS,SAAS,CAAC;AAAA,QAC3E;AACA,eAAO;AAAA,MACT;AACA,UAAI,oBAAoB,IAAI;AAE5B,aAAO;AAAA,IACT,CAAC;AAAA;AAAA;;;ACjiCD;AAAA;AAAA;AACA,QAAI,kBAAmB,WAAQ,QAAK,mBAAoB,SAAU,KAAK;AACnE,aAAQ,OAAO,IAAI,aAAc,MAAM,EAAE,WAAW,IAAI;AAAA,IAC5D;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,YAAQ,WAAW,QAAQ,YAAY,QAAQ,aAAa,QAAQ,YAAY,QAAQ,WAAW,QAAQ,QAAQ;AACnH,QAAM,UAAU,gBAAgB,mBAAgB;AAChD,WAAO,eAAe,SAAS,SAAS,EAAE,YAAY,MAAM,KAAK,WAAY;AAAE,aAAO,QAAQ;AAAA,IAAS,EAAE,CAAC;AAC1G,QAAM,QAAQ;AACd,WAAO,eAAe,SAAS,YAAY,EAAE,YAAY,MAAM,KAAK,WAAY;AAAE,aAAO,MAAM;AAAA,IAAU,EAAE,CAAC;AAC5G,WAAO,eAAe,SAAS,aAAa,EAAE,YAAY,MAAM,KAAK,WAAY;AAAE,aAAO,MAAM;AAAA,IAAQ,EAAE,CAAC;AAC3G,WAAO,eAAe,SAAS,cAAc,EAAE,YAAY,MAAM,KAAK,WAAY;AAAE,aAAO,MAAM;AAAA,IAAS,EAAE,CAAC;AAC7G,WAAO,eAAe,SAAS,aAAa,EAAE,YAAY,MAAM,KAAK,WAAY;AAAE,aAAO,MAAM;AAAA,IAAQ,EAAE,CAAC;AAI3G,QAAI;AACJ,KAAC,SAAUC,WAAU;AACjB,MAAAA,UAAS,SAAS,IAAI;AACtB,MAAAA,UAAS,MAAM,IAAI;AACnB,MAAAA,UAAS,QAAQ,IAAI;AACrB,MAAAA,UAAS,KAAK,IAAI;AAClB,MAAAA,UAAS,OAAO,IAAI;AACpB,MAAAA,UAAS,SAAS,IAAI;AAAA,IAC1B,GAAG,aAAa,QAAQ,WAAW,WAAW,CAAC,EAAE;AAAA;AAAA;;;ACxBjD;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,YAAQ,MAAM,QAAQ,SAAS,QAAQ,QAAQ,QAAQ,OAAO,QAAQ,UAAU;AAMhF,QAAM,UAAU,CAAC,OAAO,aAAa;AACjC,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAI,GAAG,KAAK;AAC1C,iBAAS,MAAM,CAAC,GAAG,CAAC;AAAA,MACxB;AAAA,IACJ;AACA,YAAQ,UAAU;AAMlB,QAAM,OAAO,CAAC,OAAO,aAAa;AAC9B,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAI,GAAG,KAAK;AAC1C,YAAI,SAAS,MAAM,CAAC,GAAG,CAAC,GAAG;AACvB,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AACA,YAAQ,OAAO;AAMf,QAAM,QAAQ,CAAC,OAAO,aAAa;AAC/B,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAI,GAAG,KAAK;AAC1C,YAAI,CAAC,SAAS,MAAM,CAAC,GAAG,CAAC,GAAG;AACxB,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AACA,YAAQ,QAAQ;AAMhB,QAAM,SAAS,CAAC,OAAO,aAAa;AAChC,YAAM,SAAS,CAAC;AAChB,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAI,GAAG,KAAK;AAC1C,cAAM,OAAO,MAAM,CAAC;AACpB,YAAI,SAAS,MAAM,CAAC,GAAG;AACnB,iBAAO,KAAK,IAAI;AAAA,QACpB;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AACA,YAAQ,SAAS;AAMjB,QAAM,MAAM,CAAC,OAAO,aAAa;AAC7B,YAAM,SAAS,IAAI,MAAM,MAAM,MAAM;AACrC,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAI,GAAG,KAAK;AAC1C,eAAO,CAAC,IAAI,SAAS,MAAM,CAAC,GAAG,CAAC;AAAA,MACpC;AACA,aAAO;AAAA,IACX;AACA,YAAQ,MAAM;AAAA;AAAA;;;ACtEd;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,YAAQ,uBAAuB,QAAQ,oBAAoB,QAAQ,wBAAwB,QAAQ,sBAAsB,QAAQ,uBAAuB,QAAQ,kBAAkB,QAAQ,iBAAiB,QAAQ,gBAAgB,QAAQ,mBAAmB,QAAQ,iBAAiB,QAAQ,kBAAkB,QAAQ,eAAe;AACxU,QAAM,QAAQ;AACd,QAAM,UAAU;AAChB,QAAM,cAAc;AAIpB,aAAS,aAAa,MAAM;AACxB,UAAI,KAAK,YAAY,KAAK,SAAS,QAAQ,SAAS,SAAS;AACzD,eAAO,CAAC,IAAI;AAAA,MAChB;AACA,aAAO,KAAK;AAAA,IAChB;AACA,YAAQ,eAAe;AACvB,aAAS,gBAAgB,SAAS,QAAQ;AACtC,cAAQ,GAAG,YAAY,OAAO,QAAQ,YAAY,CAAC,OAAO,GAAG,MAAM,eAAe,EAAE,GAAG,EAAE,IAAI,QAAQ,IAAI,GAAG,GAAG,EAAE,IAAI,QAAQ,IAAI,EAAE,GAAG,MAAM,CAAC;AAAA,IACjJ;AACA,YAAQ,kBAAkB;AAC1B,aAAS,eAAe,OAAO,SAAS;AACpC,cAAQ,GAAG,YAAY,MAAM,aAAa,OAAO,GAAG,CAAC,YAAY,GAAG,MAAM,gBAAgB,OAAO,MAAM,CAAC;AAAA,IAC5G;AACA,YAAQ,iBAAiB;AACzB,aAAS,iBAAiB,UAAU,UAAU;AAC1C,cAAQ,GAAG,YAAY,OAAO,SAAS,YAAY,CAAC,UAAU,eAAe,EAAE,GAAG,MAAM,IAAI,SAAS,IAAI,GAAG,GAAG,MAAM,IAAI,SAAS,IAAI,EAAE,GAAG,QAAQ,CAAC;AAAA,IACxJ;AACA,YAAQ,mBAAmB;AAI3B,aAAS,cAAc,OAAO,QAAQ;AAClC,cAAS,MAAM,IAAI,OAAO,IAAI,MAAM,MAAM,IAAI,OAAO,IAAI,MACpD,MAAM,IAAI,OAAO,IAAI,MAAM,MAAM,IAAI,OAAO,IAAI,OACjD,OAAO,IAAI,OAAO;AAAA,IAC1B;AACA,YAAQ,gBAAgB;AAIxB,aAAS,eAAe,GAAG,GAAG;AAC1B,YAAM,KAAK,EAAE,IAAI;AACjB,YAAM,KAAK,EAAE,IAAI;AACjB,YAAM,KAAK,EAAE,IAAI;AACjB,YAAM,KAAK,EAAE,IAAI;AACjB,YAAM,KAAK,EAAE;AACb,YAAM,KAAK,EAAE;AACb,YAAM,SAAS,KAAK,MAAM,KAAK,OAAO,KAAK,OAAO,KAAK,OAAO,KAAK,GAAG;AACtE,aAAO,SAAS,OAAO,MAAM,SAAS,KAAK;AAAA,IAC/C;AACA,YAAQ,iBAAiB;AAIzB,aAAS,gBAAgB,QAAQ,SAAS;AAEtC,UAAI,OAAO,MAAM,GAAG;AAChB,eAAO;AAAA,MACX;AAIA,UAAI,CAAC,eAAe,OAAO,KAAK,OAAO,GAAG;AACtC,eAAO;AAAA,MACX;AAEA,YAAM,UAAU,GAAG,YAAY,KAAK,QAAQ,YAAY,CAAC,EAAE,GAAG,EAAE,OAAO;AAAA,QACnE,GAAG,IAAI,QAAQ,IAAI;AAAA,QACnB,GAAG,IAAI,QAAQ,IAAI;AAAA,MACvB,EAAE;AAIF,WAAK,GAAG,YAAY,MAAM,QAAQ,CAAC,WAAW,GAAG,MAAM,eAAe,OAAO,MAAM,CAAC,GAAG;AACnF,eAAO;AAAA,MACX;AAIA,WAAK,GAAG,YAAY,MAAM,QAAQ,CAAC,KAAK,UAAU;AAC9C,cAAM,QAAQ,QACR,OAAO,QAAQ,CAAC,IAChB,OAAO,OAAO,SAAS,CAAC;AAC9B,eAAO,oBAAoB,EAAE,OAAO,IAAI,GAAG,MAAM,EAAE,SAAS;AAAA,MAChE,CAAC,GAAG;AACA,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX;AACA,YAAQ,kBAAkB;AAI1B,aAAS,qBAAqB,QAAQ,SAAS;AAE3C,UAAI,OAAO,MAAM,GAAG;AAChB,eAAO;AAAA,MACX;AAIA,UAAI,eAAe,OAAO,KAAK,OAAO,GAAG;AACrC,eAAO;AAAA,MACX;AAEA,YAAM,UAAU,GAAG,YAAY,KAAK,QAAQ,YAAY,CAAC,EAAE,GAAG,EAAE,OAAO;AAAA,QACnE,GAAG,IAAI,QAAQ,IAAI;AAAA,QACnB,GAAG,IAAI,QAAQ,IAAI;AAAA,MACvB,EAAE;AAIF,WAAK,GAAG,YAAY,MAAM,QAAQ,CAAC,WAAW,GAAG,MAAM,eAAe,OAAO,MAAM,KAAK,cAAc,OAAO,MAAM,CAAC,GAAG;AACnH,eAAO;AAAA,MACX;AAIA,WAAK,GAAG,YAAY,MAAM,QAAQ,CAAC,KAAK,UAAU;AAC9C,cAAM,QAAQ,QACR,OAAO,QAAQ,CAAC,IAChB,OAAO,OAAO,SAAS,CAAC;AAC9B,eAAO,oBAAoB,EAAE,OAAO,IAAI,GAAG,MAAM,EAAE,SAAS;AAAA,MAChE,CAAC,GAAG;AACA,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX;AACA,YAAQ,uBAAuB;AAI/B,aAAS,oBAAoB,MAAM,EAAE,KAAK,EAAE,GAAG;AAC3C,YAAM,KAAK,EAAE,GAAG,KAAK,IAAI,IAAI,KAAK,MAAM,GAAG,GAAG,KAAK,IAAI,IAAI,KAAK,MAAM,EAAE;AACxE,YAAM,KAAK,EAAE,GAAG,KAAK,MAAM,IAAI,IAAI,GAAG,GAAG,KAAK,MAAM,IAAI,IAAI,EAAE;AAC9D,YAAM,KAAK,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,KAAK;AACxC,YAAM,KAAK,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,KAAK;AACxC,YAAM,IAAI,KAAK,KAAK,IAAI,KAAK,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,KAAK,IAAI,CAAC;AACvE,UAAI,MAAM,CAAC,GAAG;AAEV,eAAO,CAAC;AAAA,MACZ;AACA,YAAM,MAAM,IAAI,KAAK;AACrB,YAAM,MAAM,IAAI,KAAK;AACrB,YAAM,UAAU,CAAC;AACjB,UAAI,MAAM,KAAK,MAAM,GAAG;AAEpB,gBAAQ,KAAK,EAAE,GAAG,KAAK,MAAM,IAAI,GAAG,IAAI,IAAI,GAAG,KAAK,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC;AAAA,MAC7E;AACA,UAAI,MAAM,KAAK,MAAM,GAAG;AAEpB,gBAAQ,KAAK,EAAE,GAAG,KAAK,MAAM,IAAI,GAAG,IAAI,IAAI,GAAG,KAAK,MAAM,IAAI,GAAG,IAAI,GAAG,CAAC;AAAA,MAC7E;AACA,aAAO;AAAA,IACX;AACA,YAAQ,sBAAsB;AAI9B,aAAS,OAAO,QAAQ,QAAQ,QAAQ;AACpC,YAAM,KAAK,OAAO,IAAI,OAAO,MAAM,OAAO,IAAI,OAAO;AACrD,YAAM,KAAK,OAAO,IAAI,OAAO,MAAM,OAAO,IAAI,OAAO;AACrD,aAAO,IAAI,IAAI,OAAO,UAAU,IAAI,IAAI,OAAO,UAAU,IAAI,KAAK;AAAA,IACtE;AAKA,aAAS,sBAAsB,OAAO,OAAO;AACzC,aAAQ,OAAO,MAAM,OAAO,MAAM,OAAO,MAAM,GAAG,MAC9C,OAAO,MAAM,KAAK,MAAM,OAAO,MAAM,GAAG,KACxC,OAAO,MAAM,OAAO,MAAM,KAAK,MAAM,KAAK,MACtC,OAAO,MAAM,OAAO,MAAM,KAAK,MAAM,GAAG;AAAA,IACpD;AACA,YAAQ,wBAAwB;AAKhC,aAAS,kBAAkB,OAAO,OAAO;AACrC,YAAM,KAAK,MAAM,IAAI,IAAI,MAAM,MAAM;AACrC,YAAM,KAAK,MAAM,IAAI,IAAI,MAAM,MAAM;AACrC,YAAM,cAAc,MAAM,MAAM,IAAI,IAAI,MAAM,MAAM,MAAM,MAAM,IAAI,IAAI,MAAM,MAAM,KAAK;AACzF,UAAI,gBAAgB,GAAG;AACnB,eAAO;AAAA,MACX;AACA,YAAM,WAAW,MAAM,IAAI,IAAI,MAAM,MAAM,MAAM,MAAM,IAAI,IAAI,MAAM,MAAM,MACtE,MAAM,MAAM,IAAI,MAAM,IAAI,MAAM,MAAM,IAAI,IAAI,MAAM,MAAM,MAC3D;AACJ,YAAM,UAAU,MAAM,MAAM,IAAI,MAAM,IAAI,MAAM,MAAM,IAAI,IAAI,MAAM,MAAM,KACtE,MAAM,MAAM,IAAI,IAAI,MAAM,MAAM,MAChC;AAEJ,UAAI,EAAE,UAAU,KAAK,UAAU,MAAM,EAAE,SAAS,KAAK,SAAS,IAAI;AAC9D,eAAO;AAAA,MACX;AACA,aAAO,EAAE,GAAG,MAAM,MAAM,IAAI,SAAS,IAAI,GAAG,MAAM,MAAM,IAAI,SAAS,GAAG;AAAA,IAC5E;AACA,YAAQ,oBAAoB;AAC5B,aAAS,qBAAqB,MAAM,SAAS;AACzC,YAAM,UAAU,CAAC;AACjB,OAAC,GAAG,YAAY,SAAS,QAAQ,YAAY,CAAC,IAAI,UAAU;AACxD,cAAM,OAAO,QACP,QAAQ,WAAW,QAAQ,CAAC,IAC5B,QAAQ,WAAW,QAAQ,WAAW,SAAS,CAAC;AACtD,cAAM,OAAO;AAAA,UACT,OAAO,EAAE,GAAG,KAAK,IAAI,QAAQ,IAAI,GAAG,GAAG,KAAK,IAAI,QAAQ,IAAI,EAAE;AAAA,UAC9D,KAAK,EAAE,GAAG,GAAG,IAAI,QAAQ,IAAI,GAAG,GAAG,GAAG,IAAI,QAAQ,IAAI,EAAE;AAAA,QAC5D;AACA,cAAM,MAAM,kBAAkB,MAAM,IAAI;AACxC,YAAI,KAAK;AACL,kBAAQ,KAAK,GAAG;AAAA,QACpB;AAAA,MACJ,CAAC;AACD,aAAO;AAAA,IACX;AACA,YAAQ,uBAAuB;AAAA;AAAA;;;ACxN/B;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,YAAQ,UAAU,QAAQ,cAAc,QAAQ,aAAa,QAAQ,qBAAqB,QAAQ,mBAAmB,QAAQ,mBAAmB,QAAQ,aAAa,QAAQ,mBAAmB,QAAQ,YAAY,QAAQ,gBAAgB,QAAQ,mBAAmB,QAAQ,YAAY,QAAQ,aAAa,QAAQ,YAAY,QAAQ,WAAW,QAAQ,sBAAsB,QAAQ,oBAAoB,QAAQ,YAAY,QAAQ,gBAAgB,QAAQ,UAAU,QAAQ,UAAU,QAAQ,UAAU,QAAQ,UAAU;AACrgB,QAAM,QAAQ;AACd,QAAM,cAAc;AACpB,QAAM,UAAU;AAChB,QAAM,cAAc;AACpB,YAAQ,UAAU,KAAK,KAAK;AAC5B,YAAQ,UAAU,MAAM,KAAK;AAI7B,aAAS,QAAQ,SAAS;AACtB,aAAO,UAAU,QAAQ;AAAA,IAC7B;AACA,YAAQ,UAAU;AAIlB,aAAS,QAAQ,SAAS;AACtB,aAAO,UAAU,QAAQ;AAAA,IAC7B;AACA,YAAQ,UAAU;AAIlB,aAAS,cAAc,SAAS,UAAU,SAAS,OAAO,GAAG;AACzD,YAAM,QAAQ,KAAK,KAAK,KAAK,MAAM,SAAS,OAAO,IAAI;AACvD,YAAM,SAAS,KAAK,IAAI,GAAG,KAAK,KAAK,QAAQ,KAAK,IAAI,GAAG,IAAI,CAAC,CAAC;AAC/D,aAAO,MAAM,KAAK,EAAE,OAAO,GAAG,CAAC,GAAG,UAAU;AACxC,cAAM,QAAS,QAAQ,SAAU,IAAI,KAAK;AAC1C,cAAM,IAAI,KAAK,IAAI,KAAK,IAAI;AAC5B,cAAM,IAAI,KAAK,IAAI,KAAK,IAAI;AAC5B,eAAO,IAAI,MAAM,OAAO,GAAG,CAAC;AAAA,MAChC,CAAC;AAAA,IACL;AACA,YAAQ,gBAAgB;AAIxB,aAAS,UAAU,OAAO,QAAQ;AAC9B,aAAO;AAAA,QACH,IAAI,MAAM,OAAO,GAAG,CAAC;AAAA,QACrB,IAAI,MAAM,OAAO,OAAO,CAAC;AAAA,QACzB,IAAI,MAAM,OAAO,OAAO,MAAM;AAAA,QAC9B,IAAI,MAAM,OAAO,GAAG,MAAM;AAAA,MAC9B;AAAA,IACJ;AACA,YAAQ,YAAY;AAIpB,aAAS,kBAAkB,QAAQ,CAAC,GAAG;AACnC,aAAO,iBAAiB,MAAM,SACxB,QACA,IAAI,MAAM,OAAO,MAAM,KAAK,GAAG,MAAM,KAAK,CAAC;AAAA,IACrD;AACA,YAAQ,oBAAoB;AAI5B,aAAS,oBAAoB,QAAQ;AACjC,UAAI,CAAC,QAAQ;AACT,cAAM,IAAI,MAAM,0BAA0B;AAAA,MAC9C;AACA,YAAM,iBAAiB,GAAG,YAAY,KAAK,QAAQ,iBAAiB;AACpE,aAAO,UAAU,aAAa,IAAI,cAAc,QAAQ,IAAI;AAAA,IAChE;AACA,YAAQ,sBAAsB;AAI9B,aAAS,SAAS,GAAG,GAAG;AACpB,aAAO,KAAK,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC;AAAA,IAC1C;AACA,YAAQ,WAAW;AAInB,aAAS,UAAU,QAAQ;AACvB,UAAI,MAAM;AACV,eAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACpC,cAAM,KAAK,OAAO,CAAC;AACnB,cAAM,KAAK,QAAQ,IAAI,KAAK,OAAO,MAAM;AACzC,gBAAQ,GAAG,IAAI,GAAG,MAAM,GAAG,IAAI,GAAG;AAAA,MACtC;AACA,aAAO,MAAM;AAAA,IACjB;AACA,YAAQ,YAAY;AAIpB,aAAS,WAAW,MAAM,SAAS;AAC/B,WAAK,WAAW,CAAC,EAAE,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ;AAC7E,WAAK,YAAY,CAAC,EAAE,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ;AAC9E,WAAK,WAAW,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,YAAY;AACtF,UAAI,KAAK,SAAS,QAAQ,SAAS,QAAQ;AACvC,aAAK,cAAc,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,eAAe;AAAA,MAChG;AACA,WAAK,UAAU,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,UAAU,CAAC;AAAA,IACxF;AACA,YAAQ,aAAa;AAIrB,aAAS,UAAU,MAAM;AACrB,aAAQ,KAAK,KAAK,OAAO,KAAK,QAC1B,KAAK,KAAK,OAAO,KAAK,QACtB,KAAK,KAAK,OAAO,KAAK,QACtB,KAAK,KAAK,OAAO,KAAK;AAAA,IAC9B;AACA,YAAQ,YAAY;AAIpB,aAAS,iBAAiB,GAAG,GAAG;AAC5B,aAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE;AAAA,IAChF;AACA,YAAQ,mBAAmB;AAI3B,aAAS,cAAc,GAAG,GAAG;AACzB,aAAO,CAAC,iBAAiB,GAAG,CAAC;AAAA,IACjC;AACA,YAAQ,gBAAgB;AAIxB,aAAS,UAAU,GAAG,GAAG;AACrB,UAAI,EAAE,SAAS,QAAQ,SAAS,QAAQ;AACpC,YAAI,EAAE,SAAS,QAAQ,SAAS,QAAQ;AACpC,kBAAQ,GAAG,YAAY,iBAAiB,GAAG,CAAC;AAAA,QAChD;AACA,gBAAQ,GAAG,YAAY,gBAAgB,GAAG,CAAC;AAAA,MAC/C;AACA,UAAI,EAAE,SAAS,QAAQ,SAAS,QAAQ;AACpC,gBAAQ,GAAG,YAAY,iBAAiB,GAAG,CAAC;AAAA,MAChD;AACA,cAAQ,GAAG,YAAY,kBAAkB,GAAG,CAAC;AAAA,IACjD;AACA,YAAQ,YAAY;AAIpB,aAAS,iBAAiB,QAAQ;AAC9B,cAAQ,GAAG,YAAY,KAAK,QAAQ,CAAC,EAAE,GAAG,EAAE,OAAO;AAAA,QAC/C;AAAA,QACA;AAAA,MACJ,EAAE;AAAA,IACN;AACA,YAAQ,mBAAmB;AAI3B,aAAS,WAAW,SAAS,OAAO,OAAO,KAAK,KAAK,OAAO,GAAG,MAAM,GAAG;AACpE,YAAM,QAAQ,MAAM;AACpB,YAAM,QAAQ,MAAM;AACpB,YAAM,MAAM,KAAK,MAAM,OAAO,KAAK;AACnC,YAAM,UAAU,KAAK,IAAI,GAAG;AAC5B,YAAM,UAAU,KAAK,IAAI,GAAG;AAC5B,UAAI,OAAO;AACX,UAAI,OAAO;AACX,UAAI,OAAO,KAAK,MAAM,OAAO,KAAK;AAClC,aAAO,OAAO,GAAG;AACb,cAAM,OAAO,KAAK,IAAI,MAAM,IAAI;AAChC,gBAAQ,OAAO,MAAM,IAAI;AACzB,gBAAQ,OAAO,OAAO,UAAU,MAAM,OAAO,UAAU,IAAI;AAC3D,gBAAQ,WAAW,OAAO;AAC1B,gBAAQ,WAAW,OAAO;AAC1B,gBAAQ,OAAO;AAAA,MACnB;AAAA,IACJ;AACA,YAAQ,aAAa;AAIrB,aAAS,iBAAiB,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG;AACjD,aAAO,CAAC,GAAG,CAAC;AAAA,IAChB;AACA,YAAQ,mBAAmB;AAI3B,aAAS,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG;AACvC,aAAO,EAAE,GAAG,EAAE;AAAA,IAClB;AACA,YAAQ,mBAAmB;AAI3B,aAAS,mBAAmB,MAAM,UAAU;AACxC,YAAM,KAAK,IAAI,MAAM,OAAO,SAAS,IAAI,KAAK,GAAG,SAAS,IAAI,KAAK,CAAC;AACpE,YAAM,KAAK,IAAI,MAAM,OAAO,KAAK,IAAI,SAAS,GAAG,KAAK,IAAI,SAAS,CAAC;AACpE,YAAM,MAAM,GAAG,IAAI,GAAG,UAAU,CAAC,IAAI;AACrC,aAAO,IAAI,MAAM,OAAO,GAAG,IAAI,MAAM,GAAG,GAAG,GAAG,IAAI,MAAM,GAAG,CAAC,EAAE,UAAU;AAAA,IAC5E;AACA,YAAQ,qBAAqB;AAI7B,aAAS,WAAW,MAAM,MAAM;AAC5B,UAAI,KAAK,SAAS,QAAQ,SAAS,QAAQ;AACvC,eAAO,KAAK,SAAS,QAAQ,SAAS,SAAS,MAAM,mBAAmB,MAAM;AAAA,MAClF;AACA,aAAO,KAAK,SAAS,QAAQ,SAAS,SAAS,MAAM,oBAAoB,MAAM;AAAA,IACnF;AACA,YAAQ,aAAa;AAIrB,aAAS,YAAY,SAAS,EAAE,KAAK,WAAY,GAAG,YAAY,OAAO;AACnE,YAAM,YAAY,WAAW,WAAW,SAAS,CAAC;AAClD,YAAM,QAAQ,IAAI,IAAI,UAAU;AAChC,YAAM,QAAQ,IAAI,IAAI,UAAU;AAChC,UAAI,WAAW,WAAW,GAAG;AACzB,gBAAQ,IAAI,OAAO,OAAO,GAAG,GAAG,KAAK,KAAK,CAAC;AAAA,MAC/C,OACK;AACD,gBAAQ,OAAO,OAAO,KAAK;AAAA,MAC/B;AACA,OAAC,GAAG,YAAY,SAAS,YAAY,CAAC,OAAO,UAAU;AACnD,cAAM,MAAM,IAAI,IAAI,MAAM;AAC1B,cAAM,MAAM,IAAI,IAAI,MAAM;AAC1B,YAAI,WAAW;AACX,gBAAM,OAAO,WAAW,QAAQ,CAAC,KAAK;AACtC,qBAAW,SAAS,IAAI,IAAI,KAAK,GAAG,IAAI,IAAI,KAAK,GAAG,KAAK,GAAG;AAAA,QAChE,OACK;AACD,kBAAQ,OAAO,KAAK,GAAG;AAAA,QAC3B;AAAA,MACJ,CAAC;AAAA,IACL;AACA,YAAQ,cAAc;AAItB,aAAS,QAAQ,SAAS,MAAM;AAC5B,kBAAY,SAAS;AAAA,QACjB,KAAK,EAAE,GAAG,KAAK,MAAM,GAAG,KAAK,KAAK;AAAA,QAClC,YAAY,UAAU,KAAK,OAAO,KAAK,MAAM,KAAK,OAAO,KAAK,IAAI;AAAA,MACtE,CAAC;AAAA,IACL;AACA,YAAQ,UAAU;AAAA;AAAA;;;ACnPlB;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,YAAQ,SAAS;AACjB,QAAM,QAAQ;AACd,QAAM,UAAU;AAChB,QAAM,UAAU;AAIhB,QAAM,SAAN,cAAqB,MAAM,OAAO;AAAA;AAAA;AAAA;AAAA,MAI9B,YAAY,UAAU,QAAQ,SAAS;AACnC,eAAO,GAAG,QAAQ,mBAAmB,QAAQ,GAAG,MAAM;AAItD,aAAK,aAAa,EAAE,GAAG,GAAG,GAAG,EAAE;AAI/B,aAAK,QAAQ;AAIb,aAAK,WAAW;AAIhB,aAAK,OAAO,QAAQ,SAAS;AAI7B,aAAK,aAAa;AAClB,SAAC,GAAG,QAAQ,YAAY,MAAM,OAAO;AACrC,aAAK,iBAAiB;AAAA,MAC1B;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,IAAI;AACJ,eAAO,KAAK,IAAI;AAAA,MACpB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,EAAE,GAAG;AACL,aAAK,IAAI,IAAI;AACb,aAAK,QAAQ;AAAA,MACjB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,IAAI;AACJ,eAAO,KAAK,IAAI;AAAA,MACpB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,EAAE,GAAG;AACL,aAAK,IAAI,IAAI;AACb,aAAK,QAAQ;AAAA,MACjB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,QAAQ;AACR,eAAO,KAAK,IAAI,KAAK;AAAA,MACzB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,MAAM,OAAO;AACb,aAAK,SAAS,KAAK;AAAA,MACvB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,SAAS;AACT,eAAO,KAAK;AAAA,MAChB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,SAAS;AACT,eAAO,KAAK;AAAA,MAChB;AAAA;AAAA;AAAA;AAAA,MAIA,YAAY,GAAG,GAAG,SAAS,MAAM;AAC7B,aAAK,IAAI,IAAI;AACb,aAAK,IAAI,IAAI;AACb,aAAK,QAAQ;AACb,YAAI,QAAQ;AACR,eAAK,WAAW;AAAA,QACpB;AACA,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,SAAS,QAAQ,UAAU,QAAQ,SAAS,MAAM;AAC9C,aAAK,IAAI,KAAK,iBAAiB,KAAK,IAAI,MAAM;AAC9C,aAAK,QAAQ;AACb,YAAI,QAAQ;AACR,eAAK,WAAW;AAAA,QACpB;AACA,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,SAAS,OAAO,SAAS,MAAM;AAC3B,aAAK,QAAQ;AACb,cAAM,EAAE,GAAG,EAAE,IAAI,KAAK,mBAAmB;AACzC,aAAK,OAAO,IAAI;AAChB,aAAK,OAAO,IAAI;AAChB,aAAK,QAAQ;AACb,YAAI,QAAQ;AACR,eAAK,WAAW;AAAA,QACpB;AACA,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,UAAU,QAAQ,SAAS,MAAM;AAC7B,aAAK,WAAW,IAAI,OAAO;AAC3B,aAAK,WAAW,IAAI,OAAO;AAC3B,cAAM,EAAE,GAAG,EAAE,IAAI,KAAK,mBAAmB;AACzC,aAAK,OAAO,IAAI;AAChB,aAAK,OAAO,IAAI;AAChB,aAAK,QAAQ;AACb,YAAI,QAAQ;AACR,eAAK,WAAW;AAAA,QACpB;AACA,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,gBAAgB;AACZ,cAAM,IAAI,KAAK,IAAI,IAAI,KAAK,OAAO;AACnC,cAAM,IAAI,KAAK,IAAI,IAAI,KAAK,OAAO;AACnC,eAAO;AAAA,UACH,MAAM,IAAI,KAAK;AAAA,UACf,MAAM,IAAI,KAAK;AAAA,UACf,MAAM,IAAI,KAAK;AAAA,UACf,MAAM,IAAI,KAAK;AAAA,QACnB;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA,MAIA,KAAK,SAAS;AACV,cAAM,IAAI,KAAK,IAAI,IAAI,KAAK,OAAO;AACnC,cAAM,IAAI,KAAK,IAAI,IAAI,KAAK,OAAO;AACnC,cAAM,IAAI,KAAK,IAAI,KAAK,CAAC;AACzB,YAAI,KAAK,WAAW;AAChB,gBAAM,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC;AAC9B,mBAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC1B,kBAAM,MAAO,IAAI,MAAO,IAAI,KAAK;AACjC,kBAAM,WAAY,IAAI,KAAK,MAAO,IAAI,KAAK;AAC3C,kBAAM,QAAQ,IAAI,KAAK,IAAI,OAAO,IAAI,KAAK;AAC3C,kBAAM,QAAQ,IAAI,KAAK,IAAI,OAAO,IAAI,KAAK;AAC3C,kBAAM,MAAM,IAAI,KAAK,IAAI,GAAG,IAAI,KAAK;AACrC,kBAAM,MAAM,IAAI,KAAK,IAAI,GAAG,IAAI,KAAK;AACrC,aAAC,GAAG,QAAQ,YAAY,SAAS,OAAO,OAAO,KAAK,GAAG;AAAA,UAC3D;AAAA,QACJ,OACK;AACD,kBAAQ,OAAO,IAAI,GAAG,CAAC;AACvB,kBAAQ,IAAI,GAAG,GAAG,GAAG,GAAG,KAAK,KAAK,CAAC;AAAA,QACvC;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA,MAIA,QAAQ,SAAS;AACb,SAAC,GAAG,QAAQ,SAAS,SAAS,IAAI;AAAA,MACtC;AAAA;AAAA;AAAA;AAAA,MAIA,WAAW,SAAS,KAAK,OAAO;AAC5B,YAAI;AACJ,YAAI,QAAQ;AACR,WAAC,KAAK,KAAK,YAAY,QAAQ,OAAO,SAAS,SAAS,GAAG,OAAO,IAAI;AACtE,eAAK,QAAQ;AAAA,QACjB;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA,MAIA,YAAY,QAAQ;AAChB,YAAI,QAAQ;AACR,eAAK,WAAW,IAAI;AAAA,QACxB,OACK;AACD,eAAK,QAAQ;AAAA,QACjB;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA,MAIA,qBAAqB;AACjB,YAAK,CAAC,KAAK,WAAW,KAAK,CAAC,KAAK,WAAW,KAAM,CAAC,KAAK,OAAO;AAC3D,iBAAO,KAAK;AAAA,QAChB;AACA,cAAM,MAAM,KAAK,IAAI,KAAK,KAAK;AAC/B,cAAM,MAAM,KAAK,IAAI,KAAK,KAAK;AAC/B,cAAM,IAAI,KAAK,WAAW,IAAI,MAAM,KAAK,WAAW,IAAI;AACxD,cAAM,IAAI,KAAK,WAAW,IAAI,MAAM,KAAK,WAAW,IAAI;AACxD,eAAO,EAAE,GAAG,EAAE;AAAA,MAClB;AAAA,IACJ;AACA,YAAQ,SAAS;AAAA;AAAA;;;AC1NjB;AAAA;AAAA,WAAO,UAAU;AAAA,MACb,QAAQ;AAAA,MACR,aAAa;AAAA,MACb,UAAU;AAAA,MACV,uBAAuB;AAAA,MACvB,uBAAuB;AAAA,MACvB,SAAS;AAAA,IACb;AAWA,aAAS,QAAQ,IAAG,IAAG,WAAU;AAC7B,kBAAY,aAAa;AACzB,UAAI,IAAI,CAAC,GAAE,CAAC;AACZ,UAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAC5B,WAAK,GAAG,CAAC,EAAE,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC;AACvB,WAAK,GAAG,CAAC,EAAE,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC;AACvB,WAAK,KAAK,GAAG,CAAC,EAAE,CAAC,IAAI,KAAK,GAAG,CAAC,EAAE,CAAC;AACjC,WAAK,GAAG,CAAC,EAAE,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC;AACvB,WAAK,GAAG,CAAC,EAAE,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC;AACvB,WAAK,KAAK,GAAG,CAAC,EAAE,CAAC,IAAI,KAAK,GAAG,CAAC,EAAE,CAAC;AACjC,YAAM,KAAK,KAAK,KAAG;AACnB,UAAI,CAAC,UAAU,KAAK,GAAG,SAAS,GAAG;AAC/B,UAAE,CAAC,KAAK,KAAK,KAAK,KAAK,MAAM;AAC7B,UAAE,CAAC,KAAK,KAAK,KAAK,KAAK,MAAM;AAAA,MACjC;AACA,aAAO;AAAA,IACX;AAWA,aAAS,sBAAsB,IAAI,IAAI,IAAI,IAAG;AAC7C,UAAI,KAAK,GAAG,CAAC,IAAI,GAAG,CAAC;AACrB,UAAI,KAAK,GAAG,CAAC,IAAI,GAAG,CAAC;AACrB,UAAI,KAAK,GAAG,CAAC,IAAI,GAAG,CAAC;AACrB,UAAI,KAAK,GAAG,CAAC,IAAI,GAAG,CAAC;AAGrB,UAAI,KAAG,KAAK,KAAG,OAAQ,GAAE;AACxB,eAAO;AAAA,MACR;AAEA,UAAI,KAAK,MAAM,GAAG,CAAC,IAAI,GAAG,CAAC,KAAK,MAAM,GAAG,CAAC,IAAI,GAAG,CAAC,OAAO,KAAK,KAAK,KAAK;AACxE,UAAI,KAAK,MAAM,GAAG,CAAC,IAAI,GAAG,CAAC,KAAK,MAAM,GAAG,CAAC,IAAI,GAAG,CAAC,OAAO,KAAK,KAAK,KAAK;AAExE,aAAQ,KAAG,KAAK,KAAG,KAAK,KAAG,KAAK,KAAG;AAAA,IACpC;AAWA,aAAS,aAAa,GAAE,GAAE,GAAE;AACxB,cAAU,EAAE,CAAC,IAAI,EAAE,CAAC,MAAI,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,MAAI,EAAE,CAAC,IAAI,EAAE,CAAC;AAAA,IACpE;AAEA,aAAS,OAAO,GAAE,GAAE,GAAE;AAClB,aAAO,aAAa,GAAE,GAAE,CAAC,IAAI;AAAA,IACjC;AAEA,aAAS,SAAS,GAAE,GAAE,GAAG;AACrB,aAAO,aAAa,GAAG,GAAG,CAAC,KAAK;AAAA,IACpC;AAEA,aAAS,QAAQ,GAAE,GAAE,GAAG;AACpB,aAAO,aAAa,GAAG,GAAG,CAAC,IAAI;AAAA,IACnC;AAEA,aAAS,UAAU,GAAE,GAAE,GAAG;AACtB,aAAO,aAAa,GAAG,GAAG,CAAC,KAAK;AAAA,IACpC;AAEA,QAAI,YAAY,CAAC;AAAjB,QACI,YAAY,CAAC;AAWjB,aAAS,UAAU,GAAE,GAAE,GAAE,gBAAgB;AACrC,UAAG,CAAC,gBAAe;AACf,eAAO,aAAa,GAAG,GAAG,CAAC,MAAM;AAAA,MACrC,OAAO;AACH,YAAI,KAAK,WACL,KAAK;AAET,WAAG,CAAC,IAAI,EAAE,CAAC,IAAE,EAAE,CAAC;AAChB,WAAG,CAAC,IAAI,EAAE,CAAC,IAAE,EAAE,CAAC;AAChB,WAAG,CAAC,IAAI,EAAE,CAAC,IAAE,EAAE,CAAC;AAChB,WAAG,CAAC,IAAI,EAAE,CAAC,IAAE,EAAE,CAAC;AAEhB,YAAI,MAAM,GAAG,CAAC,IAAE,GAAG,CAAC,IAAI,GAAG,CAAC,IAAE,GAAG,CAAC,GAC9B,OAAO,KAAK,KAAK,GAAG,CAAC,IAAE,GAAG,CAAC,IAAI,GAAG,CAAC,IAAE,GAAG,CAAC,CAAC,GAC1C,OAAO,KAAK,KAAK,GAAG,CAAC,IAAE,GAAG,CAAC,IAAI,GAAG,CAAC,IAAE,GAAG,CAAC,CAAC,GAC1C,QAAQ,KAAK,KAAK,OAAK,OAAK,KAAK;AACrC,eAAO,QAAQ;AAAA,MACnB;AAAA,IACJ;AAEA,aAAS,OAAO,GAAE,GAAE;AAChB,UAAI,KAAK,EAAE,CAAC,IAAI,EAAE,CAAC;AACnB,UAAI,KAAK,EAAE,CAAC,IAAI,EAAE,CAAC;AACnB,aAAO,KAAK,KAAK,KAAK;AAAA,IAC1B;AAQA,aAAS,UAAU,SAAS,GAAE;AAC1B,UAAI,IAAI,QAAQ;AAChB,aAAO,QAAQ,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC;AAAA,IAC5C;AAOA,aAAS,aAAa,SAAQ;AAC1B,cAAQ,SAAS;AAAA,IACrB;AAUA,aAAS,cAAc,SAAS,MAAM,MAAM,IAAG;AAC3C,eAAQ,IAAE,MAAM,IAAE,IAAI,KAAI;AACtB,gBAAQ,KAAK,KAAK,CAAC,CAAC;AAAA,MACxB;AAAA,IACJ;AAMA,aAAS,eAAe,SAAQ;AAC5B,UAAI,KAAK,GACL,IAAI;AAGR,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACrC,YAAI,EAAE,CAAC,EAAE,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,KAAM,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,EAAE,EAAE,CAAC,KAAK,EAAE,CAAC,EAAE,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,GAAI;AACpE,eAAK;AAAA,QACT;AAAA,MACJ;AAGA,UAAI,CAAC,OAAO,UAAU,SAAS,KAAK,CAAC,GAAG,UAAU,SAAS,EAAE,GAAG,UAAU,SAAS,KAAK,CAAC,CAAC,GAAG;AACzF,uBAAe,OAAO;AACtB,eAAO;AAAA,MACX,OAAO;AACH,eAAO;AAAA,MACX;AAAA,IACJ;AAMA,aAAS,eAAe,SAAQ;AAC5B,UAAI,MAAM,CAAC;AACX,UAAI,IAAI,QAAQ;AAChB,eAAQ,IAAE,GAAG,MAAI,GAAG,KAAI;AACpB,YAAI,KAAK,QAAQ,IAAI,CAAC;AAAA,MAC1B;AACA,eAAQ,IAAE,GAAG,MAAI,GAAG,KAAI;AAC1B,gBAAQ,CAAC,IAAI,IAAI,CAAC;AAAA,MAChB;AAAA,IACJ;AAQA,aAAS,gBAAgB,SAAS,GAAE;AAChC,aAAO,QAAQ,UAAU,SAAS,IAAI,CAAC,GAAG,UAAU,SAAS,CAAC,GAAG,UAAU,SAAS,IAAI,CAAC,CAAC;AAAA,IAC9F;AAEA,QAAI,WAAS,CAAC;AAAd,QACI,WAAS,CAAC;AASd,aAAS,cAAc,SAAS,GAAE,GAAG;AACjC,UAAI,GAAG,MAAM,KAAG,UAAU,KAAG;AAE7B,UAAI,SAAS,UAAU,SAAS,IAAI,CAAC,GAAG,UAAU,SAAS,CAAC,GAAG,UAAU,SAAS,CAAC,CAAC,KAAK,UAAU,UAAU,SAAS,IAAI,CAAC,GAAG,UAAU,SAAS,CAAC,GAAG,UAAU,SAAS,CAAC,CAAC,GAAG;AACzK,eAAO;AAAA,MACX;AACA,aAAO,OAAO,UAAU,SAAS,CAAC,GAAG,UAAU,SAAS,CAAC,CAAC;AAC1D,eAAS,IAAI,GAAG,MAAM,QAAQ,QAAQ,EAAE,GAAG;AACvC,aAAK,IAAI,KAAK,QAAQ,WAAW,KAAK,MAAM,GAAE;AAC1C;AAAA,QACJ;AACA,YAAI,SAAS,UAAU,SAAS,CAAC,GAAG,UAAU,SAAS,CAAC,GAAG,UAAU,SAAS,IAAI,CAAC,CAAC,KAAK,UAAU,UAAU,SAAS,CAAC,GAAG,UAAU,SAAS,CAAC,GAAG,UAAU,SAAS,CAAC,CAAC,GAAG;AACrK,aAAG,CAAC,IAAI,UAAU,SAAS,CAAC;AAC5B,aAAG,CAAC,IAAI,UAAU,SAAS,CAAC;AAC5B,aAAG,CAAC,IAAI,UAAU,SAAS,CAAC;AAC5B,aAAG,CAAC,IAAI,UAAU,SAAS,IAAI,CAAC;AAChC,cAAI,QAAQ,IAAG,EAAE;AACjB,cAAI,OAAO,UAAU,SAAS,CAAC,GAAG,CAAC,IAAI,MAAM;AACzC,mBAAO;AAAA,UACX;AAAA,QACJ;AAAA,MACJ;AAEA,aAAO;AAAA,IACX;AASA,aAAS,eAAe,SAAS,GAAE,GAAG;AAElC,eAAS,IAAI,GAAG,MAAM,QAAQ,QAAQ,EAAE,GAAG;AAEvC,YAAI,MAAM,KAAK,MAAM,MAAM,IAAI,KAAK,QAAQ,WAAW,MAAM,IAAI,KAAK,QAAQ,WAAW,GAAE;AACvF;AAAA,QACJ;AACA,YAAI,sBAAsB,UAAU,SAAS,CAAC,GAAG,UAAU,SAAS,CAAC,GAAG,UAAU,SAAS,CAAC,GAAG,UAAU,SAAS,IAAE,CAAC,CAAC,GAAG;AACrH,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAUA,aAAS,YAAY,SAAS,GAAE,GAAE,YAAW;AACzC,UAAI,IAAI,cAAc,CAAC;AACvB,mBAAa,CAAC;AACd,UAAI,IAAI,GAAG;AAEP,iBAAQ,IAAE,GAAG,KAAG,GAAG,KAAI;AACnB,YAAE,KAAK,QAAQ,CAAC,CAAC;AAAA,QACrB;AAAA,MAEJ,OAAO;AAGH,iBAAQ,IAAE,GAAG,KAAG,GAAG,KAAI;AACnB,YAAE,KAAK,QAAQ,CAAC,CAAC;AAAA,QACrB;AAGA,iBAAQ,IAAE,GAAG,IAAE,QAAQ,QAAQ,KAAI;AAC/B,YAAE,KAAK,QAAQ,CAAC,CAAC;AAAA,QACrB;AAAA,MACJ;AAEA,aAAO;AAAA,IACX;AAQA,aAAS,mBAAmB,SAAS;AACjC,UAAI,MAAI,CAAC,GAAG,OAAK,CAAC,GAAG,OAAK,CAAC,GAAG,UAAU,CAAC;AACzC,UAAI,SAAS,OAAO;AAEpB,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACrC,YAAI,gBAAgB,SAAS,CAAC,GAAG;AAC7B,mBAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACrC,gBAAI,cAAc,SAAS,GAAG,CAAC,GAAG;AAC9B,qBAAO,mBAAmB,YAAY,SAAS,GAAG,GAAG,OAAO,CAAC;AAC7D,qBAAO,mBAAmB,YAAY,SAAS,GAAG,GAAG,OAAO,CAAC;AAE7D,uBAAQ,IAAE,GAAG,IAAE,KAAK,QAAQ,KAAI;AAC5B,qBAAK,KAAK,KAAK,CAAC,CAAC;AAAA,cACrB;AAEA,kBAAI,KAAK,SAAS,QAAQ;AACtB,sBAAM;AACN,yBAAS,KAAK;AACd,oBAAI,KAAK,CAAC,UAAU,SAAS,CAAC,GAAG,UAAU,SAAS,CAAC,CAAC,CAAC;AAAA,cAC3D;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAEA,aAAO;AAAA,IACX;AAOA,aAAS,cAAc,SAAQ;AAC3B,UAAI,QAAQ,mBAAmB,OAAO;AACtC,UAAG,MAAM,SAAS,GAAE;AAChB,eAAO,aAAa,SAAS,KAAK;AAAA,MACtC,OAAO;AACH,eAAO,CAAC,OAAO;AAAA,MACnB;AAAA,IACJ;AAQA,aAAS,aAAa,SAAS,UAAS;AACpC,UAAG,SAAS,WAAW,GAAE;AAC3B,eAAO,CAAC,OAAO;AAAA,MACb;AACA,UAAG,oBAAoB,SAAS,SAAS,UAAU,SAAS,CAAC,aAAa,SAAS,SAAS,CAAC,EAAE,WAAS,KAAK,SAAS,CAAC,EAAE,CAAC,aAAa,OAAM;AAEzI,YAAI,QAAQ,CAAC,OAAO;AAEpB,iBAAQ,IAAE,GAAG,IAAE,SAAS,QAAQ,KAAI;AAChC,cAAI,UAAU,SAAS,CAAC;AAExB,mBAAQ,IAAE,GAAG,IAAE,MAAM,QAAQ,KAAI;AAC7B,gBAAI,OAAO,MAAM,CAAC;AAClB,gBAAI,SAAS,aAAa,MAAM,OAAO;AACvC,gBAAG,QAAO;AAEN,oBAAM,OAAO,GAAE,CAAC;AAChB,oBAAM,KAAK,OAAO,CAAC,GAAE,OAAO,CAAC,CAAC;AAC9B;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ;AAEA,eAAO;AAAA,MACX,OAAO;AAGH,YAAI,UAAU;AACd,YAAI,IAAI,QAAQ,QAAQ,QAAQ,CAAC,CAAC;AAClC,YAAI,IAAI,QAAQ,QAAQ,QAAQ,CAAC,CAAC;AAElC,YAAG,MAAM,MAAM,MAAM,IAAG;AACpB,iBAAO;AAAA,YAAC,YAAY,SAAS,GAAE,CAAC;AAAA,YACxB,YAAY,SAAS,GAAE,CAAC;AAAA,UAAC;AAAA,QACrC,OAAO;AACH,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ;AASA,aAAS,gBAAgB,SAAQ;AAC7B,UAAI,OAAO,SAAS;AAEpB,WAAI,IAAE,GAAG,IAAE,KAAK,SAAO,GAAG,KAAI;AAC1B,iBAAQ,IAAE,GAAG,IAAE,IAAE,GAAG,KAAI;AACpB,cAAG,sBAAsB,KAAK,CAAC,GAAG,KAAK,IAAE,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,IAAE,CAAC,CAAE,GAAE;AAC9D,mBAAO;AAAA,UACX;AAAA,QACJ;AAAA,MACJ;AAGA,WAAI,IAAE,GAAG,IAAE,KAAK,SAAO,GAAG,KAAI;AAC1B,YAAG,sBAAsB,KAAK,CAAC,GAAG,KAAK,KAAK,SAAO,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,IAAE,CAAC,CAAE,GAAE;AACxE,iBAAO;AAAA,QACX;AAAA,MACJ;AAEA,aAAO;AAAA,IACX;AAEA,aAAS,qBAAqB,IAAI,IAAI,IAAI,IAAI,OAAM;AACnD,cAAQ,SAAS;AACjB,UAAI,KAAK,GAAG,CAAC,IAAI,GAAG,CAAC;AACrB,UAAI,KAAK,GAAG,CAAC,IAAI,GAAG,CAAC;AACrB,UAAI,KAAM,KAAK,GAAG,CAAC,IAAM,KAAK,GAAG,CAAC;AAClC,UAAI,KAAK,GAAG,CAAC,IAAI,GAAG,CAAC;AACrB,UAAI,KAAK,GAAG,CAAC,IAAI,GAAG,CAAC;AACrB,UAAI,KAAM,KAAK,GAAG,CAAC,IAAM,KAAK,GAAG,CAAC;AAClC,UAAI,MAAO,KAAK,KAAO,KAAK;AAE5B,UAAG,CAAC,UAAU,KAAI,GAAE,KAAK,GAAE;AAC1B,eAAO,EAAG,KAAK,KAAO,KAAK,MAAO,MAAO,KAAK,KAAO,KAAK,MAAO,GAAG;AAAA,MACrE,OAAO;AACN,eAAO,CAAC,GAAE,CAAC;AAAA,MACT;AAAA,IACJ;AAaA,aAAS,mBAAmB,SAAS,QAAO,gBAAe,eAAc,OAAM,UAAS,OAAM;AAC1F,iBAAW,YAAY;AACvB,cAAQ,SAAS;AACjB,cAAQ,SAAS;AACjB,eAAS,OAAO,WAAU,cAAc,SAAS,CAAC;AAClD,uBAAiB,kBAAkB,CAAC;AACpC,sBAAgB,iBAAiB,CAAC;AAElC,UAAI,WAAS,CAAC,GAAE,CAAC,GAAG,WAAS,CAAC,GAAE,CAAC,GAAG,IAAE,CAAC,GAAE,CAAC;AAC1C,UAAI,YAAU,GAAG,YAAU,GAAG,IAAE,GAAG,cAAY;AAC/C,UAAI,aAAW,GAAG,aAAW,GAAG,eAAa;AAC7C,UAAI,YAAU,CAAC,GAAG,YAAU,CAAC;AAC7B,UAAI,OAAO,SACP,IAAI;AAER,UAAG,EAAE,SAAS,GAAE;AAClB,eAAO;AAAA,MACL;AAEA;AACA,UAAG,QAAQ,UAAS;AAChB,gBAAQ,KAAK,6BAA2B,WAAS,YAAY;AAC7D,eAAO;AAAA,MACX;AAEA,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACrC,YAAI,gBAAgB,MAAM,CAAC,GAAG;AAC1B,yBAAe,KAAK,KAAK,CAAC,CAAC;AAC3B,sBAAY,YAAY,OAAO;AAG/B,mBAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACrC,gBAAI,OAAO,UAAU,MAAM,IAAI,CAAC,GAAG,UAAU,MAAM,CAAC,GAAG,UAAU,MAAM,CAAC,CAAC,KAAK,UAAU,UAAU,MAAM,IAAI,CAAC,GAAG,UAAU,MAAM,CAAC,GAAG,UAAU,MAAM,IAAI,CAAC,CAAC,GAAG;AACzJ,kBAAI,qBAAqB,UAAU,MAAM,IAAI,CAAC,GAAG,UAAU,MAAM,CAAC,GAAG,UAAU,MAAM,CAAC,GAAG,UAAU,MAAM,IAAI,CAAC,CAAC;AAC/G,kBAAI,QAAQ,UAAU,MAAM,IAAI,CAAC,GAAG,UAAU,MAAM,CAAC,GAAG,CAAC,GAAG;AACxD,oBAAI,OAAO,KAAK,CAAC,GAAG,CAAC;AACrB,oBAAI,IAAI,WAAW;AACf,8BAAY;AACZ,6BAAW;AACX,+BAAa;AAAA,gBACjB;AAAA,cACJ;AAAA,YACJ;AACA,gBAAI,OAAO,UAAU,MAAM,IAAI,CAAC,GAAG,UAAU,MAAM,CAAC,GAAG,UAAU,MAAM,IAAI,CAAC,CAAC,KAAK,UAAU,UAAU,MAAM,IAAI,CAAC,GAAG,UAAU,MAAM,CAAC,GAAG,UAAU,MAAM,CAAC,CAAC,GAAG;AACzJ,kBAAI,qBAAqB,UAAU,MAAM,IAAI,CAAC,GAAG,UAAU,MAAM,CAAC,GAAG,UAAU,MAAM,CAAC,GAAG,UAAU,MAAM,IAAI,CAAC,CAAC;AAC/G,kBAAI,OAAO,UAAU,MAAM,IAAI,CAAC,GAAG,UAAU,MAAM,CAAC,GAAG,CAAC,GAAG;AACvD,oBAAI,OAAO,KAAK,CAAC,GAAG,CAAC;AACrB,oBAAI,IAAI,WAAW;AACf,8BAAY;AACZ,6BAAW;AACX,+BAAa;AAAA,gBACjB;AAAA,cACJ;AAAA,YACJ;AAAA,UACJ;AAGA,cAAI,gBAAgB,aAAa,KAAK,QAAQ,QAAQ;AAElD,cAAE,CAAC,KAAK,SAAS,CAAC,IAAI,SAAS,CAAC,KAAK;AACrC,cAAE,CAAC,KAAK,SAAS,CAAC,IAAI,SAAS,CAAC,KAAK;AACrC,0BAAc,KAAK,CAAC;AAEpB,gBAAI,IAAI,YAAY;AAEhB,4BAAc,WAAW,MAAM,GAAG,aAAW,CAAC;AAC9C,wBAAU,KAAK,CAAC;AAChB,wBAAU,KAAK,CAAC;AAChB,kBAAI,eAAe,GAAE;AAEjB,8BAAc,WAAW,MAAK,YAAW,KAAK,MAAM;AAAA,cACxD;AAEA,4BAAc,WAAW,MAAK,GAAE,IAAE,CAAC;AAAA,YACvC,OAAO;AACH,kBAAI,MAAM,GAAE;AAER,8BAAc,WAAW,MAAK,GAAE,KAAK,MAAM;AAAA,cAC/C;AAEA,4BAAc,WAAW,MAAK,GAAE,aAAW,CAAC;AAC5C,wBAAU,KAAK,CAAC;AAChB,wBAAU,KAAK,CAAC;AAEhB,4BAAc,WAAW,MAAK,YAAW,IAAE,CAAC;AAAA,YAChD;AAAA,UACJ,OAAO;AAIH,gBAAI,aAAa,YAAY;AACzB,4BAAc,QAAQ;AAAA,YAC1B;AACA,0BAAc,OAAO;AAErB,gBAAG,aAAa,YAAW;AACvB,qBAAO;AAAA,YACX;AAEA,qBAAS,IAAI,YAAY,KAAK,YAAY,EAAE,GAAG;AAC3C,kBACI,SAAS,UAAU,MAAM,IAAI,CAAC,GAAG,UAAU,MAAM,CAAC,GAAG,UAAU,MAAM,CAAC,CAAC,KACvE,UAAU,UAAU,MAAM,IAAI,CAAC,GAAG,UAAU,MAAM,CAAC,GAAG,UAAU,MAAM,CAAC,CAAC,GAC1E;AACE,oBAAI,OAAO,UAAU,MAAM,CAAC,GAAG,UAAU,MAAM,CAAC,CAAC;AACjD,oBAAI,IAAI,eAAe,eAAe,MAAM,GAAG,CAAC,GAAG;AAC/C,gCAAc;AACd,iCAAe,IAAI,QAAQ;AAAA,gBAC/B;AAAA,cACJ;AAAA,YACJ;AAEA,gBAAI,IAAI,cAAc;AAClB,4BAAc,WAAW,MAAK,GAAE,eAAa,CAAC;AAC9C,kBAAI,iBAAiB,GAAE;AACnB,8BAAc,WAAW,MAAK,cAAa,EAAE,MAAM;AAAA,cACvD;AACA,4BAAc,WAAW,MAAK,GAAE,IAAE,CAAC;AAAA,YACvC,OAAO;AACH,kBAAI,MAAM,GAAE;AACR,8BAAc,WAAW,MAAK,GAAE,EAAE,MAAM;AAAA,cAC5C;AACA,4BAAc,WAAW,MAAK,GAAE,eAAa,CAAC;AAC9C,4BAAc,WAAW,MAAK,cAAa,IAAE,CAAC;AAAA,YAClD;AAAA,UACJ;AAGA,cAAI,UAAU,SAAS,UAAU,QAAQ;AACrC,+BAAmB,WAAU,QAAO,gBAAe,eAAc,OAAM,UAAS,KAAK;AACrF,+BAAmB,WAAU,QAAO,gBAAe,eAAc,OAAM,UAAS,KAAK;AAAA,UACzF,OAAO;AACH,+BAAmB,WAAU,QAAO,gBAAe,eAAc,OAAM,UAAS,KAAK;AACrF,+BAAmB,WAAU,QAAO,gBAAe,eAAc,OAAM,UAAS,KAAK;AAAA,UACzF;AAEA,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,aAAO,KAAK,OAAO;AAEnB,aAAO;AAAA,IACX;AAQA,aAAS,6BAA6B,SAAS,WAAU;AACrD,UAAI,MAAM;AACV,eAAQ,IAAE,QAAQ,SAAO,GAAG,QAAQ,SAAO,KAAK,KAAG,GAAG,EAAE,GAAE;AACtD,YAAG,UAAU,UAAU,SAAS,IAAE,CAAC,GAAE,UAAU,SAAS,CAAC,GAAE,UAAU,SAAS,IAAE,CAAC,GAAE,SAAS,GAAE;AAE1F,kBAAQ,OAAO,IAAE,QAAQ,QAAO,CAAC;AACjC;AAAA,QACJ;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAOA,aAAS,6BAA6B,SAAS,WAAU;AACrD,eAAQ,IAAE,QAAQ,SAAO,GAAG,KAAG,GAAG,EAAE,GAAE;AAClC,YAAI,KAAK,QAAQ,CAAC;AAClB,iBAAQ,IAAE,IAAE,GAAG,KAAG,GAAG,EAAE,GAAE;AACrB,cAAG,UAAU,IAAI,QAAQ,CAAC,GAAG,SAAS,GAAE;AACpC,oBAAQ,OAAO,GAAE,CAAC;AAClB;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAWA,aAAS,UAAU,GAAE,GAAE,WAAU;AAC7B,kBAAY,aAAa;AACzB,aAAO,KAAK,IAAI,IAAE,CAAC,KAAK;AAAA,IAC5B;AAWA,aAAS,UAAU,GAAE,GAAE,WAAU;AAC7B,aAAO,UAAU,EAAE,CAAC,GAAE,EAAE,CAAC,GAAE,SAAS,KAAK,UAAU,EAAE,CAAC,GAAE,EAAE,CAAC,GAAE,SAAS;AAAA,IAC1E;AAAA;AAAA;;;AChpBA;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,YAAQ,UAAU,QAAQ,WAAW;AACrC,QAAM,gBAAgB;AACtB,WAAO,eAAe,SAAS,YAAY,EAAE,YAAY,MAAM,KAAK,WAAY;AAAE,aAAO,cAAc;AAAA,IAAU,EAAE,CAAC;AACpH,QAAM,QAAQ;AACd,QAAM,UAAU;AAChB,QAAM,cAAc;AACpB,QAAM,UAAU;AAIhB,QAAM,UAAN,cAAsB,MAAM,QAAQ;AAAA;AAAA;AAAA;AAAA,MAIhC,YAAY,UAAU,QAAQ,SAAS;AACnC,eAAO,GAAG,QAAQ,mBAAmB,QAAQ,IAAI,GAAG,QAAQ,qBAAqB,MAAM,CAAC;AAIxF,aAAK,QAAQ;AAIb,aAAK,OAAO,QAAQ,SAAS;AAI7B,aAAK,WAAW;AAIhB,aAAK,cAAc,EAAE,GAAG,GAAG,GAAG,EAAE;AAChC,YAAI,EAAE,WAAW,QAAQ,WAAW,SAAS,SAAS,OAAO,SAAS;AAClE,gBAAM,IAAI,MAAM,sBAAsB;AAAA,QAC1C;AACA,SAAC,GAAG,QAAQ,YAAY,MAAM,OAAO;AAAA,MACzC;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,WAAW,YAAY;AACvB,YAAI,KAAK,aAAa,YAAY;AAC9B;AAAA,QACJ;AACA,cAAM,WAAW,KAAK,2BAA2B;AACjD,cAAM,IAAI,SAAS,KAAK,aAAa,IAAI;AACzC,cAAM,IAAI,SAAS,KAAK,aAAa,IAAI;AACzC,aAAK,UAAU,CAAC,GAAG,CAAC,CAAC;AACrB,aAAK,WAAW;AAAA,MACpB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,aAAa;AACb,eAAO,KAAK;AAAA,MAChB;AAAA,MACA,IAAI,IAAI;AACJ,eAAO,KAAK,IAAI;AAAA,MACpB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,EAAE,GAAG;AACL,aAAK,IAAI,IAAI;AACb,aAAK,QAAQ;AAAA,MACjB;AAAA,MACA,IAAI,IAAI;AACJ,eAAO,KAAK,IAAI;AAAA,MACpB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,EAAE,GAAG;AACL,aAAK,IAAI,IAAI;AACb,aAAK,QAAQ;AAAA,MACjB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,SAAS;AACT,eAAO,KAAK,YAAY;AAAA,MAC5B;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,SAAS;AACT,eAAO,KAAK,YAAY;AAAA,MAC5B;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,QAAQ;AACR,eAAO,KAAK,YAAY;AAAA,MAC5B;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,MAAM,OAAO;AACb,aAAK,SAAS,KAAK;AAAA,MACvB;AAAA;AAAA;AAAA;AAAA,MAIA,YAAY,GAAG,GAAG,SAAS,MAAM;AAC7B,aAAK,IAAI,IAAI;AACb,aAAK,IAAI,IAAI;AACb,aAAK,YAAY,MAAM;AACvB,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,SAAS,GAAG,IAAI,GAAG,SAAS,MAAM;AAC9B,aAAK,YAAY,IAAI,KAAK,IAAI,CAAC;AAC/B,aAAK,YAAY,IAAI,KAAK,IAAI,CAAC;AAC/B,cAAM,WAAW,GAAG,YAAY,KAAK,KAAK,QAAQ,CAAC,OAAO,UAAU;AAChE,gBAAM,IAAI,KAAK,aAAa,KAAK,EAAE,IAAI,KAAK,YAAY;AACxD,gBAAM,IAAI,KAAK,aAAa,KAAK,EAAE,IAAI,KAAK,YAAY;AACxD,iBAAO;AAAA,QACX,CAAC,CAAC;AACF,aAAK,YAAY,MAAM;AACvB,eAAO;AAAA,MACX;AAAA,MACA,SAAS,OAAO,SAAS,MAAM;AAC3B,cAAM,SAAS,KAAK;AACpB,aAAK,YAAY,MAAM;AACvB,eAAO;AAAA,MACX;AAAA,MACA,UAAU,QAAQ,SAAS,MAAM;AAC7B,cAAM,UAAU,MAAM;AACtB,aAAK,YAAY,MAAM;AACvB,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,gBAAgB;AACZ,cAAM,EAAE,KAAK,GAAG,EAAE,IAAI,KAAK,aAAa;AACxC,eAAO;AAAA,UACH,MAAM,IAAI;AAAA,UACV,MAAM,IAAI;AAAA,UACV,MAAM,IAAI,IAAI;AAAA,UACd,MAAM,IAAI,IAAI;AAAA,QAClB;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA,MAIA,KAAK,SAAS;AACV,SAAC,GAAG,QAAQ,aAAa,SAAS,MAAM,KAAK,SAAS;AAAA,MAC1D;AAAA;AAAA;AAAA;AAAA,MAIA,QAAQ,SAAS;AACb,SAAC,GAAG,QAAQ,SAAS,SAAS,IAAI;AAAA,MACtC;AAAA;AAAA;AAAA;AAAA,MAIA,6BAA6B;AAEzB,cAAM,QAAQ,KAAK;AAEnB,aAAK,SAAS,CAAC;AAEf,cAAM,WAAW,KAAK,YAAY;AAElC,aAAK,SAAS,KAAK;AACnB,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,UAAU,QAAQ;AACd,cAAM,UAAU,MAAM;AACtB,aAAK,eAAe;AACpB,aAAK,gBAAgB,GAAG,QAAQ,kBAAkB,MAAM;AACxD,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,UAAU,GAAG,GAAG;AACZ,cAAM,UAAU,GAAG,CAAC;AACpB,aAAK,gBAAgB,GAAG,QAAQ,kBAAkB,KAAK,MAAM;AAC7D,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,OAAO,OAAO;AACV,cAAM,OAAO,KAAK;AAClB,aAAK,gBAAgB,GAAG,QAAQ,kBAAkB,KAAK,MAAM;AAC7D,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,WAAW;AACP,gBAAQ,GAAG,cAAc,UAAU,KAAK,WAAW,IAAI,QAAQ,gBAAgB,CAAC;AAAA,MACpF;AAAA;AAAA;AAAA;AAAA,MAIA,WAAW,SAAS,KAAK,OAAO;AAC5B,YAAI;AACJ,YAAI,QAAQ;AACR,eAAK,6BAA6B;AAClC,WAAC,KAAK,KAAK,YAAY,QAAQ,OAAO,SAAS,SAAS,GAAG,OAAO,IAAI;AACtE,eAAK,QAAQ;AAAA,QACjB;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA,MAIA,YAAY,QAAQ;AAChB,YAAI,QAAQ;AACR,eAAK,WAAW,IAAI;AAAA,QACxB,OACK;AACD,eAAK,QAAQ;AAAA,QACjB;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,+BAA+B;AAC3B,YAAI,KAAK,YAAY,CAAC,KAAK,gBAAgB;AACvC;AAAA,QACJ;AACA,SAAC,GAAG,YAAY,SAAS,KAAK,gBAAgB,CAAC,YAAY;AACvD,kBAAQ,IAAI,IAAI,KAAK,IAAI;AACzB,kBAAQ,IAAI,IAAI,KAAK,IAAI;AAAA,QAC7B,CAAC;AAAA,MACL;AAAA;AAAA;AAAA;AAAA,MAIA,YAAY;AACR,YAAK,KAAK,QAAQ,KAAK,SAAS,QAAQ,SAAS,WAC7C,KAAK,OAAO,SAAS,GAAG;AACxB,iBAAO,CAAC;AAAA,QACZ;AACA,cAAM,UAAU,GAAG,YAAY,KAAK,KAAK,YAAY,QAAQ,gBAAgB;AAC7E,gBAAQ,GAAG,cAAc,aAAa,MAAM;AAAA,MAChD;AAAA;AAAA;AAAA;AAAA,MAIA,qBAAqB,SAAS,KAAK,UAAU,GAAG;AAC5C,YAAI,KAAK,UAAU;AACf;AAAA,QACJ;AACA,YAAI,CAAC,KAAK,gBAAgB;AACtB,eAAK,iBAAiB,CAAC;AAAA,QAC3B;AACA,SAAC,GAAG,YAAY,SAAS,QAAQ,CAAC,QAAQ,UAAU;AAEhD,cAAI,CAAC,KAAK,eAAe,KAAK,GAAG;AAC7B,iBAAK,eAAe,KAAK,IAAI,IAAI,MAAM,QAAQ;AAAA,UACnD;AACA,eAAK,eAAe,KAAK,EAAE,IAAI,IAAI,KAAK,IAAI;AAC5C,eAAK,eAAe,KAAK,EAAE,IAAI,IAAI,KAAK,IAAI;AAC5C,eAAK,eAAe,KAAK,EAAE,WAAW,GAAG,QAAQ,sBAAsB,GAAG,YAAY,KAAK,QAAQ,QAAQ,gBAAgB,CAAC,CAAC;AAAA,QACjI,CAAC;AAED,aAAK,eAAe,SAAS,OAAO;AAAA,MACxC;AAAA;AAAA;AAAA;AAAA,MAIA,iBAAiB;AAEb,cAAM,SAAS,KAAK,UAAU;AAE9B,aAAK,WAAW,OAAO,UAAU;AACjC,aAAK,qBAAqB,MAAM;AAAA,MACpC;AAAA,IACJ;AACA,YAAQ,UAAU;AAAA;AAAA;;;AC3RlB;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,YAAQ,UAAU;AAClB,QAAM,UAAU;AAChB,QAAM,UAAU;AAChB,QAAM,YAAY;AAIlB,QAAM,UAAN,cAAsB,UAAU,QAAQ;AAAA;AAAA;AAAA;AAAA,MAIpC,YAAY,UAAU,SAAS,UAAU,SAAS,QAAQ,UAAU,WAAW,KAAK,IAAI,SAAS;AAC7F,cAAM,WAAW,GAAG,QAAQ,eAAe,SAAS,SAAS,IAAI,GAAG,OAAO;AAI3E,aAAK,OAAO,QAAQ,SAAS;AAI7B,aAAK,WAAW;AAChB,aAAK,WAAW;AAChB,aAAK,WAAW;AAChB,aAAK,QAAQ;AAAA,MACjB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,WAAW,aAAa;AAAA,MAAE;AAAA;AAAA;AAAA;AAAA,MAI9B,IAAI,aAAa;AACb,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,OAAO;AACP,eAAO,KAAK;AAAA,MAChB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,KAAK,MAAM;AACX,aAAK,QAAQ;AACb,aAAK,WAAW,GAAG,QAAQ,eAAe,KAAK,UAAU,KAAK,UAAU,KAAK,KAAK,CAAC;AAAA,MACvF;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,UAAU;AACV,eAAO,KAAK;AAAA,MAChB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,QAAQ,SAAS;AACjB,aAAK,WAAW;AAChB,aAAK,WAAW,GAAG,QAAQ,eAAe,KAAK,UAAU,KAAK,UAAU,KAAK,KAAK,CAAC;AAAA,MACvF;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,UAAU;AACV,eAAO,KAAK;AAAA,MAChB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,QAAQ,SAAS;AACjB,aAAK,WAAW;AAChB,aAAK,WAAW,GAAG,QAAQ,eAAe,KAAK,UAAU,KAAK,UAAU,KAAK,KAAK,CAAC;AAAA,MACvF;AAAA;AAAA;AAAA;AAAA,MAIA,SAAS;AACL;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA,MAIA,iBAAiB;AACb;AAAA,MACJ;AAAA,IACJ;AACA,YAAQ,UAAU;AAAA;AAAA;;;ACzFlB;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,YAAQ,MAAM;AACd,QAAM,UAAU;AAChB,QAAM,UAAU;AAChB,QAAM,YAAY;AAIlB,QAAM,MAAN,cAAkB,UAAU,QAAQ;AAAA;AAAA;AAAA;AAAA,MAIhC,YAAY,UAAU,OAAO,QAAQ,SAAS;AAC1C,cAAM,WAAW,GAAG,QAAQ,WAAW,OAAO,MAAM,GAAG,OAAO;AAI9D,aAAK,OAAO,QAAQ,SAAS;AAI7B,aAAK,WAAW;AAChB,aAAK,SAAS;AACd,aAAK,UAAU;AAAA,MACnB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,QAAQ;AACR,eAAO,KAAK;AAAA,MAChB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,MAAM,OAAO;AACb,aAAK,SAAS;AACd,aAAK,WAAW,GAAG,QAAQ,WAAW,KAAK,QAAQ,KAAK,OAAO,CAAC;AAAA,MACpE;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,SAAS;AACT,eAAO,KAAK;AAAA,MAChB;AAAA;AAAA;AAAA;AAAA,MAIA,IAAI,OAAO,QAAQ;AACf,aAAK,UAAU;AACf,aAAK,WAAW,GAAG,QAAQ,WAAW,KAAK,QAAQ,KAAK,OAAO,CAAC;AAAA,MACpE;AAAA;AAAA;AAAA;AAAA,MAIA,iBAAiB;AACb;AAAA,MACJ;AAAA,IACJ;AACA,YAAQ,MAAM;AAAA;AAAA;;;AC3Dd;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,YAAQ,QAAQ;AAChB,QAAM,UAAU;AAChB,QAAM,UAAU;AAChB,QAAM,QAAQ;AAId,QAAM,QAAN,cAAoB,MAAM,IAAI;AAAA;AAAA;AAAA;AAAA,MAI1B,YAAY,UAAU,SAAS;AAC3B,eAAO,GAAG,QAAQ,mBAAmB,QAAQ,GAAG,MAAO,MAAO,OAAO;AAIrE,aAAK,OAAO,QAAQ,SAAS;AAAA,MACjC;AAAA,IACJ;AACA,YAAQ,QAAQ;AAAA;AAAA;;;ACrBhB;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,YAAQ,OAAO;AACf,QAAM,QAAQ;AACd,QAAM,UAAU;AAChB,QAAM,YAAY;AAIlB,QAAM,OAAN,cAAmB,UAAU,QAAQ;AAAA;AAAA;AAAA;AAAA,MAIjC,YAAY,OAAO,KAAK,SAAS;AAC7B,cAAM,OAAO;AAAA,UACT,EAAE,GAAG,GAAG,GAAG,EAAE;AAAA,UACb,EAAE,GAAG,IAAI,IAAI,MAAM,GAAG,GAAG,IAAI,IAAI,MAAM,EAAE;AAAA,QAC7C,GAAG,OAAO;AAIV,aAAK,OAAO,QAAQ,SAAS;AAI7B,aAAK,WAAW;AAChB,YAAI,KAAK,WAAW,WAAW,KAAK,CAAC,KAAK;AACtC,kBAAQ,MAAM,EAAE,OAAO,IAAI,CAAC;AAC5B,gBAAM,IAAI,MAAM,gCAAgC;AAAA,QACpD;AAAA,MACJ;AAAA,MACA,IAAI,QAAQ;AACR,eAAO;AAAA,UACH,GAAG,KAAK,IAAI,KAAK,WAAW,CAAC,EAAE;AAAA,UAC/B,GAAG,KAAK,IAAI,KAAK,WAAW,CAAC,EAAE;AAAA,QACnC;AAAA,MACJ;AAAA,MACA,IAAI,MAAM,EAAE,GAAG,EAAE,GAAG;AAChB,aAAK,IAAI;AACT,aAAK,IAAI;AAAA,MACb;AAAA,MACA,IAAI,MAAM;AACN,eAAO;AAAA,UACH,GAAG,KAAK,IAAI,KAAK,WAAW,CAAC,EAAE;AAAA,UAC/B,GAAG,KAAK,IAAI,KAAK,WAAW,CAAC,EAAE;AAAA,QACnC;AAAA,MACJ;AAAA,MACA,IAAI,IAAI,EAAE,GAAG,EAAE,GAAG;AACd,aAAK,OAAO,CAAC,EAAE,IAAI,IAAI,KAAK,MAAM;AAClC,aAAK,OAAO,CAAC,EAAE,IAAI,IAAI,KAAK,MAAM;AAClC,aAAK,UAAU,KAAK,MAAM;AAAA,MAC9B;AAAA,MACA,cAAc;AACV,eAAO,IAAI,MAAM,QAAQ,KAAK,IAAI,IAAI,KAAK,MAAM,KAAK,IAAI,KAAK,IAAI,IAAI,KAAK,MAAM,KAAK,CAAC;AAAA,MAC5F;AAAA;AAAA;AAAA;AAAA,MAIA,iBAAiB;AACb;AAAA,MACJ;AAAA,IACJ;AACA,YAAQ,OAAO;AAAA;AAAA;;;AC9Df;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,YAAQ,aAAa;AACrB,QAAM,QAAQ;AACd,QAAM,WAAW;AACjB,QAAM,YAAY;AAClB,QAAM,SAAS;AACf,QAAM,UAAU;AAChB,QAAM,YAAY;AAClB,QAAM,UAAU;AAChB,QAAM,cAAc;AACpB,QAAM,UAAU;AAIhB,QAAM,aAAN,cAAyB,QAAQ,MAAM;AAAA;AAAA;AAAA;AAAA,MAInC,KAAK,SAAS;AACV,SAAC,GAAG,YAAY,SAAS,KAAK,IAAI,GAAG,CAAC,SAAS;AAC3C,eAAK,KAAK,OAAO;AAAA,QACrB,CAAC;AAAA,MACL;AAAA;AAAA;AAAA;AAAA,MAIA,QAAQ,SAAS;AACb,cAAM,eAAe,CAAC,SAAS;AAC3B,WAAC,GAAG,QAAQ,SAAS,SAAS,IAAI;AAClC,cAAI,KAAK,UAAU;AACf,aAAC,GAAG,YAAY,SAAS,KAAK,UAAU,YAAY;AAAA,UACxD;AAAA,QACJ;AACA,SAAC,GAAG,YAAY,SAAS,KAAK,KAAK,UAAU,YAAY;AAAA,MAC7D;AAAA;AAAA;AAAA;AAAA,MAIA,YAAY,UAAU,SAAS;AAC3B,cAAM,QAAQ,IAAI,QAAQ,MAAM,UAAU,OAAO;AACjD,aAAK,OAAO,KAAK;AACjB,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,WAAW,OAAO,KAAK,SAAS;AAC5B,cAAM,OAAO,IAAI,OAAO,KAAK,OAAO,KAAK,OAAO;AAChD,aAAK,OAAO,IAAI;AAChB,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,aAAa,UAAU,QAAQ,SAAS;AACpC,cAAM,SAAS,IAAI,SAAS,OAAO,UAAU,QAAQ,OAAO;AAC5D,aAAK,OAAO,MAAM;AAClB,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,UAAU,UAAU,OAAO,QAAQ,SAAS;AACxC,cAAM,MAAM,IAAI,MAAM,IAAI,UAAU,OAAO,QAAQ,OAAO;AAC1D,aAAK,OAAO,GAAG;AACf,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,cAAc,UAAU,SAAS,UAAU,SAAS,MAAM,SAAS;AAC/D,cAAM,UAAU,IAAI,UAAU,QAAQ,UAAU,SAAS,SAAS,MAAM,OAAO;AAC/E,aAAK,OAAO,OAAO;AACnB,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,cAAc,UAAU,QAAQ,SAAS;AACrC,cAAM,UAAU,IAAI,UAAU,QAAQ,UAAU,QAAQ,OAAO;AAC/D,aAAK,OAAO,OAAO;AACnB,eAAO;AAAA,MACX;AAAA,IACJ;AACA,YAAQ,aAAa;AAAA;AAAA;;;ACrFrB;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,YAAQ,SAAS;AACjB,QAAM,gBAAgB;AACtB,QAAM,SAAS;AACf,QAAM,UAAU;AAChB,QAAM,UAAU;AAChB,QAAM,cAAc;AACpB,QAAM,cAAc;AAIpB,QAAM,SAAN,cAAqB,cAAc,WAAW;AAAA,MAC1C,cAAc;AACV,cAAM,GAAG,SAAS;AAIlB,aAAK,WAAW,IAAI,QAAQ,SAAS;AAAA,MACzC;AAAA;AAAA;AAAA;AAAA,MAIA,OAAO,MAAM,QAAQ;AACjB,aAAK,SAAS;AACd,eAAO,MAAM,OAAO,MAAM,MAAM;AAAA,MACpC;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,OAAO,MAAM;AACT,aAAK,OAAO,KAAK,cAAc;AAC/B,YAAI,KAAK,QAAQ;AAEb,cAAI,EAAE,GAAG,QAAQ,WAAW,IAAI,GAAG;AAC/B,mBAAO;AAAA,UACX;AAEA,eAAK,OAAO,OAAO,IAAI;AAAA,QAC3B;AAEA,aAAK,OAAO,KAAK,KAAK,OAAO,KAAK;AAClC,aAAK,OAAO,KAAK,KAAK,OAAO,KAAK;AAClC,aAAK,OAAO,KAAK,KAAK,OAAO,KAAK;AAClC,aAAK,OAAO,KAAK,KAAK,OAAO,KAAK;AAElC,aAAK,SAAS;AAEd,eAAO,MAAM,OAAO,IAAI;AAAA,MAC5B;AAAA;AAAA;AAAA;AAAA,MAIA,WAAW,MAAM;AACb,aAAK,WAAW;AAAA,MACpB;AAAA;AAAA;AAAA;AAAA,MAIA,SAAS;AACL,SAAC,GAAG,YAAY,SAAS,KAAK,IAAI,GAAG,CAAC,SAAS;AAC3C,eAAK,WAAW,IAAI;AAAA,QACxB,CAAC;AAAA,MACL;AAAA;AAAA;AAAA;AAAA,MAIA,WAAW;AACP,aAAK,SAAS,CAAC,EAAE,GAAG,SAAS,MAAM;AAE/B,cAAI,EAAE,WAAW;AACb,mBAAO;AAAA,UACX;AACA,YAAE,YAAY,EAAE,IAAI,SAAS,GAAG,EAAE,IAAI,SAAS,CAAC;AAAA,QACpD,CAAC;AAAA,MACL;AAAA;AAAA;AAAA;AAAA,MAIA,SAAS,MAAM,WAAW,MAAM,MAAM,WAAW,KAAK,UAAU;AAE5D,YAAI,KAAK,UAAU;AACf,iBAAO;AAAA,QACX;AACA,cAAM,SAAS,KAAK,OAAO,IAAI;AAC/B,cAAM,iBAAiB,CAAC,cAAc;AAClC,cAAI,cAAc,QACd,KAAK,eAAe,MAAM,WAAW,QAAQ,GAAG;AAChD,mBAAO,SAAS,QAAQ;AAAA,UAC5B;AAAA,QACJ;AACA,gBAAQ,GAAG,YAAY,MAAM,QAAQ,cAAc;AAAA,MACvD;AAAA;AAAA;AAAA;AAAA,MAIA,SAAS,UAAU,WAAW,KAAK,UAAU;AACzC,cAAM,SAAS,KAAK,IAAI;AACxB,cAAM,WAAW,CAAC,SAAS;AACvB,iBAAO,KAAK,SAAS,MAAM,UAAU,QAAQ;AAAA,QACjD;AACA,gBAAQ,GAAG,YAAY,MAAM,QAAQ,QAAQ;AAAA,MACjD;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,cAAc,MAAM;AAEhB,gBAAQ,GAAG,YAAY,QAAQ,KAAK,OAAO,IAAI,GAAG,CAAC,cAAc,cAAc,IAAI;AAAA,MACvF;AAAA;AAAA;AAAA;AAAA,MAIA,eAAe,OAAO,OAAO,WAAW,KAAK,UAAU;AAEnD,aAAK,MAAM,WAAW,MAAM,aACvB,GAAG,QAAQ,kBAAkB,MAAM,QAAQ,OAAO,MAAM,QAAQ,KAAK,GAAG;AACzE,iBAAO;AAAA,QACX;AACA,cAAM,OAAO,GAAG,QAAQ,YAAY,OAAO,KAAK;AAEhD,YAAI,MAAM,YAAY,MAAM,UAAU;AAClC,mBAAS,MAAM;AACf,iBAAO,IAAI,OAAO,OAAO,QAAQ;AAAA,QACrC;AAEA,cAAM,iBAAiB,GAAG,YAAY,cAAc,KAAK;AACzD,cAAM,iBAAiB,GAAG,YAAY,cAAc,KAAK;AACzD,cAAM,WAAW,IAAI,QAAQ,UAAU;AACvC,YAAI,WAAW;AACf,SAAC,GAAG,YAAY,SAAS,eAAe,CAAC,gBAAgB;AACrD,WAAC,GAAG,YAAY,SAAS,eAAe,CAAC,gBAAgB;AACrD,qBAAS,MAAM;AACf,gBAAI,IAAI,aAAa,aAAa,QAAQ,GAAG;AACzC,yBAAW;AACX,uBAAS,IAAI,SAAS,QAAQ;AAAA,YAClC;AAAA,UACJ,CAAC;AAAA,QACL,CAAC;AACD,YAAI,UAAU;AACV,mBAAS,IAAI;AACb,mBAAS,IAAI;AACb,mBAAS,WAAW;AACpB,mBAAS,WAAW,SAAS,MAAM,EAAE,UAAU;AAC/C,mBAAS,UAAU,SAAS,IAAI;AAChC,mBAAS,QAAQ,GAAG,QAAQ,WAAW,OAAO,KAAK;AACnD,mBAAS,QAAQ,GAAG,QAAQ,WAAW,OAAO,KAAK;AAAA,QACvD;AACA,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,QAAQ,OAAO,KAAK,QAAQ,MAAM,MAAM;AACpC,YAAI,cAAc;AAClB,YAAI,SAAS;AACb,YAAI,CAAC,KAAK,KAAK;AACX,eAAK,MAAM,IAAI,OAAO,KAAK,OAAO,KAAK,EAAE,WAAW,KAAK,CAAC;AAAA,QAC9D,OACK;AACD,eAAK,IAAI,QAAQ;AACjB,eAAK,IAAI,MAAM;AAAA,QACnB;AACA,aAAK,OAAO,KAAK,GAAG;AACpB,aAAK,SAAS,KAAK,KAAK,CAAC,EAAE,GAAG,KAAK,MAAM;AACrC,cAAI,CAAC,MAAM,IAAI,GAAG;AACd,mBAAO;AAAA,UACX;AACA,gBAAM,SAAS,KAAK,SAAS,QAAQ,SAAS,UACvC,GAAG,YAAY,qBAAqB,KAAK,KAAK,IAAI,KAClD,GAAG,YAAY,sBAAsB,KAAK,KAAK,IAAI;AAC1D,WAAC,GAAG,YAAY,SAAS,QAAQ,CAAC,UAAU;AACxC,kBAAM,iBAAiB,GAAG,QAAQ,UAAU,OAAO,KAAK;AACxD,gBAAI,gBAAgB,aAAa;AAC7B,4BAAc;AACd,uBAAS,EAAE,OAAO,KAAK;AAAA,YAC3B;AAAA,UACJ,CAAC;AAAA,QACL,CAAC;AACD,aAAK,OAAO,KAAK,GAAG;AACpB,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA,MAIA,SAAS,MAAM,EAAE,SAAS,IAAI,KAAK,MAAM;AACrC,eAAO,aAAa,QAAQ,aAAa,SAAS,SAAS,SAAS,KAAK,CAAC,MAAM,UAAU;AACtF,cAAI,CAAC,MAAM;AACP,mBAAO;AAAA,UACX;AACA,cAAI,KAAK,QAAQ,KAAK,MAAM,UAAU,KAAK,GAAG;AAC1C,mBAAO;AAAA,UACX;AAEA,cAAI,KAAK,UAAU;AACf,iBAAK,SAAS,MAAM,IAAI;AAAA,UAC5B;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,IACJ;AACA,YAAQ,SAAS;AAAA;AAAA;;;AC1MjB;AAAA;AACA,QAAI,kBAAmB,WAAQ,QAAK,oBAAqB,OAAO,SAAU,SAAS,GAAG,GAAG,GAAG,IAAI;AAC5F,UAAI,OAAO;AAAW,aAAK;AAC3B,UAAI,OAAO,OAAO,yBAAyB,GAAG,CAAC;AAC/C,UAAI,CAAC,SAAS,SAAS,OAAO,CAAC,EAAE,aAAa,KAAK,YAAY,KAAK,eAAe;AACjF,eAAO,EAAE,YAAY,MAAM,KAAK,WAAW;AAAE,iBAAO,EAAE,CAAC;AAAA,QAAG,EAAE;AAAA,MAC9D;AACA,aAAO,eAAe,GAAG,IAAI,IAAI;AAAA,IACrC,IAAM,SAAS,GAAG,GAAG,GAAG,IAAI;AACxB,UAAI,OAAO;AAAW,aAAK;AAC3B,QAAE,EAAE,IAAI,EAAE,CAAC;AAAA,IACf;AACA,QAAI,eAAgB,WAAQ,QAAK,gBAAiB,SAAS,GAAGC,UAAS;AACnE,eAAS,KAAK;AAAG,YAAI,MAAM,aAAa,CAAC,OAAO,UAAU,eAAe,KAAKA,UAAS,CAAC;AAAG,0BAAgBA,UAAS,GAAG,CAAC;AAAA,IAC5H;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,iBAAa,iBAAoB,OAAO;AACxC,iBAAa,kBAA4B,OAAO;AAChD,iBAAa,mBAA6B,OAAO;AACjD,iBAAa,mBAA6B,OAAO;AACjD,iBAAa,eAAyB,OAAO;AAC7C,iBAAa,iBAA2B,OAAO;AAC/C,iBAAa,gBAA0B,OAAO;AAC9C,iBAAa,kBAAqB,OAAO;AACzC,iBAAa,iBAAoB,OAAO;AACxC,iBAAa,qBAAwB,OAAO;AAAA;AAAA;",
  "names": ["t", "r", "e", "a", "h", "n", "o", "s", "l", "f", "u", "m", "c", "p", "d", "i", "i", "BodyType", "exports"]
}
