import {
  __commonJS
} from "./chunk-76J2PTFD.js";

// node_modules/rbush/rbush.min.js
var require_rbush_min = __commonJS({
  "node_modules/rbush/rbush.min.js"(exports, module) {
    !function(t, i) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = t || self).RBush = i();
    }(exports, function() {
      "use strict";
      function t(t2, r2, e2, a2, h2) {
        !function t3(n2, r3, e3, a3, h3) {
          for (; a3 > e3; ) {
            if (a3 - e3 > 600) {
              var o2 = a3 - e3 + 1, s2 = r3 - e3 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u2 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m2 = Math.max(e3, Math.floor(r3 - s2 * f2 / o2 + u2)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u2));
              t3(n2, r3, m2, c2, h3);
            }
            var p2 = n2[r3], d2 = e3, x = a3;
            for (i(n2, e3, r3), h3(n2[a3], p2) > 0 && i(n2, e3, a3); d2 < x; ) {
              for (i(n2, d2, x), d2++, x--; h3(n2[d2], p2) < 0; )
                d2++;
              for (; h3(n2[x], p2) > 0; )
                x--;
            }
            0 === h3(n2[e3], p2) ? i(n2, e3, x) : i(n2, ++x, a3), x <= r3 && (e3 = x + 1), r3 <= x && (a3 = x - 1);
          }
        }(t2, r2, e2 || 0, a2 || t2.length - 1, h2 || n);
      }
      function i(t2, i2, n2) {
        var r2 = t2[i2];
        t2[i2] = t2[n2], t2[n2] = r2;
      }
      function n(t2, i2) {
        return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
      }
      var r = function(t2) {
        void 0 === t2 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
      };
      function e(t2, i2, n2) {
        if (!n2)
          return i2.indexOf(t2);
        for (var r2 = 0; r2 < i2.length; r2++)
          if (n2(t2, i2[r2]))
            return r2;
        return -1;
      }
      function a(t2, i2) {
        h(t2, 0, t2.children.length, i2, t2);
      }
      function h(t2, i2, n2, r2, e2) {
        e2 || (e2 = p(null)), e2.minX = 1 / 0, e2.minY = 1 / 0, e2.maxX = -1 / 0, e2.maxY = -1 / 0;
        for (var a2 = i2; a2 < n2; a2++) {
          var h2 = t2.children[a2];
          o(e2, t2.leaf ? r2(h2) : h2);
        }
        return e2;
      }
      function o(t2, i2) {
        return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
      }
      function s(t2, i2) {
        return t2.minX - i2.minX;
      }
      function l(t2, i2) {
        return t2.minY - i2.minY;
      }
      function f(t2) {
        return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
      }
      function u(t2) {
        return t2.maxX - t2.minX + (t2.maxY - t2.minY);
      }
      function m(t2, i2) {
        return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
      }
      function c(t2, i2) {
        return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
      }
      function p(t2) {
        return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
      }
      function d(i2, n2, r2, e2, a2) {
        for (var h2 = [n2, r2]; h2.length; )
          if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e2)) {
            var o2 = n2 + Math.ceil((r2 - n2) / e2 / 2) * e2;
            t(i2, o2, n2, r2, a2), h2.push(n2, o2, o2, r2);
          }
      }
      return r.prototype.all = function() {
        return this._all(this.data, []);
      }, r.prototype.search = function(t2) {
        var i2 = this.data, n2 = [];
        if (!c(t2, i2))
          return n2;
        for (var r2 = this.toBBox, e2 = []; i2; ) {
          for (var a2 = 0; a2 < i2.children.length; a2++) {
            var h2 = i2.children[a2], o2 = i2.leaf ? r2(h2) : h2;
            c(t2, o2) && (i2.leaf ? n2.push(h2) : m(t2, o2) ? this._all(h2, n2) : e2.push(h2));
          }
          i2 = e2.pop();
        }
        return n2;
      }, r.prototype.collides = function(t2) {
        var i2 = this.data;
        if (!c(t2, i2))
          return false;
        for (var n2 = []; i2; ) {
          for (var r2 = 0; r2 < i2.children.length; r2++) {
            var e2 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e2) : e2;
            if (c(t2, a2)) {
              if (i2.leaf || m(t2, a2))
                return true;
              n2.push(e2);
            }
          }
          i2 = n2.pop();
        }
        return false;
      }, r.prototype.load = function(t2) {
        if (!t2 || !t2.length)
          return this;
        if (t2.length < this._minEntries) {
          for (var i2 = 0; i2 < t2.length; i2++)
            this.insert(t2[i2]);
          return this;
        }
        var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
        if (this.data.children.length)
          if (this.data.height === n2.height)
            this._splitRoot(this.data, n2);
          else {
            if (this.data.height < n2.height) {
              var r2 = this.data;
              this.data = n2, n2 = r2;
            }
            this._insert(n2, this.data.height - n2.height - 1, true);
          }
        else
          this.data = n2;
        return this;
      }, r.prototype.insert = function(t2) {
        return t2 && this._insert(t2, this.data.height - 1), this;
      }, r.prototype.clear = function() {
        return this.data = p([]), this;
      }, r.prototype.remove = function(t2, i2) {
        if (!t2)
          return this;
        for (var n2, r2, a2, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
          if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h2.leaf) {
            var f2 = e(t2, h2.children, i2);
            if (-1 !== f2)
              return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
          }
          a2 || h2.leaf || !m(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a2 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
        }
        return this;
      }, r.prototype.toBBox = function(t2) {
        return t2;
      }, r.prototype.compareMinX = function(t2, i2) {
        return t2.minX - i2.minX;
      }, r.prototype.compareMinY = function(t2, i2) {
        return t2.minY - i2.minY;
      }, r.prototype.toJSON = function() {
        return this.data;
      }, r.prototype.fromJSON = function(t2) {
        return this.data = t2, this;
      }, r.prototype._all = function(t2, i2) {
        for (var n2 = []; t2; )
          t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
        return i2;
      }, r.prototype._build = function(t2, i2, n2, r2) {
        var e2, h2 = n2 - i2 + 1, o2 = this._maxEntries;
        if (h2 <= o2)
          return a(e2 = p(t2.slice(i2, n2 + 1)), this.toBBox), e2;
        r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e2 = p([])).leaf = false, e2.height = r2;
        var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
        d(t2, i2, n2, l2, this.compareMinX);
        for (var f2 = i2; f2 <= n2; f2 += l2) {
          var u2 = Math.min(f2 + l2 - 1, n2);
          d(t2, f2, u2, s2, this.compareMinY);
          for (var m2 = f2; m2 <= u2; m2 += s2) {
            var c2 = Math.min(m2 + s2 - 1, u2);
            e2.children.push(this._build(t2, m2, c2, r2 - 1));
          }
        }
        return a(e2, this.toBBox), e2;
      }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
        for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
          for (var e2 = 1 / 0, a2 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
            var s2 = i2.children[o2], l2 = f(s2), u2 = (m2 = t2, c2 = s2, (Math.max(c2.maxX, m2.maxX) - Math.min(c2.minX, m2.minX)) * (Math.max(c2.maxY, m2.maxY) - Math.min(c2.minY, m2.minY)) - l2);
            u2 < a2 ? (a2 = u2, e2 = l2 < e2 ? l2 : e2, h2 = s2) : u2 === a2 && l2 < e2 && (e2 = l2, h2 = s2);
          }
          i2 = h2 || i2.children[0];
        }
        var m2, c2;
        return i2;
      }, r.prototype._insert = function(t2, i2, n2) {
        var r2 = n2 ? t2 : this.toBBox(t2), e2 = [], a2 = this._chooseSubtree(r2, this.data, i2, e2);
        for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e2[i2].children.length > this._maxEntries; )
          this._split(e2, i2), i2--;
        this._adjustParentBBoxes(r2, e2, i2);
      }, r.prototype._split = function(t2, i2) {
        var n2 = t2[i2], r2 = n2.children.length, e2 = this._minEntries;
        this._chooseSplitAxis(n2, e2, r2);
        var h2 = this._chooseSplitIndex(n2, e2, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
        o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
      }, r.prototype._splitRoot = function(t2, i2) {
        this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
      }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
        for (var r2, e2, a2, o2, s2, l2, u2, m2 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
          var d2 = h(t2, 0, p2, this.toBBox), x = h(t2, p2, n2, this.toBBox), v = (e2 = d2, a2 = x, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, o2 = Math.max(e2.minX, a2.minX), s2 = Math.max(e2.minY, a2.minY), l2 = Math.min(e2.maxX, a2.maxX), u2 = Math.min(e2.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u2 - s2)), M = f(d2) + f(x);
          v < m2 ? (m2 = v, r2 = p2, c2 = M < c2 ? M : c2) : v === m2 && M < c2 && (c2 = M, r2 = p2);
        }
        return r2 || n2 - i2;
      }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
        var r2 = t2.leaf ? this.compareMinX : s, e2 = t2.leaf ? this.compareMinY : l;
        this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e2) && t2.children.sort(r2);
      }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
        t2.children.sort(r2);
        for (var e2 = this.toBBox, a2 = h(t2, 0, i2, e2), s2 = h(t2, n2 - i2, n2, e2), l2 = u(a2) + u(s2), f2 = i2; f2 < n2 - i2; f2++) {
          var m2 = t2.children[f2];
          o(a2, t2.leaf ? e2(m2) : m2), l2 += u(a2);
        }
        for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
          var p2 = t2.children[c2];
          o(s2, t2.leaf ? e2(p2) : p2), l2 += u(s2);
        }
        return l2;
      }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
        for (var r2 = n2; r2 >= 0; r2--)
          o(i2[r2], t2);
      }, r.prototype._condense = function(t2) {
        for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--)
          0 === t2[i2].children.length ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
      }, r;
    });
  }
});

// node_modules/sat/SAT.js
var require_SAT = __commonJS({
  "node_modules/sat/SAT.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof define === "function" && define["amd"]) {
        define(factory);
      } else if (typeof exports === "object") {
        module["exports"] = factory();
      } else {
        root["SAT"] = factory();
      }
    })(exports, function() {
      "use strict";
      var SAT = {};
      function Vector(x, y) {
        this["x"] = x || 0;
        this["y"] = y || 0;
      }
      SAT["Vector"] = Vector;
      SAT["V"] = Vector;
      Vector.prototype["copy"] = Vector.prototype.copy = function(other) {
        this["x"] = other["x"];
        this["y"] = other["y"];
        return this;
      };
      Vector.prototype["clone"] = Vector.prototype.clone = function() {
        return new Vector(this["x"], this["y"]);
      };
      Vector.prototype["perp"] = Vector.prototype.perp = function() {
        var x = this["x"];
        this["x"] = this["y"];
        this["y"] = -x;
        return this;
      };
      Vector.prototype["rotate"] = Vector.prototype.rotate = function(angle) {
        var x = this["x"];
        var y = this["y"];
        this["x"] = x * Math.cos(angle) - y * Math.sin(angle);
        this["y"] = x * Math.sin(angle) + y * Math.cos(angle);
        return this;
      };
      Vector.prototype["reverse"] = Vector.prototype.reverse = function() {
        this["x"] = -this["x"];
        this["y"] = -this["y"];
        return this;
      };
      Vector.prototype["normalize"] = Vector.prototype.normalize = function() {
        var d = this.len();
        if (d > 0) {
          this["x"] = this["x"] / d;
          this["y"] = this["y"] / d;
        }
        return this;
      };
      Vector.prototype["add"] = Vector.prototype.add = function(other) {
        this["x"] += other["x"];
        this["y"] += other["y"];
        return this;
      };
      Vector.prototype["sub"] = Vector.prototype.sub = function(other) {
        this["x"] -= other["x"];
        this["y"] -= other["y"];
        return this;
      };
      Vector.prototype["scale"] = Vector.prototype.scale = function(x, y) {
        this["x"] *= x;
        this["y"] *= typeof y != "undefined" ? y : x;
        return this;
      };
      Vector.prototype["project"] = Vector.prototype.project = function(other) {
        var amt = this.dot(other) / other.len2();
        this["x"] = amt * other["x"];
        this["y"] = amt * other["y"];
        return this;
      };
      Vector.prototype["projectN"] = Vector.prototype.projectN = function(other) {
        var amt = this.dot(other);
        this["x"] = amt * other["x"];
        this["y"] = amt * other["y"];
        return this;
      };
      Vector.prototype["reflect"] = Vector.prototype.reflect = function(axis) {
        var x = this["x"];
        var y = this["y"];
        this.project(axis).scale(2);
        this["x"] -= x;
        this["y"] -= y;
        return this;
      };
      Vector.prototype["reflectN"] = Vector.prototype.reflectN = function(axis) {
        var x = this["x"];
        var y = this["y"];
        this.projectN(axis).scale(2);
        this["x"] -= x;
        this["y"] -= y;
        return this;
      };
      Vector.prototype["dot"] = Vector.prototype.dot = function(other) {
        return this["x"] * other["x"] + this["y"] * other["y"];
      };
      Vector.prototype["len2"] = Vector.prototype.len2 = function() {
        return this.dot(this);
      };
      Vector.prototype["len"] = Vector.prototype.len = function() {
        return Math.sqrt(this.len2());
      };
      function Circle(pos, r) {
        this["pos"] = pos || new Vector();
        this["r"] = r || 0;
        this["offset"] = new Vector();
      }
      SAT["Circle"] = Circle;
      Circle.prototype["getAABBAsBox"] = Circle.prototype.getAABBAsBox = function() {
        var r = this["r"];
        var corner = this["pos"].clone().add(this["offset"]).sub(new Vector(r, r));
        return new Box(corner, r * 2, r * 2);
      };
      Circle.prototype["getAABB"] = Circle.prototype.getAABB = function() {
        return this.getAABBAsBox().toPolygon();
      };
      Circle.prototype["setOffset"] = Circle.prototype.setOffset = function(offset) {
        this["offset"] = offset;
        return this;
      };
      function Polygon(pos, points) {
        this["pos"] = pos || new Vector();
        this["angle"] = 0;
        this["offset"] = new Vector();
        this.setPoints(points || []);
      }
      SAT["Polygon"] = Polygon;
      Polygon.prototype["setPoints"] = Polygon.prototype.setPoints = function(points) {
        var lengthChanged = !this["points"] || this["points"].length !== points.length;
        if (lengthChanged) {
          var i2;
          var calcPoints = this["calcPoints"] = [];
          var edges = this["edges"] = [];
          var normals = this["normals"] = [];
          for (i2 = 0; i2 < points.length; i2++) {
            var p1 = points[i2];
            var p2 = i2 < points.length - 1 ? points[i2 + 1] : points[0];
            if (p1 !== p2 && p1.x === p2.x && p1.y === p2.y) {
              points.splice(i2, 1);
              i2 -= 1;
              continue;
            }
            calcPoints.push(new Vector());
            edges.push(new Vector());
            normals.push(new Vector());
          }
        }
        this["points"] = points;
        this._recalc();
        return this;
      };
      Polygon.prototype["setAngle"] = Polygon.prototype.setAngle = function(angle) {
        this["angle"] = angle;
        this._recalc();
        return this;
      };
      Polygon.prototype["setOffset"] = Polygon.prototype.setOffset = function(offset) {
        this["offset"] = offset;
        this._recalc();
        return this;
      };
      Polygon.prototype["rotate"] = Polygon.prototype.rotate = function(angle) {
        var points = this["points"];
        var len = points.length;
        for (var i2 = 0; i2 < len; i2++) {
          points[i2].rotate(angle);
        }
        this._recalc();
        return this;
      };
      Polygon.prototype["translate"] = Polygon.prototype.translate = function(x, y) {
        var points = this["points"];
        var len = points.length;
        for (var i2 = 0; i2 < len; i2++) {
          points[i2]["x"] += x;
          points[i2]["y"] += y;
        }
        this._recalc();
        return this;
      };
      Polygon.prototype._recalc = function() {
        var calcPoints = this["calcPoints"];
        var edges = this["edges"];
        var normals = this["normals"];
        var points = this["points"];
        var offset = this["offset"];
        var angle = this["angle"];
        var len = points.length;
        var i2;
        for (i2 = 0; i2 < len; i2++) {
          var calcPoint = calcPoints[i2].copy(points[i2]);
          calcPoint["x"] += offset["x"];
          calcPoint["y"] += offset["y"];
          if (angle !== 0) {
            calcPoint.rotate(angle);
          }
        }
        for (i2 = 0; i2 < len; i2++) {
          var p1 = calcPoints[i2];
          var p2 = i2 < len - 1 ? calcPoints[i2 + 1] : calcPoints[0];
          var e = edges[i2].copy(p2).sub(p1);
          normals[i2].copy(e).perp().normalize();
        }
        return this;
      };
      Polygon.prototype["getAABBAsBox"] = Polygon.prototype.getAABBAsBox = function() {
        var points = this["calcPoints"];
        var len = points.length;
        var xMin = points[0]["x"];
        var yMin = points[0]["y"];
        var xMax = points[0]["x"];
        var yMax = points[0]["y"];
        for (var i2 = 1; i2 < len; i2++) {
          var point = points[i2];
          if (point["x"] < xMin) {
            xMin = point["x"];
          } else if (point["x"] > xMax) {
            xMax = point["x"];
          }
          if (point["y"] < yMin) {
            yMin = point["y"];
          } else if (point["y"] > yMax) {
            yMax = point["y"];
          }
        }
        return new Box(this["pos"].clone().add(new Vector(xMin, yMin)), xMax - xMin, yMax - yMin);
      };
      Polygon.prototype["getAABB"] = Polygon.prototype.getAABB = function() {
        return this.getAABBAsBox().toPolygon();
      };
      Polygon.prototype["getCentroid"] = Polygon.prototype.getCentroid = function() {
        var points = this["calcPoints"];
        var len = points.length;
        var cx = 0;
        var cy = 0;
        var ar = 0;
        for (var i2 = 0; i2 < len; i2++) {
          var p1 = points[i2];
          var p2 = i2 === len - 1 ? points[0] : points[i2 + 1];
          var a = p1["x"] * p2["y"] - p2["x"] * p1["y"];
          cx += (p1["x"] + p2["x"]) * a;
          cy += (p1["y"] + p2["y"]) * a;
          ar += a;
        }
        ar = ar * 3;
        cx = cx / ar;
        cy = cy / ar;
        return new Vector(cx, cy);
      };
      function Box(pos, w, h) {
        this["pos"] = pos || new Vector();
        this["w"] = w || 0;
        this["h"] = h || 0;
      }
      SAT["Box"] = Box;
      Box.prototype["toPolygon"] = Box.prototype.toPolygon = function() {
        var pos = this["pos"];
        var w = this["w"];
        var h = this["h"];
        return new Polygon(new Vector(pos["x"], pos["y"]), [
          new Vector(),
          new Vector(w, 0),
          new Vector(w, h),
          new Vector(0, h)
        ]);
      };
      function Response() {
        this["a"] = null;
        this["b"] = null;
        this["overlapN"] = new Vector();
        this["overlapV"] = new Vector();
        this.clear();
      }
      SAT["Response"] = Response;
      Response.prototype["clear"] = Response.prototype.clear = function() {
        this["aInB"] = true;
        this["bInA"] = true;
        this["overlap"] = Number.MAX_VALUE;
        return this;
      };
      var T_VECTORS = [];
      for (var i = 0; i < 10; i++) {
        T_VECTORS.push(new Vector());
      }
      var T_ARRAYS = [];
      for (var i = 0; i < 5; i++) {
        T_ARRAYS.push([]);
      }
      var T_RESPONSE = new Response();
      var TEST_POINT = new Box(new Vector(), 1e-6, 1e-6).toPolygon();
      function flattenPointsOn(points, normal, result) {
        var min = Number.MAX_VALUE;
        var max = -Number.MAX_VALUE;
        var len = points.length;
        for (var i2 = 0; i2 < len; i2++) {
          var dot = points[i2].dot(normal);
          if (dot < min) {
            min = dot;
          }
          if (dot > max) {
            max = dot;
          }
        }
        result[0] = min;
        result[1] = max;
      }
      function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {
        var rangeA = T_ARRAYS.pop();
        var rangeB = T_ARRAYS.pop();
        var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);
        var projectedOffset = offsetV.dot(axis);
        flattenPointsOn(aPoints, axis, rangeA);
        flattenPointsOn(bPoints, axis, rangeB);
        rangeB[0] += projectedOffset;
        rangeB[1] += projectedOffset;
        if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {
          T_VECTORS.push(offsetV);
          T_ARRAYS.push(rangeA);
          T_ARRAYS.push(rangeB);
          return true;
        }
        if (response) {
          var overlap = 0;
          if (rangeA[0] < rangeB[0]) {
            response["aInB"] = false;
            if (rangeA[1] < rangeB[1]) {
              overlap = rangeA[1] - rangeB[0];
              response["bInA"] = false;
            } else {
              var option1 = rangeA[1] - rangeB[0];
              var option2 = rangeB[1] - rangeA[0];
              overlap = option1 < option2 ? option1 : -option2;
            }
          } else {
            response["bInA"] = false;
            if (rangeA[1] > rangeB[1]) {
              overlap = rangeA[0] - rangeB[1];
              response["aInB"] = false;
            } else {
              var option1 = rangeA[1] - rangeB[0];
              var option2 = rangeB[1] - rangeA[0];
              overlap = option1 < option2 ? option1 : -option2;
            }
          }
          var absOverlap = Math.abs(overlap);
          if (absOverlap < response["overlap"]) {
            response["overlap"] = absOverlap;
            response["overlapN"].copy(axis);
            if (overlap < 0) {
              response["overlapN"].reverse();
            }
          }
        }
        T_VECTORS.push(offsetV);
        T_ARRAYS.push(rangeA);
        T_ARRAYS.push(rangeB);
        return false;
      }
      SAT["isSeparatingAxis"] = isSeparatingAxis;
      function voronoiRegion(line, point) {
        var len2 = line.len2();
        var dp = point.dot(line);
        if (dp < 0) {
          return LEFT_VORONOI_REGION;
        } else if (dp > len2) {
          return RIGHT_VORONOI_REGION;
        } else {
          return MIDDLE_VORONOI_REGION;
        }
      }
      var LEFT_VORONOI_REGION = -1;
      var MIDDLE_VORONOI_REGION = 0;
      var RIGHT_VORONOI_REGION = 1;
      function pointInCircle(p, c) {
        var differenceV = T_VECTORS.pop().copy(p).sub(c["pos"]).sub(c["offset"]);
        var radiusSq = c["r"] * c["r"];
        var distanceSq = differenceV.len2();
        T_VECTORS.push(differenceV);
        return distanceSq <= radiusSq;
      }
      SAT["pointInCircle"] = pointInCircle;
      function pointInPolygon(p, poly) {
        TEST_POINT["pos"].copy(p);
        T_RESPONSE.clear();
        var result = testPolygonPolygon(TEST_POINT, poly, T_RESPONSE);
        if (result) {
          result = T_RESPONSE["aInB"];
        }
        return result;
      }
      SAT["pointInPolygon"] = pointInPolygon;
      function testCircleCircle(a, b, response) {
        var differenceV = T_VECTORS.pop().copy(b["pos"]).add(b["offset"]).sub(a["pos"]).sub(a["offset"]);
        var totalRadius = a["r"] + b["r"];
        var totalRadiusSq = totalRadius * totalRadius;
        var distanceSq = differenceV.len2();
        if (distanceSq > totalRadiusSq) {
          T_VECTORS.push(differenceV);
          return false;
        }
        if (response) {
          var dist = Math.sqrt(distanceSq);
          response["a"] = a;
          response["b"] = b;
          response["overlap"] = totalRadius - dist;
          response["overlapN"].copy(differenceV.normalize());
          response["overlapV"].copy(differenceV).scale(response["overlap"]);
          response["aInB"] = a["r"] <= b["r"] && dist <= b["r"] - a["r"];
          response["bInA"] = b["r"] <= a["r"] && dist <= a["r"] - b["r"];
        }
        T_VECTORS.push(differenceV);
        return true;
      }
      SAT["testCircleCircle"] = testCircleCircle;
      function testPolygonCircle(polygon, circle, response) {
        var circlePos = T_VECTORS.pop().copy(circle["pos"]).add(circle["offset"]).sub(polygon["pos"]);
        var radius = circle["r"];
        var radius2 = radius * radius;
        var points = polygon["calcPoints"];
        var len = points.length;
        var edge = T_VECTORS.pop();
        var point = T_VECTORS.pop();
        for (var i2 = 0; i2 < len; i2++) {
          var next = i2 === len - 1 ? 0 : i2 + 1;
          var prev = i2 === 0 ? len - 1 : i2 - 1;
          var overlap = 0;
          var overlapN = null;
          edge.copy(polygon["edges"][i2]);
          point.copy(circlePos).sub(points[i2]);
          if (response && point.len2() > radius2) {
            response["aInB"] = false;
          }
          var region = voronoiRegion(edge, point);
          if (region === LEFT_VORONOI_REGION) {
            edge.copy(polygon["edges"][prev]);
            var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);
            region = voronoiRegion(edge, point2);
            if (region === RIGHT_VORONOI_REGION) {
              var dist = point.len();
              if (dist > radius) {
                T_VECTORS.push(circlePos);
                T_VECTORS.push(edge);
                T_VECTORS.push(point);
                T_VECTORS.push(point2);
                return false;
              } else if (response) {
                response["bInA"] = false;
                overlapN = point.normalize();
                overlap = radius - dist;
              }
            }
            T_VECTORS.push(point2);
          } else if (region === RIGHT_VORONOI_REGION) {
            edge.copy(polygon["edges"][next]);
            point.copy(circlePos).sub(points[next]);
            region = voronoiRegion(edge, point);
            if (region === LEFT_VORONOI_REGION) {
              var dist = point.len();
              if (dist > radius) {
                T_VECTORS.push(circlePos);
                T_VECTORS.push(edge);
                T_VECTORS.push(point);
                return false;
              } else if (response) {
                response["bInA"] = false;
                overlapN = point.normalize();
                overlap = radius - dist;
              }
            }
          } else {
            var normal = edge.perp().normalize();
            var dist = point.dot(normal);
            var distAbs = Math.abs(dist);
            if (dist > 0 && distAbs > radius) {
              T_VECTORS.push(circlePos);
              T_VECTORS.push(normal);
              T_VECTORS.push(point);
              return false;
            } else if (response) {
              overlapN = normal;
              overlap = radius - dist;
              if (dist >= 0 || overlap < 2 * radius) {
                response["bInA"] = false;
              }
            }
          }
          if (overlapN && response && Math.abs(overlap) < Math.abs(response["overlap"])) {
            response["overlap"] = overlap;
            response["overlapN"].copy(overlapN);
          }
        }
        if (response) {
          response["a"] = polygon;
          response["b"] = circle;
          response["overlapV"].copy(response["overlapN"]).scale(response["overlap"]);
        }
        T_VECTORS.push(circlePos);
        T_VECTORS.push(edge);
        T_VECTORS.push(point);
        return true;
      }
      SAT["testPolygonCircle"] = testPolygonCircle;
      function testCirclePolygon(circle, polygon, response) {
        var result = testPolygonCircle(polygon, circle, response);
        if (result && response) {
          var a = response["a"];
          var aInB = response["aInB"];
          response["overlapN"].reverse();
          response["overlapV"].reverse();
          response["a"] = response["b"];
          response["b"] = a;
          response["aInB"] = response["bInA"];
          response["bInA"] = aInB;
        }
        return result;
      }
      SAT["testCirclePolygon"] = testCirclePolygon;
      function testPolygonPolygon(a, b, response) {
        var aPoints = a["calcPoints"];
        var aLen = aPoints.length;
        var bPoints = b["calcPoints"];
        var bLen = bPoints.length;
        for (var i2 = 0; i2 < aLen; i2++) {
          if (isSeparatingAxis(a["pos"], b["pos"], aPoints, bPoints, a["normals"][i2], response)) {
            return false;
          }
        }
        for (var i2 = 0; i2 < bLen; i2++) {
          if (isSeparatingAxis(a["pos"], b["pos"], aPoints, bPoints, b["normals"][i2], response)) {
            return false;
          }
        }
        if (response) {
          response["a"] = a;
          response["b"] = b;
          response["overlapV"].copy(response["overlapN"]).scale(response["overlap"]);
        }
        return true;
      }
      SAT["testPolygonPolygon"] = testPolygonPolygon;
      return SAT;
    });
  }
});

// node_modules/detect-collisions/dist/model.js
var require_model = __commonJS({
  "node_modules/detect-collisions/dist/model.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BodyType = exports.SATCircle = exports.SATPolygon = exports.SATVector = exports.Response = exports.RBush = void 0;
    var rbush_1 = __importDefault(require_rbush_min());
    Object.defineProperty(exports, "RBush", { enumerable: true, get: function() {
      return rbush_1.default;
    } });
    var sat_1 = require_SAT();
    Object.defineProperty(exports, "Response", { enumerable: true, get: function() {
      return sat_1.Response;
    } });
    Object.defineProperty(exports, "SATVector", { enumerable: true, get: function() {
      return sat_1.Vector;
    } });
    Object.defineProperty(exports, "SATPolygon", { enumerable: true, get: function() {
      return sat_1.Polygon;
    } });
    Object.defineProperty(exports, "SATCircle", { enumerable: true, get: function() {
      return sat_1.Circle;
    } });
    var BodyType;
    (function(BodyType2) {
      BodyType2["Ellipse"] = "Ellipse";
      BodyType2["Line"] = "Line";
      BodyType2["Circle"] = "Circle";
      BodyType2["Box"] = "Box";
      BodyType2["Point"] = "Point";
      BodyType2["Polygon"] = "Polygon";
    })(BodyType || (exports.BodyType = BodyType = {}));
  }
});

// node_modules/detect-collisions/dist/optimized.js
var require_optimized = __commonJS({
  "node_modules/detect-collisions/dist/optimized.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.map = exports.filter = exports.every = exports.some = exports.forEach = void 0;
    var forEach = (array, callback) => {
      for (let i = 0, l = array.length; i < l; i++) {
        callback(array[i], i);
      }
    };
    exports.forEach = forEach;
    var some = (array, callback) => {
      for (let i = 0, l = array.length; i < l; i++) {
        if (callback(array[i], i)) {
          return true;
        }
      }
      return false;
    };
    exports.some = some;
    var every = (array, callback) => {
      for (let i = 0, l = array.length; i < l; i++) {
        if (!callback(array[i], i)) {
          return false;
        }
      }
      return true;
    };
    exports.every = every;
    var filter = (array, callback) => {
      const output = [];
      for (let i = 0, l = array.length; i < l; i++) {
        const item = array[i];
        if (callback(item, i)) {
          output.push(item);
        }
      }
      return output;
    };
    exports.filter = filter;
    var map = (array, callback) => {
      const output = new Array(array.length);
      for (let i = 0, l = array.length; i < l; i++) {
        output[i] = callback(array[i], i);
      }
      return output;
    };
    exports.map = map;
  }
});

// node_modules/detect-collisions/dist/intersect.js
var require_intersect = __commonJS({
  "node_modules/detect-collisions/dist/intersect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.intersectLinePolygon = exports.intersectLineLine = exports.intersectLineLineFast = exports.intersectLineCircle = exports.circleOutsidePolygon = exports.circleInPolygon = exports.circleInCircle = exports.pointOnCircle = exports.polygonInPolygon = exports.pointInPolygon = exports.polygonInCircle = exports.ensureConvex = void 0;
    var sat_1 = require_SAT();
    var model_1 = require_model();
    var optimized_1 = require_optimized();
    function ensureConvex(body) {
      if (body.isConvex || body.type !== model_1.BodyType.Polygon) {
        return [body];
      }
      return body.convexPolygons;
    }
    exports.ensureConvex = ensureConvex;
    function polygonInCircle(polygon, circle) {
      return (0, optimized_1.every)(polygon.calcPoints, (p) => (0, sat_1.pointInCircle)({ x: p.x + polygon.pos.x, y: p.y + polygon.pos.y }, circle));
    }
    exports.polygonInCircle = polygonInCircle;
    function pointInPolygon(point, polygon) {
      return (0, optimized_1.some)(ensureConvex(polygon), (convex) => (0, sat_1.pointInPolygon)(point, convex));
    }
    exports.pointInPolygon = pointInPolygon;
    function polygonInPolygon(polygonA, polygonB) {
      return (0, optimized_1.every)(polygonA.calcPoints, (point) => pointInPolygon({ x: point.x + polygonA.pos.x, y: point.y + polygonA.pos.y }, polygonB));
    }
    exports.polygonInPolygon = polygonInPolygon;
    function pointOnCircle(point, circle) {
      return (point.x - circle.pos.x) * (point.x - circle.pos.x) + (point.y - circle.pos.y) * (point.y - circle.pos.y) === circle.r * circle.r;
    }
    exports.pointOnCircle = pointOnCircle;
    function circleInCircle(a, b) {
      const x1 = a.pos.x;
      const y1 = a.pos.y;
      const x2 = b.pos.x;
      const y2 = b.pos.y;
      const r1 = a.r;
      const r2 = b.r;
      const distSq = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
      return distSq + r2 === r1 || distSq + r2 < r1;
    }
    exports.circleInCircle = circleInCircle;
    function circleInPolygon(circle, polygon) {
      if (circle.r === 0) {
        return false;
      }
      if (!pointInPolygon(circle.pos, polygon)) {
        return false;
      }
      const points = (0, optimized_1.map)(polygon.calcPoints, ({ x, y }) => ({
        x: x + polygon.pos.x,
        y: y + polygon.pos.y
      }));
      if ((0, optimized_1.some)(points, (point) => (0, sat_1.pointInCircle)(point, circle))) {
        return false;
      }
      if ((0, optimized_1.some)(points, (end, index) => {
        const start = index ? points[index - 1] : points[points.length - 1];
        return intersectLineCircle({ start, end }, circle).length > 0;
      })) {
        return false;
      }
      return true;
    }
    exports.circleInPolygon = circleInPolygon;
    function circleOutsidePolygon(circle, polygon) {
      if (circle.r === 0) {
        return false;
      }
      if (pointInPolygon(circle.pos, polygon)) {
        return false;
      }
      const points = (0, optimized_1.map)(polygon.calcPoints, ({ x, y }) => ({
        x: x + polygon.pos.x,
        y: y + polygon.pos.y
      }));
      if ((0, optimized_1.some)(points, (point) => (0, sat_1.pointInCircle)(point, circle) || pointOnCircle(point, circle))) {
        return false;
      }
      if ((0, optimized_1.some)(points, (end, index) => {
        const start = index ? points[index - 1] : points[points.length - 1];
        return intersectLineCircle({ start, end }, circle).length > 0;
      })) {
        return false;
      }
      return true;
    }
    exports.circleOutsidePolygon = circleOutsidePolygon;
    function intersectLineCircle(line, { pos, r }) {
      const v1 = { x: line.end.x - line.start.x, y: line.end.y - line.start.y };
      const v2 = { x: line.start.x - pos.x, y: line.start.y - pos.y };
      const b = (v1.x * v2.x + v1.y * v2.y) * -2;
      const c = (v1.x * v1.x + v1.y * v1.y) * 2;
      const d = Math.sqrt(b * b - (v2.x * v2.x + v2.y * v2.y - r * r) * c * 2);
      if (isNaN(d)) {
        return [];
      }
      const u1 = (b - d) / c;
      const u2 = (b + d) / c;
      const results = [];
      if (u1 <= 1 && u1 >= 0) {
        results.push({ x: line.start.x + v1.x * u1, y: line.start.y + v1.y * u1 });
      }
      if (u2 <= 1 && u2 >= 0) {
        results.push({ x: line.start.x + v1.x * u2, y: line.start.y + v1.y * u2 });
      }
      return results;
    }
    exports.intersectLineCircle = intersectLineCircle;
    function isTurn(point1, point2, point3) {
      const A = (point3.x - point1.x) * (point2.y - point1.y);
      const B = (point2.x - point1.x) * (point3.y - point1.y);
      return A > B + Number.EPSILON ? 1 : A + Number.EPSILON < B ? -1 : 0;
    }
    function intersectLineLineFast(line1, line2) {
      return isTurn(line1.start, line2.start, line2.end) !== isTurn(line1.end, line2.start, line2.end) && isTurn(line1.start, line1.end, line2.start) !== isTurn(line1.start, line1.end, line2.end);
    }
    exports.intersectLineLineFast = intersectLineLineFast;
    function intersectLineLine(line1, line2) {
      const dX = line1.end.x - line1.start.x;
      const dY = line1.end.y - line1.start.y;
      const determinant = dX * (line2.end.y - line2.start.y) - (line2.end.x - line2.start.x) * dY;
      if (determinant === 0) {
        return null;
      }
      const lambda = ((line2.end.y - line2.start.y) * (line2.end.x - line1.start.x) + (line2.start.x - line2.end.x) * (line2.end.y - line1.start.y)) / determinant;
      const gamma = ((line1.start.y - line1.end.y) * (line2.end.x - line1.start.x) + dX * (line2.end.y - line1.start.y)) / determinant;
      if (!(lambda >= 0 && lambda <= 1) || !(gamma >= 0 && gamma <= 1)) {
        return null;
      }
      return { x: line1.start.x + lambda * dX, y: line1.start.y + lambda * dY };
    }
    exports.intersectLineLine = intersectLineLine;
    function intersectLinePolygon(line, polygon) {
      const results = [];
      (0, optimized_1.forEach)(polygon.calcPoints, (to, index) => {
        const from = index ? polygon.calcPoints[index - 1] : polygon.calcPoints[polygon.calcPoints.length - 1];
        const side = {
          start: { x: from.x + polygon.pos.x, y: from.y + polygon.pos.y },
          end: { x: to.x + polygon.pos.x, y: to.y + polygon.pos.y }
        };
        const hit = intersectLineLine(line, side);
        if (hit) {
          results.push(hit);
        }
      });
      return results;
    }
    exports.intersectLinePolygon = intersectLinePolygon;
  }
});

// node_modules/detect-collisions/dist/utils.js
var require_utils = __commonJS({
  "node_modules/detect-collisions/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.drawBVH = exports.drawPolygon = exports.getSATTest = exports.getBounceDirection = exports.mapArrayToVector = exports.mapVectorToArray = exports.dashLineTo = exports.clonePointsArray = exports.checkAInB = exports.intersectAABB = exports.notIntersectAABB = exports.bodyMoved = exports.extendBody = exports.clockwise = exports.distance = exports.ensurePolygonPoints = exports.ensureVectorPoint = exports.createBox = exports.createEllipse = exports.rad2deg = exports.deg2rad = exports.RAD2DEG = exports.DEG2RAD = void 0;
    var sat_1 = require_SAT();
    var intersect_1 = require_intersect();
    var model_1 = require_model();
    var optimized_1 = require_optimized();
    exports.DEG2RAD = Math.PI / 180;
    exports.RAD2DEG = 180 / Math.PI;
    function deg2rad(degrees) {
      return degrees * exports.DEG2RAD;
    }
    exports.deg2rad = deg2rad;
    function rad2deg(radians) {
      return radians * exports.RAD2DEG;
    }
    exports.rad2deg = rad2deg;
    function createEllipse(radiusX, radiusY = radiusX, step = 1) {
      const steps = Math.PI * Math.hypot(radiusX, radiusY) * 2;
      const length = Math.max(8, Math.ceil(steps / Math.max(1, step)));
      return Array.from({ length }, (_, index) => {
        const value = index / length * 2 * Math.PI;
        const x = Math.cos(value) * radiusX;
        const y = Math.sin(value) * radiusY;
        return new sat_1.Vector(x, y);
      });
    }
    exports.createEllipse = createEllipse;
    function createBox(width, height) {
      return [
        new sat_1.Vector(0, 0),
        new sat_1.Vector(width, 0),
        new sat_1.Vector(width, height),
        new sat_1.Vector(0, height)
      ];
    }
    exports.createBox = createBox;
    function ensureVectorPoint(point = {}) {
      return point instanceof sat_1.Vector ? point : new sat_1.Vector(point.x || 0, point.y || 0);
    }
    exports.ensureVectorPoint = ensureVectorPoint;
    function ensurePolygonPoints(points) {
      if (!points) {
        throw new Error("No points array provided");
      }
      const polygonPoints = (0, optimized_1.map)(points, ensureVectorPoint);
      return clockwise(polygonPoints) ? polygonPoints.reverse() : polygonPoints;
    }
    exports.ensurePolygonPoints = ensurePolygonPoints;
    function distance(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }
    exports.distance = distance;
    function clockwise(points) {
      let sum = 0;
      for (let i = 0; i < points.length; i++) {
        const v1 = points[i];
        const v2 = points[(i + 1) % points.length];
        sum += (v2.x - v1.x) * (v2.y + v1.y);
      }
      return sum > 0;
    }
    exports.clockwise = clockwise;
    function extendBody(body, options) {
      body.isStatic = !!(options === null || options === void 0 ? void 0 : options.isStatic);
      body.isTrigger = !!(options === null || options === void 0 ? void 0 : options.isTrigger);
      body.padding = (options === null || options === void 0 ? void 0 : options.padding) || 0;
      if (body.type !== model_1.BodyType.Circle) {
        body.isCentered = (options === null || options === void 0 ? void 0 : options.isCentered) || false;
      }
      body.setAngle((options === null || options === void 0 ? void 0 : options.angle) || 0);
    }
    exports.extendBody = extendBody;
    function bodyMoved(body) {
      return body.bbox.minX < body.minX || body.bbox.minY < body.minY || body.bbox.maxX > body.maxX || body.bbox.maxY > body.maxY;
    }
    exports.bodyMoved = bodyMoved;
    function notIntersectAABB(a, b) {
      return b.minX > a.maxX || b.minY > a.maxY || b.maxX < a.minX || b.maxY < a.minY;
    }
    exports.notIntersectAABB = notIntersectAABB;
    function intersectAABB(a, b) {
      return !notIntersectAABB(a, b);
    }
    exports.intersectAABB = intersectAABB;
    function checkAInB(a, b) {
      if (a.type === model_1.BodyType.Circle) {
        if (b.type !== model_1.BodyType.Circle) {
          return (0, intersect_1.circleInPolygon)(a, b);
        }
        return (0, intersect_1.circleInCircle)(a, b);
      }
      if (b.type === model_1.BodyType.Circle) {
        return (0, intersect_1.polygonInCircle)(a, b);
      }
      return (0, intersect_1.polygonInPolygon)(a, b);
    }
    exports.checkAInB = checkAInB;
    function clonePointsArray(points) {
      return (0, optimized_1.map)(points, ({ x, y }) => ({
        x,
        y
      }));
    }
    exports.clonePointsArray = clonePointsArray;
    function dashLineTo(context, fromX, fromY, toX, toY, dash = 2, gap = 4) {
      const xDiff = toX - fromX;
      const yDiff = toY - fromY;
      const arc = Math.atan2(yDiff, xDiff);
      const offsetX = Math.cos(arc);
      const offsetY = Math.sin(arc);
      let posX = fromX;
      let posY = fromY;
      let dist = Math.hypot(xDiff, yDiff);
      while (dist > 0) {
        const step = Math.min(dist, dash);
        context.moveTo(posX, posY);
        context.lineTo(posX + offsetX * step, posY + offsetY * step);
        posX += offsetX * (dash + gap);
        posY += offsetY * (dash + gap);
        dist -= dash + gap;
      }
    }
    exports.dashLineTo = dashLineTo;
    function mapVectorToArray({ x, y } = { x: 0, y: 0 }) {
      return [x, y];
    }
    exports.mapVectorToArray = mapVectorToArray;
    function mapArrayToVector([x, y] = [0, 0]) {
      return { x, y };
    }
    exports.mapArrayToVector = mapArrayToVector;
    function getBounceDirection(body, collider) {
      const v2 = new sat_1.Vector(collider.x - body.x, collider.y - body.y);
      const v1 = new sat_1.Vector(body.x - collider.x, body.y - collider.y);
      const len = v1.dot(v2.normalize()) * 2;
      return new sat_1.Vector(v2.x * len - v1.x, v2.y * len - v1.y).normalize();
    }
    exports.getBounceDirection = getBounceDirection;
    function getSATTest(body, wall) {
      if (body.type === model_1.BodyType.Circle) {
        return wall.type === model_1.BodyType.Circle ? sat_1.testCircleCircle : sat_1.testCirclePolygon;
      }
      return wall.type === model_1.BodyType.Circle ? sat_1.testPolygonCircle : sat_1.testPolygonPolygon;
    }
    exports.getSATTest = getSATTest;
    function drawPolygon(context, { pos, calcPoints }, isTrigger = false) {
      const lastPoint = calcPoints[calcPoints.length - 1];
      const fromX = pos.x + lastPoint.x;
      const fromY = pos.y + lastPoint.y;
      if (calcPoints.length === 1) {
        context.arc(fromX, fromY, 1, 0, Math.PI * 2);
      } else {
        context.moveTo(fromX, fromY);
      }
      (0, optimized_1.forEach)(calcPoints, (point, index) => {
        const toX = pos.x + point.x;
        const toY = pos.y + point.y;
        if (isTrigger) {
          const prev = calcPoints[index - 1] || lastPoint;
          dashLineTo(context, pos.x + prev.x, pos.y + prev.y, toX, toY);
        } else {
          context.lineTo(toX, toY);
        }
      });
    }
    exports.drawPolygon = drawPolygon;
    function drawBVH(context, body) {
      drawPolygon(context, {
        pos: { x: body.minX, y: body.minY },
        calcPoints: createBox(body.maxX - body.minX, body.maxY - body.minY)
      });
    }
    exports.drawBVH = drawBVH;
  }
});

// node_modules/detect-collisions/dist/bodies/circle.js
var require_circle = __commonJS({
  "node_modules/detect-collisions/dist/bodies/circle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Circle = void 0;
    var sat_1 = require_SAT();
    var model_1 = require_model();
    var utils_1 = require_utils();
    var Circle = class extends sat_1.Circle {
      /**
       * collider - circle
       */
      constructor(position, radius, options) {
        super((0, utils_1.ensureVectorPoint)(position), radius);
        this.offsetCopy = { x: 0, y: 0 };
        this.dirty = false;
        this.isConvex = true;
        this.type = model_1.BodyType.Circle;
        this.isCentered = true;
        (0, utils_1.extendBody)(this, options);
        this.unscaledRadius = radius;
      }
      /**
       * get this.pos.x
       */
      get x() {
        return this.pos.x;
      }
      /**
       * updating this.pos.x by this.x = x updates AABB
       */
      set x(x) {
        this.pos.x = x;
        this.dirty = true;
      }
      /**
       * get this.pos.y
       */
      get y() {
        return this.pos.y;
      }
      /**
       * updating this.pos.y by this.y = y updates AABB
       */
      set y(y) {
        this.pos.y = y;
        this.dirty = true;
      }
      /**
       * allow get scale
       */
      get scale() {
        return this.r / this.unscaledRadius;
      }
      /**
       * shorthand for setScale()
       */
      set scale(scale) {
        this.setScale(scale);
      }
      /**
       * scaleX = scale in case of Circles
       */
      get scaleX() {
        return this.scale;
      }
      /**
       * scaleY = scale in case of Circles
       */
      get scaleY() {
        return this.scale;
      }
      /**
       * update position
       */
      setPosition(x, y, update = true) {
        this.pos.x = x;
        this.pos.y = y;
        this.dirty = true;
        if (update) {
          this.updateBody();
        }
        return this;
      }
      /**
       * update scale
       */
      setScale(scaleX, _scaleY = scaleX, update = true) {
        this.r = this.unscaledRadius * Math.abs(scaleX);
        this.dirty = true;
        if (update) {
          this.updateBody();
        }
        return this;
      }
      /**
       * set rotation
       */
      setAngle(angle, update = true) {
        this.angle = angle;
        const { x, y } = this.getOffsetWithAngle();
        this.offset.x = x;
        this.offset.y = y;
        this.dirty = true;
        if (update) {
          this.updateBody();
        }
        return this;
      }
      /**
       * set offset from center
       */
      setOffset(offset, update = true) {
        this.offsetCopy.x = offset.x;
        this.offsetCopy.y = offset.y;
        const { x, y } = this.getOffsetWithAngle();
        this.offset.x = x;
        this.offset.y = y;
        this.dirty = true;
        if (update) {
          this.updateBody();
        }
        return this;
      }
      /**
       * get body bounding box, without padding
       */
      getAABBAsBBox() {
        const x = this.pos.x + this.offset.x;
        const y = this.pos.y + this.offset.y;
        return {
          minX: x - this.r,
          maxX: x + this.r,
          minY: y - this.r,
          maxY: y + this.r
        };
      }
      /**
       * Draws collider on a CanvasRenderingContext2D's current path
       */
      draw(context) {
        const x = this.pos.x + this.offset.x;
        const y = this.pos.y + this.offset.y;
        const r = Math.abs(this.r);
        if (this.isTrigger) {
          const max = Math.max(8, this.r);
          for (let i = 0; i < max; i++) {
            const arc = i / max * 2 * Math.PI;
            const arcPrev = (i - 1) / max * 2 * Math.PI;
            const fromX = x + Math.cos(arcPrev) * this.r;
            const fromY = y + Math.sin(arcPrev) * this.r;
            const toX = x + Math.cos(arc) * this.r;
            const toY = y + Math.sin(arc) * this.r;
            (0, utils_1.dashLineTo)(context, fromX, fromY, toX, toY);
          }
        } else {
          context.moveTo(x + r, y);
          context.arc(x, y, r, 0, Math.PI * 2);
        }
      }
      /**
       * Draws Bounding Box on canvas context
       */
      drawBVH(context) {
        (0, utils_1.drawBVH)(context, this);
      }
      /**
       * inner function for after position change update aabb in system
       */
      updateBody(update = this.dirty) {
        var _a;
        if (update) {
          (_a = this.system) === null || _a === void 0 ? void 0 : _a.insert(this);
          this.dirty = false;
        }
      }
      /**
       * update instantly or mark as dirty
       */
      markAsDirty(update) {
        if (update) {
          this.updateBody(true);
        } else {
          this.dirty = true;
        }
      }
      /**
       * internal for getting offset with applied angle
       */
      getOffsetWithAngle() {
        if (!this.offsetCopy.x && !this.offsetCopy.y || !this.angle) {
          return this.offsetCopy;
        }
        const sin = Math.sin(this.angle);
        const cos = Math.cos(this.angle);
        const x = this.offsetCopy.x * cos - this.offsetCopy.y * sin;
        const y = this.offsetCopy.x * sin + this.offsetCopy.y * cos;
        return { x, y };
      }
    };
    exports.Circle = Circle;
  }
});

// node_modules/poly-decomp/src/index.js
var require_src = __commonJS({
  "node_modules/poly-decomp/src/index.js"(exports, module) {
    module.exports = {
      decomp: polygonDecomp,
      quickDecomp: polygonQuickDecomp,
      isSimple: polygonIsSimple,
      removeCollinearPoints: polygonRemoveCollinearPoints,
      removeDuplicatePoints: polygonRemoveDuplicatePoints,
      makeCCW: polygonMakeCCW
    };
    function lineInt(l1, l2, precision) {
      precision = precision || 0;
      var i = [0, 0];
      var a1, b1, c1, a2, b2, c2, det;
      a1 = l1[1][1] - l1[0][1];
      b1 = l1[0][0] - l1[1][0];
      c1 = a1 * l1[0][0] + b1 * l1[0][1];
      a2 = l2[1][1] - l2[0][1];
      b2 = l2[0][0] - l2[1][0];
      c2 = a2 * l2[0][0] + b2 * l2[0][1];
      det = a1 * b2 - a2 * b1;
      if (!scalar_eq(det, 0, precision)) {
        i[0] = (b2 * c1 - b1 * c2) / det;
        i[1] = (a1 * c2 - a2 * c1) / det;
      }
      return i;
    }
    function lineSegmentsIntersect(p1, p2, q1, q2) {
      var dx = p2[0] - p1[0];
      var dy = p2[1] - p1[1];
      var da = q2[0] - q1[0];
      var db = q2[1] - q1[1];
      if (da * dy - db * dx === 0) {
        return false;
      }
      var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
      var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);
      return s >= 0 && s <= 1 && t >= 0 && t <= 1;
    }
    function triangleArea(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
    }
    function isLeft(a, b, c) {
      return triangleArea(a, b, c) > 0;
    }
    function isLeftOn(a, b, c) {
      return triangleArea(a, b, c) >= 0;
    }
    function isRight(a, b, c) {
      return triangleArea(a, b, c) < 0;
    }
    function isRightOn(a, b, c) {
      return triangleArea(a, b, c) <= 0;
    }
    var tmpPoint1 = [];
    var tmpPoint2 = [];
    function collinear(a, b, c, thresholdAngle) {
      if (!thresholdAngle) {
        return triangleArea(a, b, c) === 0;
      } else {
        var ab = tmpPoint1, bc = tmpPoint2;
        ab[0] = b[0] - a[0];
        ab[1] = b[1] - a[1];
        bc[0] = c[0] - b[0];
        bc[1] = c[1] - b[1];
        var dot = ab[0] * bc[0] + ab[1] * bc[1], magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]), magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]), angle = Math.acos(dot / (magA * magB));
        return angle < thresholdAngle;
      }
    }
    function sqdist(a, b) {
      var dx = b[0] - a[0];
      var dy = b[1] - a[1];
      return dx * dx + dy * dy;
    }
    function polygonAt(polygon, i) {
      var s = polygon.length;
      return polygon[i < 0 ? i % s + s : i % s];
    }
    function polygonClear(polygon) {
      polygon.length = 0;
    }
    function polygonAppend(polygon, poly, from, to) {
      for (var i = from; i < to; i++) {
        polygon.push(poly[i]);
      }
    }
    function polygonMakeCCW(polygon) {
      var br = 0, v = polygon;
      for (var i = 1; i < polygon.length; ++i) {
        if (v[i][1] < v[br][1] || v[i][1] === v[br][1] && v[i][0] > v[br][0]) {
          br = i;
        }
      }
      if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
        polygonReverse(polygon);
        return true;
      } else {
        return false;
      }
    }
    function polygonReverse(polygon) {
      var tmp = [];
      var N = polygon.length;
      for (var i = 0; i !== N; i++) {
        tmp.push(polygon.pop());
      }
      for (var i = 0; i !== N; i++) {
        polygon[i] = tmp[i];
      }
    }
    function polygonIsReflex(polygon, i) {
      return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));
    }
    var tmpLine1 = [];
    var tmpLine2 = [];
    function polygonCanSee(polygon, a, b) {
      var p, dist, l1 = tmpLine1, l2 = tmpLine2;
      if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {
        return false;
      }
      dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));
      for (var i = 0; i !== polygon.length; ++i) {
        if ((i + 1) % polygon.length === a || i === a) {
          continue;
        }
        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) {
          l1[0] = polygonAt(polygon, a);
          l1[1] = polygonAt(polygon, b);
          l2[0] = polygonAt(polygon, i);
          l2[1] = polygonAt(polygon, i + 1);
          p = lineInt(l1, l2);
          if (sqdist(polygonAt(polygon, a), p) < dist) {
            return false;
          }
        }
      }
      return true;
    }
    function polygonCanSee2(polygon, a, b) {
      for (var i = 0; i !== polygon.length; ++i) {
        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b) {
          continue;
        }
        if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) {
          return false;
        }
      }
      return true;
    }
    function polygonCopy(polygon, i, j, targetPoly) {
      var p = targetPoly || [];
      polygonClear(p);
      if (i < j) {
        for (var k = i; k <= j; k++) {
          p.push(polygon[k]);
        }
      } else {
        for (var k = 0; k <= j; k++) {
          p.push(polygon[k]);
        }
        for (var k = i; k < polygon.length; k++) {
          p.push(polygon[k]);
        }
      }
      return p;
    }
    function polygonGetCutEdges(polygon) {
      var min = [], tmp1 = [], tmp2 = [], tmpPoly = [];
      var nDiags = Number.MAX_VALUE;
      for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(polygon, i)) {
          for (var j = 0; j < polygon.length; ++j) {
            if (polygonCanSee(polygon, i, j)) {
              tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));
              tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));
              for (var k = 0; k < tmp2.length; k++) {
                tmp1.push(tmp2[k]);
              }
              if (tmp1.length < nDiags) {
                min = tmp1;
                nDiags = tmp1.length;
                min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);
              }
            }
          }
        }
      }
      return min;
    }
    function polygonDecomp(polygon) {
      var edges = polygonGetCutEdges(polygon);
      if (edges.length > 0) {
        return polygonSlice(polygon, edges);
      } else {
        return [polygon];
      }
    }
    function polygonSlice(polygon, cutEdges) {
      if (cutEdges.length === 0) {
        return [polygon];
      }
      if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {
        var polys = [polygon];
        for (var i = 0; i < cutEdges.length; i++) {
          var cutEdge = cutEdges[i];
          for (var j = 0; j < polys.length; j++) {
            var poly = polys[j];
            var result = polygonSlice(poly, cutEdge);
            if (result) {
              polys.splice(j, 1);
              polys.push(result[0], result[1]);
              break;
            }
          }
        }
        return polys;
      } else {
        var cutEdge = cutEdges;
        var i = polygon.indexOf(cutEdge[0]);
        var j = polygon.indexOf(cutEdge[1]);
        if (i !== -1 && j !== -1) {
          return [
            polygonCopy(polygon, i, j),
            polygonCopy(polygon, j, i)
          ];
        } else {
          return false;
        }
      }
    }
    function polygonIsSimple(polygon) {
      var path = polygon, i;
      for (i = 0; i < path.length - 1; i++) {
        for (var j = 0; j < i - 1; j++) {
          if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {
            return false;
          }
        }
      }
      for (i = 1; i < path.length - 2; i++) {
        if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {
          return false;
        }
      }
      return true;
    }
    function getIntersectionPoint(p1, p2, q1, q2, delta) {
      delta = delta || 0;
      var a1 = p2[1] - p1[1];
      var b1 = p1[0] - p2[0];
      var c1 = a1 * p1[0] + b1 * p1[1];
      var a2 = q2[1] - q1[1];
      var b2 = q1[0] - q2[0];
      var c2 = a2 * q1[0] + b2 * q1[1];
      var det = a1 * b2 - a2 * b1;
      if (!scalar_eq(det, 0, delta)) {
        return [(b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det];
      } else {
        return [0, 0];
      }
    }
    function polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {
      maxlevel = maxlevel || 100;
      level = level || 0;
      delta = delta || 25;
      result = typeof result !== "undefined" ? result : [];
      reflexVertices = reflexVertices || [];
      steinerPoints = steinerPoints || [];
      var upperInt = [0, 0], lowerInt = [0, 0], p = [0, 0];
      var upperDist = 0, lowerDist = 0, d = 0, closestDist = 0;
      var upperIndex = 0, lowerIndex = 0, closestIndex = 0;
      var lowerPoly = [], upperPoly = [];
      var poly = polygon, v = polygon;
      if (v.length < 3) {
        return result;
      }
      level++;
      if (level > maxlevel) {
        console.warn("quickDecomp: max level (" + maxlevel + ") reached.");
        return result;
      }
      for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(poly, i)) {
          reflexVertices.push(poly[i]);
          upperDist = lowerDist = Number.MAX_VALUE;
          for (var j = 0; j < polygon.length; ++j) {
            if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) {
              p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1));
              if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) {
                d = sqdist(poly[i], p);
                if (d < lowerDist) {
                  lowerDist = d;
                  lowerInt = p;
                  lowerIndex = j;
                }
              }
            }
            if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
              p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));
              if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {
                d = sqdist(poly[i], p);
                if (d < upperDist) {
                  upperDist = d;
                  upperInt = p;
                  upperIndex = j;
                }
              }
            }
          }
          if (lowerIndex === (upperIndex + 1) % polygon.length) {
            p[0] = (lowerInt[0] + upperInt[0]) / 2;
            p[1] = (lowerInt[1] + upperInt[1]) / 2;
            steinerPoints.push(p);
            if (i < upperIndex) {
              polygonAppend(lowerPoly, poly, i, upperIndex + 1);
              lowerPoly.push(p);
              upperPoly.push(p);
              if (lowerIndex !== 0) {
                polygonAppend(upperPoly, poly, lowerIndex, poly.length);
              }
              polygonAppend(upperPoly, poly, 0, i + 1);
            } else {
              if (i !== 0) {
                polygonAppend(lowerPoly, poly, i, poly.length);
              }
              polygonAppend(lowerPoly, poly, 0, upperIndex + 1);
              lowerPoly.push(p);
              upperPoly.push(p);
              polygonAppend(upperPoly, poly, lowerIndex, i + 1);
            }
          } else {
            if (lowerIndex > upperIndex) {
              upperIndex += polygon.length;
            }
            closestDist = Number.MAX_VALUE;
            if (upperIndex < lowerIndex) {
              return result;
            }
            for (var j = lowerIndex; j <= upperIndex; ++j) {
              if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                d = sqdist(polygonAt(poly, i), polygonAt(poly, j));
                if (d < closestDist && polygonCanSee2(poly, i, j)) {
                  closestDist = d;
                  closestIndex = j % polygon.length;
                }
              }
            }
            if (i < closestIndex) {
              polygonAppend(lowerPoly, poly, i, closestIndex + 1);
              if (closestIndex !== 0) {
                polygonAppend(upperPoly, poly, closestIndex, v.length);
              }
              polygonAppend(upperPoly, poly, 0, i + 1);
            } else {
              if (i !== 0) {
                polygonAppend(lowerPoly, poly, i, v.length);
              }
              polygonAppend(lowerPoly, poly, 0, closestIndex + 1);
              polygonAppend(upperPoly, poly, closestIndex, i + 1);
            }
          }
          if (lowerPoly.length < upperPoly.length) {
            polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
            polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
          } else {
            polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
            polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
          }
          return result;
        }
      }
      result.push(polygon);
      return result;
    }
    function polygonRemoveCollinearPoints(polygon, precision) {
      var num = 0;
      for (var i = polygon.length - 1; polygon.length > 3 && i >= 0; --i) {
        if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision)) {
          polygon.splice(i % polygon.length, 1);
          num++;
        }
      }
      return num;
    }
    function polygonRemoveDuplicatePoints(polygon, precision) {
      for (var i = polygon.length - 1; i >= 1; --i) {
        var pi = polygon[i];
        for (var j = i - 1; j >= 0; --j) {
          if (points_eq(pi, polygon[j], precision)) {
            polygon.splice(i, 1);
            continue;
          }
        }
      }
    }
    function scalar_eq(a, b, precision) {
      precision = precision || 0;
      return Math.abs(a - b) <= precision;
    }
    function points_eq(a, b, precision) {
      return scalar_eq(a[0], b[0], precision) && scalar_eq(a[1], b[1], precision);
    }
  }
});

// node_modules/detect-collisions/dist/bodies/polygon.js
var require_polygon = __commonJS({
  "node_modules/detect-collisions/dist/bodies/polygon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Polygon = exports.isSimple = void 0;
    var poly_decomp_1 = require_src();
    Object.defineProperty(exports, "isSimple", { enumerable: true, get: function() {
      return poly_decomp_1.isSimple;
    } });
    var sat_1 = require_SAT();
    var model_1 = require_model();
    var optimized_1 = require_optimized();
    var utils_1 = require_utils();
    var Polygon = class extends sat_1.Polygon {
      /**
       * collider - polygon
       */
      constructor(position, points, options) {
        super((0, utils_1.ensureVectorPoint)(position), (0, utils_1.ensurePolygonPoints)(points));
        this.dirty = false;
        this.type = model_1.BodyType.Polygon;
        this.centered = false;
        this.scaleVector = { x: 1, y: 1 };
        if (!(points === null || points === void 0 ? void 0 : points.length)) {
          throw new Error("No points in polygon");
        }
        (0, utils_1.extendBody)(this, options);
      }
      /**
       * flag to set is polygon centered
       */
      set isCentered(isCentered) {
        if (this.centered === isCentered) {
          return;
        }
        const centroid = this.getCentroidWithoutRotation();
        const x = centroid.x * (isCentered ? 1 : -1);
        const y = centroid.y * (isCentered ? 1 : -1);
        this.translate(-x, -y);
        this.centered = isCentered;
      }
      /**
       * is polygon centered?
       */
      get isCentered() {
        return this.centered;
      }
      get x() {
        return this.pos.x;
      }
      /**
       * updating this.pos.x by this.x = x updates AABB
       */
      set x(x) {
        this.pos.x = x;
        this.dirty = true;
      }
      get y() {
        return this.pos.y;
      }
      /**
       * updating this.pos.y by this.y = y updates AABB
       */
      set y(y) {
        this.pos.y = y;
        this.dirty = true;
      }
      /**
       * allow exact getting of scale x - use setScale(x, y) to set
       */
      get scaleX() {
        return this.scaleVector.x;
      }
      /**
       * allow exact getting of scale y - use setScale(x, y) to set
       */
      get scaleY() {
        return this.scaleVector.y;
      }
      /**
       * allow approx getting of scale
       */
      get scale() {
        return this.scaleVector.x;
      }
      /**
       * allow easier setting of scale
       */
      set scale(scale) {
        this.setScale(scale);
      }
      /**
       * update position
       */
      setPosition(x, y, update = true) {
        this.pos.x = x;
        this.pos.y = y;
        this.markAsDirty(update);
        return this;
      }
      /**
       * update scale
       */
      setScale(x, y = x, update = true) {
        this.scaleVector.x = Math.abs(x);
        this.scaleVector.y = Math.abs(y);
        super.setPoints((0, optimized_1.map)(this.points, (point, index) => {
          point.x = this.pointsBackup[index].x * this.scaleVector.x;
          point.y = this.pointsBackup[index].y * this.scaleVector.y;
          return point;
        }));
        this.markAsDirty(update);
        return this;
      }
      setAngle(angle, update = true) {
        super.setAngle(angle);
        this.markAsDirty(update);
        return this;
      }
      setOffset(offset, update = true) {
        super.setOffset(offset);
        this.markAsDirty(update);
        return this;
      }
      /**
       * get body bounding box, without padding
       */
      getAABBAsBBox() {
        const { pos, w, h } = this.getAABBAsBox();
        return {
          minX: pos.x,
          minY: pos.y,
          maxX: pos.x + w,
          maxY: pos.y + h
        };
      }
      /**
       * Draws exact collider on canvas context
       */
      draw(context) {
        (0, utils_1.drawPolygon)(context, this, this.isTrigger);
      }
      /**
       * Draws Bounding Box on canvas context
       */
      drawBVH(context) {
        (0, utils_1.drawBVH)(context, this);
      }
      /**
       * get body centroid without applied angle
       */
      getCentroidWithoutRotation() {
        const angle = this.angle;
        this.setAngle(0);
        const centroid = this.getCentroid();
        this.setAngle(angle);
        return centroid;
      }
      /**
       * sets polygon points to new array of vectors
       */
      setPoints(points) {
        super.setPoints(points);
        this.updateIsConvex();
        this.pointsBackup = (0, utils_1.clonePointsArray)(points);
        return this;
      }
      /**
       * translates polygon points in x, y direction
       */
      translate(x, y) {
        super.translate(x, y);
        this.pointsBackup = (0, utils_1.clonePointsArray)(this.points);
        return this;
      }
      /**
       * rotates polygon points by angle, in radians
       */
      rotate(angle) {
        super.rotate(angle);
        this.pointsBackup = (0, utils_1.clonePointsArray)(this.points);
        return this;
      }
      /**
       * if true, polygon is not an invalid, self-crossing polygon
       */
      isSimple() {
        return (0, poly_decomp_1.isSimple)(this.calcPoints.map(utils_1.mapVectorToArray));
      }
      /**
       * inner function for after position change update aabb in system and convex inner polygons
       */
      updateBody(update = this.dirty) {
        var _a;
        if (update) {
          this.updateConvexPolygonPositions();
          (_a = this.system) === null || _a === void 0 ? void 0 : _a.insert(this);
          this.dirty = false;
        }
      }
      /**
       * update instantly or mark as dirty
       */
      markAsDirty(update) {
        if (update) {
          this.updateBody(true);
        } else {
          this.dirty = true;
        }
      }
      /**
       * update the position of the decomposed convex polygons (if any), called
       * after the position of the body has changed
       */
      updateConvexPolygonPositions() {
        if (this.isConvex || !this.convexPolygons) {
          return;
        }
        (0, optimized_1.forEach)(this.convexPolygons, (polygon) => {
          polygon.pos.x = this.pos.x;
          polygon.pos.y = this.pos.y;
        });
      }
      /**
       * returns body split into convex polygons, or empty array for convex bodies
       */
      getConvex() {
        if (this.type && this.type !== model_1.BodyType.Polygon || this.points.length < 4) {
          return [];
        }
        const points = (0, optimized_1.map)(this.calcPoints, utils_1.mapVectorToArray);
        return (0, poly_decomp_1.quickDecomp)(points);
      }
      /**
       * updates convex polygons cache in body
       */
      updateConvexPolygons(convex = this.getConvex()) {
        if (this.isConvex) {
          return;
        }
        if (!this.convexPolygons) {
          this.convexPolygons = [];
        }
        (0, optimized_1.forEach)(convex, (points, index) => {
          if (!this.convexPolygons[index]) {
            this.convexPolygons[index] = new sat_1.Polygon();
          }
          this.convexPolygons[index].pos.x = this.pos.x;
          this.convexPolygons[index].pos.y = this.pos.y;
          this.convexPolygons[index].setPoints((0, utils_1.ensurePolygonPoints)((0, optimized_1.map)(points, utils_1.mapArrayToVector)));
        });
        this.convexPolygons.length = convex.length;
      }
      /**
       * after points update set is convex
       */
      updateIsConvex() {
        const convex = this.getConvex();
        this.isConvex = convex.length <= 1;
        this.updateConvexPolygons(convex);
      }
    };
    exports.Polygon = Polygon;
  }
});

// node_modules/detect-collisions/dist/bodies/ellipse.js
var require_ellipse = __commonJS({
  "node_modules/detect-collisions/dist/bodies/ellipse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Ellipse = void 0;
    var model_1 = require_model();
    var utils_1 = require_utils();
    var polygon_1 = require_polygon();
    var Ellipse = class extends polygon_1.Polygon {
      /**
       * collider - ellipse
       */
      constructor(position, radiusX, radiusY = radiusX, step = (radiusX + radiusY) / Math.PI, options) {
        super(position, (0, utils_1.createEllipse)(radiusX, radiusY, step), options);
        this.type = model_1.BodyType.Ellipse;
        this.isConvex = true;
        this._radiusX = radiusX;
        this._radiusY = radiusY;
        this._step = step;
      }
      /**
       * flag to set is body centered
       */
      set isCentered(_isCentered) {
      }
      /**
       * is body centered?
       */
      get isCentered() {
        return true;
      }
      /**
       * get ellipse step number
       */
      get step() {
        return this._step;
      }
      /**
       * set ellipse step number
       */
      set step(step) {
        this._step = step;
        this.setPoints((0, utils_1.createEllipse)(this._radiusX, this._radiusY, this._step));
      }
      /**
       * get ellipse radiusX
       */
      get radiusX() {
        return this._radiusX;
      }
      /**
       * set ellipse radiusX, update points
       */
      set radiusX(radiusX) {
        this._radiusX = radiusX;
        this.setPoints((0, utils_1.createEllipse)(this._radiusX, this._radiusY, this._step));
      }
      /**
       * get ellipse radiusY
       */
      get radiusY() {
        return this._radiusY;
      }
      /**
       * set ellipse radiusY, update points
       */
      set radiusY(radiusY) {
        this._radiusY = radiusY;
        this.setPoints((0, utils_1.createEllipse)(this._radiusX, this._radiusY, this._step));
      }
      /**
       * do not attempt to use Polygon.center()
       */
      center() {
        return;
      }
      /**
       * do not attempt to use Polygon.updateIsConvex()
       */
      updateIsConvex() {
        return;
      }
    };
    exports.Ellipse = Ellipse;
  }
});

// node_modules/detect-collisions/dist/bodies/box.js
var require_box = __commonJS({
  "node_modules/detect-collisions/dist/bodies/box.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Box = void 0;
    var model_1 = require_model();
    var utils_1 = require_utils();
    var polygon_1 = require_polygon();
    var Box = class extends polygon_1.Polygon {
      /**
       * collider - box
       */
      constructor(position, width, height, options) {
        super(position, (0, utils_1.createBox)(width, height), options);
        this.type = model_1.BodyType.Box;
        this.isConvex = true;
        this._width = width;
        this._height = height;
      }
      /**
       * get box width
       */
      get width() {
        return this._width;
      }
      /**
       * set box width, update points
       */
      set width(width) {
        this._width = width;
        this.setPoints((0, utils_1.createBox)(this._width, this._height));
      }
      /**
       * get box height
       */
      get height() {
        return this._height;
      }
      /**
       * set box height, update points
       */
      set height(height) {
        this._height = height;
        this.setPoints((0, utils_1.createBox)(this._width, this._height));
      }
      /**
       * do not attempt to use Polygon.updateIsConvex()
       */
      updateIsConvex() {
        return;
      }
    };
    exports.Box = Box;
  }
});

// node_modules/detect-collisions/dist/bodies/point.js
var require_point = __commonJS({
  "node_modules/detect-collisions/dist/bodies/point.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Point = void 0;
    var model_1 = require_model();
    var utils_1 = require_utils();
    var box_1 = require_box();
    var Point = class extends box_1.Box {
      /**
       * collider - point (very tiny box)
       */
      constructor(position, options) {
        super((0, utils_1.ensureVectorPoint)(position), 1e-3, 1e-3, options);
        this.type = model_1.BodyType.Point;
      }
    };
    exports.Point = Point;
  }
});

// node_modules/detect-collisions/dist/bodies/line.js
var require_line = __commonJS({
  "node_modules/detect-collisions/dist/bodies/line.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Line = void 0;
    var sat_1 = require_SAT();
    var model_1 = require_model();
    var polygon_1 = require_polygon();
    var Line = class extends polygon_1.Polygon {
      /**
       * collider - line from start to end
       */
      constructor(start, end, options) {
        super(start, [
          { x: 0, y: 0 },
          { x: end.x - start.x, y: end.y - start.y }
        ], options);
        this.type = model_1.BodyType.Line;
        this.isConvex = true;
        if (this.calcPoints.length === 1 || !end) {
          console.error({ start, end });
          throw new Error("No end point for line provided");
        }
      }
      get start() {
        return {
          x: this.x + this.calcPoints[0].x,
          y: this.y + this.calcPoints[0].y
        };
      }
      set start({ x, y }) {
        this.x = x;
        this.y = y;
      }
      get end() {
        return {
          x: this.x + this.calcPoints[1].x,
          y: this.y + this.calcPoints[1].y
        };
      }
      set end({ x, y }) {
        this.points[1].x = x - this.start.x;
        this.points[1].y = y - this.start.y;
        this.setPoints(this.points);
      }
      getCentroid() {
        return new sat_1.Vector((this.end.x - this.start.x) / 2, (this.end.y - this.start.y) / 2);
      }
      /**
       * do not attempt to use Polygon.updateIsConvex()
       */
      updateIsConvex() {
        return;
      }
    };
    exports.Line = Line;
  }
});

// node_modules/detect-collisions/dist/base-system.js
var require_base_system = __commonJS({
  "node_modules/detect-collisions/dist/base-system.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseSystem = void 0;
    var box_1 = require_box();
    var circle_1 = require_circle();
    var ellipse_1 = require_ellipse();
    var line_1 = require_line();
    var point_1 = require_point();
    var polygon_1 = require_polygon();
    var model_1 = require_model();
    var optimized_1 = require_optimized();
    var utils_1 = require_utils();
    var BaseSystem = class extends model_1.RBush {
      /**
       * draw exact bodies colliders outline
       */
      draw(context) {
        (0, optimized_1.forEach)(this.all(), (body) => {
          body.draw(context);
        });
      }
      /**
       * draw bounding boxes hierarchy outline
       */
      drawBVH(context) {
        const drawChildren = (body) => {
          (0, utils_1.drawBVH)(context, body);
          if (body.children) {
            (0, optimized_1.forEach)(body.children, drawChildren);
          }
        };
        (0, optimized_1.forEach)(this.data.children, drawChildren);
      }
      /**
       * create point at position with options and add to system
       */
      createPoint(position, options) {
        const point = new point_1.Point(position, options);
        this.insert(point);
        return point;
      }
      /**
       * create line at position with options and add to system
       */
      createLine(start, end, options) {
        const line = new line_1.Line(start, end, options);
        this.insert(line);
        return line;
      }
      /**
       * create circle at position with options and add to system
       */
      createCircle(position, radius, options) {
        const circle = new circle_1.Circle(position, radius, options);
        this.insert(circle);
        return circle;
      }
      /**
       * create box at position with options and add to system
       */
      createBox(position, width, height, options) {
        const box = new box_1.Box(position, width, height, options);
        this.insert(box);
        return box;
      }
      /**
       * create ellipse at position with options and add to system
       */
      createEllipse(position, radiusX, radiusY = radiusX, step, options) {
        const ellipse = new ellipse_1.Ellipse(position, radiusX, radiusY, step, options);
        this.insert(ellipse);
        return ellipse;
      }
      /**
       * create polygon at position with options and add to system
       */
      createPolygon(position, points, options) {
        const polygon = new polygon_1.Polygon(position, points, options);
        this.insert(polygon);
        return polygon;
      }
    };
    exports.BaseSystem = BaseSystem;
  }
});

// node_modules/detect-collisions/dist/system.js
var require_system = __commonJS({
  "node_modules/detect-collisions/dist/system.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.System = void 0;
    var base_system_1 = require_base_system();
    var line_1 = require_line();
    var model_1 = require_model();
    var utils_1 = require_utils();
    var intersect_1 = require_intersect();
    var optimized_1 = require_optimized();
    var System = class extends base_system_1.BaseSystem {
      constructor() {
        super(...arguments);
        this.response = new model_1.Response();
      }
      /**
       * remove body aabb from collision tree
       */
      remove(body, equals) {
        body.system = void 0;
        return super.remove(body, equals);
      }
      /**
       * re-insert body into collision tree and update its aabb
       * every body can be part of only one system
       */
      insert(body) {
        body.bbox = body.getAABBAsBBox();
        if (body.system) {
          if (!(0, utils_1.bodyMoved)(body)) {
            return this;
          }
          body.system.remove(body);
        }
        body.minX = body.bbox.minX - body.padding;
        body.minY = body.bbox.minY - body.padding;
        body.maxX = body.bbox.maxX + body.padding;
        body.maxY = body.bbox.maxY + body.padding;
        body.system = this;
        return super.insert(body);
      }
      /**
       * updates body in collision tree
       */
      updateBody(body) {
        body.updateBody();
      }
      /**
       * update all bodies aabb
       */
      update() {
        (0, optimized_1.forEach)(this.all(), (body) => {
          this.updateBody(body);
        });
      }
      /**
       * separate (move away) colliders
       */
      separate() {
        this.checkAll(({ a, overlapV }) => {
          if (a.isTrigger) {
            return false;
          }
          a.setPosition(a.x - overlapV.x, a.y - overlapV.y);
        });
      }
      /**
       * check one collider collisions with callback
       */
      checkOne(body, callback = () => true, response = this.response) {
        if (body.isStatic) {
          return false;
        }
        const bodies = this.search(body);
        const checkCollision = (candidate) => {
          if (candidate !== body && this.checkCollision(body, candidate, response)) {
            return callback(response);
          }
        };
        return (0, optimized_1.some)(bodies, checkCollision);
      }
      /**
       * check all colliders collisions with callback
       */
      checkAll(callback, response = this.response) {
        const bodies = this.all();
        const checkOne = (body) => {
          return this.checkOne(body, callback, response);
        };
        return (0, optimized_1.some)(bodies, checkOne);
      }
      /**
       * get object potential colliders
       * @deprecated because it's slower to use than checkOne() or checkAll()
       */
      getPotentials(body) {
        return (0, optimized_1.filter)(this.search(body), (candidate) => candidate !== body);
      }
      /**
       * check do 2 objects collide
       */
      checkCollision(bodyA, bodyB, response = this.response) {
        if ((bodyA.padding || bodyB.padding) && (0, utils_1.notIntersectAABB)(bodyA.bbox || bodyA, bodyB.bbox || bodyB)) {
          return false;
        }
        const sat = (0, utils_1.getSATTest)(bodyA, bodyB);
        if (bodyA.isConvex && bodyB.isConvex) {
          response.clear();
          return sat(bodyA, bodyB, response);
        }
        const convexBodiesA = (0, intersect_1.ensureConvex)(bodyA);
        const convexBodiesB = (0, intersect_1.ensureConvex)(bodyB);
        const overlapV = new model_1.SATVector();
        let collided = false;
        (0, optimized_1.forEach)(convexBodiesA, (convexBodyA) => {
          (0, optimized_1.forEach)(convexBodiesB, (convexBodyB) => {
            response.clear();
            if (sat(convexBodyA, convexBodyB, response)) {
              collided = true;
              overlapV.add(response.overlapV);
            }
          });
        });
        if (collided) {
          response.a = bodyA;
          response.b = bodyB;
          response.overlapV = overlapV;
          response.overlapN = overlapV.clone().normalize();
          response.overlap = overlapV.len();
          response.aInB = (0, utils_1.checkAInB)(bodyA, bodyB);
          response.bInA = (0, utils_1.checkAInB)(bodyB, bodyA);
        }
        return collided;
      }
      /**
       * raycast to get collider of ray from start to end
       */
      raycast(start, end, allow = () => true) {
        let minDistance = Infinity;
        let result = null;
        if (!this.ray) {
          this.ray = new line_1.Line(start, end, { isTrigger: true });
        } else {
          this.ray.start = start;
          this.ray.end = end;
        }
        this.insert(this.ray);
        this.checkOne(this.ray, ({ b: body }) => {
          if (!allow(body)) {
            return false;
          }
          const points = body.type === model_1.BodyType.Circle ? (0, intersect_1.intersectLineCircle)(this.ray, body) : (0, intersect_1.intersectLinePolygon)(this.ray, body);
          (0, optimized_1.forEach)(points, (point) => {
            const pointDistance = (0, utils_1.distance)(start, point);
            if (pointDistance < minDistance) {
              minDistance = pointDistance;
              result = { point, body };
            }
          });
        });
        this.remove(this.ray);
        return result;
      }
      /**
       * used to find body deep inside data with finder function returning boolean found or not
       */
      traverse(find, { children } = this.data) {
        return children === null || children === void 0 ? void 0 : children.find((body, index) => {
          if (!body) {
            return false;
          }
          if (body.type && find(body, children, index)) {
            return true;
          }
          if (body.children) {
            this.traverse(find, body);
          }
        });
      }
    };
    exports.System = System;
  }
});

// node_modules/detect-collisions/dist/index.js
var require_dist = __commonJS({
  "node_modules/detect-collisions/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_model(), exports);
    __exportStar(require_circle(), exports);
    __exportStar(require_ellipse(), exports);
    __exportStar(require_polygon(), exports);
    __exportStar(require_box(), exports);
    __exportStar(require_point(), exports);
    __exportStar(require_line(), exports);
    __exportStar(require_system(), exports);
    __exportStar(require_utils(), exports);
    __exportStar(require_intersect(), exports);
  }
});
export default require_dist();
/*! Bundled license information:

sat/SAT.js:
  (** @preserve SAT.js - Version 0.9.0 - Copyright 2012 - 2021 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js *)
*/
//# sourceMappingURL=detect-collisions.js.map
