class UIView {
    constructor() {
        this.state = "created";
        this.host = null;
        this.bindings = [];
        this.views = [];
        this.animations = [];
        this.animationQueue = [];
        this.destroyed = "";
        this.moved = "";
    }
    static create(t, e = {}, i, n = {
        parent: null,
        prepare: true,
        sibling: null
    }) {
        const h = new UIView;
        h.model = e;
        h.element = i ?? t;
        h.parent = n.parent ?? s;
        h.host = n.host ?? h.parent.host;
        if (i instanceof HTMLTemplateElement || i?.tagName === "TEMPLATE") {
            const r = i.content.cloneNode(true);
            if (r.children.length === 1) return s.create(t, e, r.firstElementChild, n);
            h.views = [ ...r.children ].map((i => s.create(t, e, i, {
                ...n,
                parent: h
            })));
            h.state = "rendered";
        } else h.bindings.push(...s.parse(h.element, e, h, n.parent));
        h.parentElement = i != null ? t : t.ownerDocument.documentElement;
        h.sibling = n.sibling;
        if (h.views.length > 1) h.attached = Promise.all(h.views.map((t => t.attached))); else h.attached = new Promise((t => {
            h.attachResolve = t;
        }));
        return h;
    }
    destroy() {
        this.views.forEach((t => t.destroy()));
        this.element.classList.add("pui-removing");
        this.destroyed = "queue";
        s.destroyed.push(this);
    }
    terminate() {
        void Promise.all(this.getAnimations()).then((() => {
            this.element.parentElement?.removeChild(this.element);
            this.bindings.forEach((t => t.unbind()));
            const t = this.parent.views.findIndex((t => t === this));
            if (t > -1) this.parent.views.splice(t, 1);
        }));
        this.destroyed = "destroyed";
    }
    move(t) {
        this.moved = "queue";
        this.element.classList.add("pui-moving");
        this.sibling = t;
    }
    play(t, e) {
        if (typeof t === "string") t = this.animations.find((e => e.name === t)).clone();
        t.element = e;
        t.state = "pending";
        this.animationQueue.push(t);
        this.updateAnimations(performance.now());
        return t;
    }
    updateFromUI() {
        this.views.forEach((t => t.updateFromUI()));
        this.bindings.forEach((t => t.updateFromUI()));
    }
    updateToUI() {
        this.views.forEach((t => t.updateToUI()));
        this.bindings.forEach((t => t.updateToUI()));
        switch (this.state) {
          case "created":
            this.element.classList.add("pui-adding");
            if (!this.element.hasAttribute("PUI-UNRENDERED")) (this.parentElement ?? s.parentElement(this.element, this.parent)).insertBefore(this.element, this.sibling?.nextSibling ?? null);
            this.attachResolve();
            this.state = "attaching";
            break;

          case "attaching":
            if (this.getAnimations(false).length === 0) {
                this.element.classList.remove("pui-adding");
                this.state = "attached";
            }
            break;

          case "attached":
            this.state = "rendered";
            break;
        }
    }
    updateAtEvents() {
        this.views.forEach((t => t.updateAtEvents()));
        this.bindings.forEach((t => t.updateAtEvents()));
    }
    updateAnimations(t) {
        while (this.animationQueue[0]?.state === "finished" ?? false) {
            const t = this.animationQueue.shift();
            t.destroy();
        }
        for (let e = 0; e < this.animationQueue.length; e++) {
            const i = this.animationQueue[e];
            if (i.state !== "pending") continue;
            if (i.isBlocked(t)) continue;
            i.state = "playing";
            i.startTime = t;
            i.animation = i.element.animate(i.keyframes, i.options);
            i.finished = i.animation.finished;
            void i.finished.then((() => {
                i.state = "finished";
                this.updateAnimations(performance.now());
            }));
        }
    }
    updateMove() {
        switch (this.moved) {
          case "queue":
            this.moved = "move";
            break;

          case "move":
            if (this.getAnimations().length === 0) {
                const t = s.parentElement(this.element, this.parent);
                t.insertBefore(this.element, this.sibling.nextSibling);
                this.element.classList.remove("pui-moving");
                this.moved = "";
                this.sibling = null;
            }
            break;
        }
        this.bindings.forEach((t => t.updateMove()));
    }
    getAnimations(t = true) {
        return this.element.getAnimations({
            subtree: t
        }).filter((t => t.playState !== "finished" && t.effect?.getTiming().iterations !== 1 / 0)).map((t => t.finished));
    }
}

class UIBinding {
    constructor() {
        this.fromUI = false;
        this.toUI = true;
        this.atEvent = false;
        this.oneTime = false;
        this.views = [];
        this.firstUpdate = true;
        this.events = [];
        this.triggerAtEvent = t => {
            if (t.type === "change") this.events.push(t); else {
                const e = s.resolveValue(this.object, this.property);
                e.call(this.object.$model, t, this.object.$model, this.element, this.attribute, this.object);
            }
        };
        this.twoWayBindingEvent = t => {
            const {target: e, property: i} = s.resolveProperty(this.object, this.property);
            const n = t.detail;
            if (n !== this.lastUIValue) {
                let t = n;
                if (t !== void 0 && t !== this.lastValue) {
                    if (s.resolveValue(this.object, this.property) === "number" && !isNaN(t)) t = +t;
                    e[i] = t;
                } else e[i] = t;
            }
        };
        this.id = ++s.id;
    }
    get element() {
        if (this.$element == null) this.$element = typeof this.selector === "string" ? this.context.querySelector(this.selector) : this.selector;
        return this.$element;
    }
    set element(t) {
        this.$element = t;
    }
    static create(t) {
        const e = new UIBinding;
        const i = t.property?.split(":") ?? [];
        const n = i.shift();
        e.object = "$model" in t.object ? t.object : {
            $model: t.object
        };
        e.property = n;
        e.arguments = i;
        e.context = t.context ?? document;
        e.selector = t.selector;
        e.attribute = t.attribute ?? "innerText";
        e.value = t.value ?? e.value;
        e.template = t.template ?? e.template;
        e.fromUI = t.fromUI ?? e.fromUI;
        e.toUI = t.toUI ?? e.toUI;
        e.atEvent = t.atEvent ?? e.atEvent;
        e.oneTime = t.oneTime ?? e.oneTime;
        e.parent = t.parent ?? s;
        e.addListener();
        if (typeof e.fromUI !== "boolean") e.fromUI = e.fromUI.bind(e);
        if (typeof e.toUI !== "boolean") e.toUI = e.toUI.bind(e);
        return e;
    }
    destroy() {
        this.element = null;
        this.removeListener();
        this.views.forEach((t => t.destroy()));
    }
    unbind() {
        s.unbind(this);
    }
    addListener() {
        if (this.atEvent) {
            this.toUI = false;
            this.fromUI = false;
            this.element.addEventListener(this.attribute, this.triggerAtEvent);
        }
        if (this.toUI && this.fromUI && customElements.get(this.element.tagName.toLowerCase()) != null) this.element.addEventListener(this.attribute, this.twoWayBindingEvent);
    }
    removeListener() {
        if (this.atEvent) this.element.removeEventListener(this.attribute, this.triggerAtEvent);
        if (this.toUI && this.fromUI && customElements.get(this.element.tagName.toLowerCase()) != null) this.element.removeEventListener(this.attribute, this.twoWayBindingEvent);
    }
    updateFromUI() {
        if (this.fromUI === false || this.firstUpdate) {
            this.firstUpdate = false;
            this.views.forEach((t => t.updateFromUI()));
            return;
        }
        const {target: t, property: e} = s.resolveProperty(this.element, this.attribute);
        const i = t[e];
        if (i !== this.lastUIValue) {
            let t = this.fromUI !== true ? this.fromUI(i, this.lastUIValue, this.property, this.object) : i;
            this.lastUIValue = i;
            if (t !== void 0 && t !== this.lastValue) {
                this.lastValue = t;
                const {target: e, property: i} = s.resolveProperty(this.object, this.property);
                if (s.resolveValue(this.object, this.property) === "number" && !isNaN(t)) t = +t;
                e[i] = t;
            } else this.lastValue = t;
            this.parent.host?.dispatchEvent(new CustomEvent(e, {
                detail: t
            }));
        }
        this.views.forEach((t => t.updateFromUI()));
    }
    updateToUI() {
        if (this.toUI === false) {
            this.views.forEach((t => t.updateToUI()));
            return;
        }
        let t = s.resolveValue(this.object, this.property);
        if (this.template != null) if (this.template instanceof HTMLElement) if (typeof this.attribute === "boolean") {
            t = (t ?? false) === false ? false : true;
            if (t !== this.lastValue) {
                const e = this.toUI !== true ? this.toUI(t, this.lastValue, this.property, this.object, this.value) : t;
                if (e !== void 0 && e !== this.lastUIValue) {
                    if (e === this.attribute) this.views.push(UIView.create(this.element.parentElement, this.object, this.template.cloneNode(true), {
                        parent: this,
                        prepare: false,
                        sibling: this.element
                    })); else {
                        const t = this.views.pop();
                        t?.destroy();
                    }
                    this.lastValue = t;
                    this.lastUIValue = e;
                }
            }
        } else {
            let e = false;
            let i = false;
            if (t == null) t = [];
            const n = this.arguments[0];
            const h = this.lastValue ?? [];
            if (t.length !== h.length) e = true; else for (let r = 0, o = t.length; r < o; r++) {
                let o, l;
                if (n == null) {
                    if (t[r] !== h[r]) {
                        e = true;
                        i = true;
                    }
                } else {
                    o = s.resolveValue(t[r] ?? {}, n);
                    l = s.resolveValue(h[r] ?? {}, n);
                    if (o !== l) e = true;
                    if (t[r] !== h[r]) i = true;
                }
            }
            if (!e) if (!i) return this.updateViews(); else {
                const e = this.toUI !== true ? this.toUI(t, h, this.property, this.object, this.value) : t;
                return this.updateViews(t, e);
            }
            const r = this.toUI !== true ? this.toUI(t, h, this.property, this.object, this.value) : t;
            if (r == null) return this.updateViews();
            const o = this.lastUIValue ?? [];
            let l = 0;
            for (let t = 0, e = r.length, i = 0; t < e; t++, i++) {
                let e, h;
                if (n == null) {
                    e = r[t];
                    h = o[i];
                } else {
                    e = s.resolveValue(r[t] ?? {}, n);
                    h = s.resolveValue(o[i] ?? {}, n);
                }
                if (e === h) l++; else break;
            }
            if (l === r.length && r.length === o.length) return this.updateViews(t, r);
            const u = this.views.splice(0, l);
            let a = u[u.length - 1];
            for (let t = l, e = r.length, i = l; t < e; t++, i++) {
                const e = r[t];
                const i = this.views.shift();
                if (i == null) {
                    const t = {
                        $model: {
                            [this.attribute]: e
                        },
                        $parent: this.object
                    };
                    const i = UIView.create(this.element.parentElement, t, this.template.cloneNode(true), {
                        parent: this,
                        prepare: false,
                        sibling: a?.element ?? this.element
                    });
                    u.push(i);
                    a = i;
                    continue;
                }
                const h = n == null ? e : s.resolveValue(e ?? {}, n);
                const o = i?.model.$model[this.attribute];
                const l = n == null ? o : s.resolveValue(o ?? {}, n);
                if (h === l) {
                    u.push(i);
                    i.move(a?.element ?? this.element);
                    a = i;
                    continue;
                }
                if (!r.slice(t).map((t => n == null ? t : s.resolveValue(t ?? {}, n))).includes(l)) {
                    i.destroy();
                    t--;
                    a = i;
                    continue;
                }
                this.views.unshift(i);
                let c = false;
                for (let t = 0, e = this.views.length; t < e; t++) {
                    const e = this.views[t];
                    const i = e?.model.$model[this.attribute];
                    const r = n == null ? i : s.resolveValue(i ?? {}, n);
                    if (h === r) {
                        u.push(...this.views.splice(t, 1));
                        e.move(a?.element ?? this.element);
                        c = true;
                        a = e;
                        break;
                    }
                }
                if (!c) {
                    const t = {
                        $model: {
                            [this.attribute]: e
                        },
                        $parent: this.object
                    };
                    const i = UIView.create(this.element.parentElement, t, this.template.cloneNode(true), {
                        parent: this,
                        prepare: false,
                        sibling: a?.element ?? this.element
                    });
                    u.push(i);
                    a = i;
                }
            }
            this.views.forEach((t => t.destroy()));
            this.views = u;
            return this.updateViews(t, r);
        } else {
            const e = s.resolveValue(this.object, this.attribute);
            if ((t ?? e) == null || (t ?? e) !== this.lastValue) {
                if (this.lastUIValue != null) {
                    this.lastUIValue.destroy();
                    this.lastUIValue = null;
                }
                const i = t == null ? e : e.create(t);
                const n = e.template;
                this.lastValue = t ?? e;
                const h = this.element.nodeType === 8 ? this.element.parentElement : this.element;
                const r = this.element.nodeType === 8 ? this.element : null;
                this.lastUIValue = s.create(h, i, n, {
                    parent: this,
                    prepare: true,
                    sibling: r
                });
                this.views.push(this.lastUIValue);
            }
        } else if (t !== this.lastValue) {
            const e = this.toUI !== true ? this.toUI(t, this.lastValue, this.property, this.object, this.value) : t;
            if (e !== void 0 && e !== this.lastUIValue) {
                const {target: i, property: n} = s.resolveProperty(this.element, this.attribute);
                i[n] = e;
                if ("setAttribute" in this.element) this.element.setAttribute(this.attribute, e);
                this.lastValue = t;
                this.lastUIValue = e;
            }
        }
        this.updateViews();
    }
    updateAtEvents() {
        let t = this.events.shift();
        while (t != null) {
            const e = s.resolveValue(this.object, this.property);
            e.call(this.object.$model, t, this.object.$model, this.element, this.attribute, this.object);
            t = this.events.shift();
        }
        this.views.forEach((t => t.updateAtEvents()));
    }
    updateMove() {
        this.views.forEach((t => t.updateMove()));
    }
    updateViews(t, e) {
        if (t == null) this.views.forEach((t => t.updateToUI())); else {
            this.views.forEach(((t, i) => {
                const s = e[i];
                if (typeof s === "object") s.$index = i;
                t.model.$model[this.attribute] = s;
                t.model.$index = i;
                t.updateToUI();
            }));
            this.lastValue = [ ...t ];
            this.lastUIValue = [ ...e ];
        }
        if (this.oneTime) {
            this.toUI = false;
            this.fromUI = false;
        }
    }
}

var t;

class _UI {
    static initialize(t = true) {
        if (this.initialized) return;
        this.initialized = true;
        this.initializeLoadPromise();
        if (t === false) return;
        if (t === true) {
            const t = () => {
                this.update();
                requestAnimationFrame(t);
            };
            requestAnimationFrame(t);
            return;
        }
        setInterval((() => this.update()), 1e3 / t);
    }
    static import(t) {
        this.initializeLoadPromise();
        document.body.insertAdjacentHTML(`afterbegin`, `<object type="text/pui" data="${t}"></object>`);
    }
    static ready() {
        this.initialize();
        return this.loadPromise.then((() => {
            if (this.hoist()) document.head.insertAdjacentHTML("beforeend", '<style> object[type="text/pui"] { height: 0; position: absolute; } </style>');
            return this.registrations;
        }));
    }
    static create(t = document.body, e = {}, i = null, n = {
        parent: null,
        prepare: true,
        sibling: null
    }) {
        if (typeof t === "string") t = document.querySelector(t);
        if (typeof e === "string" || e instanceof HTMLElement) {
            console.warn("Old parameter order to UI.create!");
            [e, i] = [ i, e ];
        }
        if (typeof i === "string") {
            const e = t?.ownerDocument?.defaultView != null ? t.ownerDocument : document;
            if (i.startsWith("#")) i = e.querySelector(i); else {
                const t = e.createElement("template");
                t.innerHTML = n.prepare ? this.prepare(i) : i;
                i = t;
            }
        }
        const h = UIView.create(t, e, i, n);
        if (h.parent === s) this.views.push(h);
        this.initialize();
        return h;
    }
    static play(t, e) {
        if (typeof t === "string") {
            t = this.globals.animations.find((e => e.name === t)).clone();
            return t.play(e);
        }
        return t.play();
    }
    static queue(t) {
        this.t.push(t);
    }
    static register(t, e) {
        if (typeof t === "string") {
            this.registrations[t] = e;
            return;
        }
        this.registerWebComponent(e, t);
    }
    static parse(t, e, i, n) {
        const h = [];
        if (t instanceof Comment) return [];
        if (t instanceof HTMLTemplateElement || t.tagName === "TEMPLATE") return [];
        if (t.nodeType === 3) {
            let s = t.textContent;
            let r = s.match(this.regexValue);
            while (r != null) {
                const o = r[1];
                let l = r[2];
                s = r[3];
                let u = false;
                if (l.startsWith("|")) {
                    u = true;
                    l = l.slice(1).trimStart();
                }
                const a = l.match(this.regexConditionalValue);
                let c;
                let f = true;
                if (l.startsWith("(")) {
                    const t = `_pui${this.bindingCounter++}`;
                    Object.defineProperty(e, t, {
                        get: new Function(`return ${l}`)
                    });
                    l = t;
                } else if (a) {
                    l = a[3];
                    c = `${a[2]}${a[1]}`;
                    f = function(t, e, i, s, n) {
                        const h = n[0] === "=";
                        n = n.slice(2, -1);
                        return !!t === h ? n : "";
                    };
                }
                let p = t.cloneNode();
                t.textContent = o;
                this.parentElement(t, n).insertBefore(p, t.nextSibling);
                h.push(this.bind({
                    selector: p,
                    attribute: "textContent",
                    object: e,
                    property: l,
                    parent: i,
                    oneTime: u,
                    value: c,
                    toUI: f
                }));
                t = p;
                p = t.cloneNode();
                p.textContent = s;
                this.parentElement(t, n).insertBefore(p, t.nextSibling);
                t = p;
                r = s.match(this.regexValue);
            }
        } else {
            const r = t.getAttribute("pui") ?? "";
            if (r.trim().length > 0) {
                const e = r.split(";");
                for (let i of e) {
                    i = i.trim();
                    if (i.length > 0) t.setAttribute(`pui.${this.bindingCounter++}`, i);
                }
            }
            t.removeAttribute("pui");
            h.push(...Object.keys(t.attributes ?? []).reverse().map((h => {
                const r = [];
                if (t instanceof Comment) return [];
                const o = t.attributes[h];
                if (o.name.startsWith("pui.")) {
                    const s = o.value.match(this.regexAttribute);
                    let [h, r, l, u, a] = s;
                    let c;
                    let f;
                    let p = false;
                    if (l !== "@") {
                        const i = r.match(/^'(.*?)'$/);
                        if (i != null) {
                            c = i[1];
                            t.setAttribute("value", c);
                            r = t.nodeName.toLowerCase() === "option" ? "selected" : "checked";
                            u = t => t ? c : void 0;
                            l = t => t === c;
                        } else if (r === "") if (u === ">") {
                            const {target: i, property: s} = this.resolveProperty(e, a);
                            i[s] = t;
                            return [];
                        } else {
                            const e = document.createComment(o.name);
                            this.parentNode(t, n).insertBefore(e, t);
                            this.parentNode(t, n).removeChild(t);
                            t.removeAttribute(o.name);
                            f = t;
                            t = e;
                            r = l === "=";
                            l = true;
                            if (u === "|") p = true;
                        } else if (u === "=" && l === "=") {
                            if (!t.tagName.includes("-")) {
                                t.setAttribute("pui-unrendered", "");
                                const e = this.parentNode(t, n);
                                if (e.nodeType !== 8) {
                                    const i = document.createComment(o.name);
                                    e.insertBefore(i, t);
                                    e.removeChild(t);
                                    t.removeAttribute(o.name);
                                    t = i;
                                } else t = e;
                            }
                            f = r;
                            l = true;
                        } else if (u === "*") {
                            const e = document.createComment(o.name);
                            this.parentNode(t, n).insertBefore(e, t);
                            this.parentNode(t, n).removeChild(t);
                            t.removeAttribute(o.name);
                            f = t;
                            t = e;
                        } else if (u === "|") p = true; else if (r !== "checked") t.setAttribute(r, t.getAttribute?.(r) ?? "");
                    }
                    return [ this.bind({
                        selector: t,
                        attribute: r,
                        value: c,
                        object: e,
                        property: a,
                        template: f,
                        toUI: typeof l === "string" ? l === "<" : l,
                        fromUI: typeof u === "string" ? u === ">" : u,
                        atEvent: l === "@",
                        parent: i,
                        oneTime: p
                    }) ];
                }
                const l = [ o.value ];
                let u = 0;
                let a = l[u].match(this.regexValue);
                while (a != null) {
                    let {before: n, property: h, after: c} = a.groups;
                    let f = false;
                    if (h.startsWith("|")) {
                        f = true;
                        h = h.slice(1).trimStart();
                    }
                    const p = h.match(this.regexConditionalValue);
                    let d;
                    if (p) {
                        h = p[3];
                        d = `${p[2]}${p[1]}`;
                    }
                    r.push(this.bind({
                        selector: t,
                        attribute: o.name,
                        object: e,
                        property: h,
                        oneTime: f,
                        toUI(e, i, n, h, r) {
                            if (this.oneTime) {
                                const t = l.indexOf(n);
                                if (t > -1) {
                                    l[t] = s.resolveValue(h, n);
                                    l[t - 1] += l[t] + l[t + 1];
                                    l.splice(t, 2);
                                }
                            }
                            const u = l.map(((t, i) => {
                                if (i % 2 === 0) return t;
                                const o = t.match(s.regexSplitConditionalValue);
                                if (o) {
                                    const i = t === `${n}${r}` ? e : s.resolveValue(h, o[1]);
                                    const l = o[2] === "=";
                                    return !!i === l ? o[3].slice(1, -1) : "";
                                }
                                return t === n ? e : s.resolveValue(h, t);
                            })).join("");
                            t.setAttribute(o.name, u);
                            return u;
                        },
                        parent: i,
                        value: d
                    }));
                    l[u++] = n;
                    l[u++] = `${h}${d ?? ""}`;
                    l[u] = c;
                    a = l[u].match(this.regexValue);
                }
                return r;
            })).flat());
            if (t instanceof Comment) return h.filter((t => {
                if (t.template != null) return true;
                t.unbind();
                return false;
            }));
            if (!this.leaveAttributes) for (let e = Object.keys(t.attributes ?? []).length - 1; e >= 0; e--) {
                const i = t.attributes[Object.keys(t.attributes ?? [])[e]];
                if (i.name.startsWith("pui.")) t.removeAttribute(i.name);
            }
            h.push(...Array.from(t.childNodes).map((t => this.parse(t, e, i, n))).flat());
        }
        return h;
    }
    static bind(t) {
        const e = UIBinding.create(t);
        return e;
    }
    static unbind(t) {
        t.destroy();
        if (t.parent !== s) {
            const e = t.parent.bindings;
            const i = e.indexOf(t);
            if (i > -1) e.splice(i, 1);
        }
    }
    static update() {
        this.i.forEach((t => t()));
        this.i = this.t;
        this.t = [];
        this.views.forEach((t => t.updateToUI()));
        this.views.forEach((t => t.updateFromUI()));
        this.views.forEach((t => t.updateAtEvents()));
        const t = performance.now();
        [ ...this.views, this.globals ].forEach((e => e.updateAnimations(t)));
        this.views.forEach((t => {
            t.updateMove();
        }));
        this.destroyed.forEach((t => {
            switch (t.destroyed) {
              case "queue":
                if (t.state === "rendered") t.destroyed = "destroy"; else t.updateToUI();
                break;

              case "destroy":
                {
                    t.terminate();
                    const e = this.destroyed.findIndex((e => t === e));
                    if (e > -1) this.destroyed.splice(e, 1);
                }
            }
        }));
    }
    static resolveProperty(t, e) {
        e = e.replace("[", ".").replace("]", ".");
        const i = e.split(".").filter((t => (t ?? "").length > 0));
        while (i[0] === "$parent" && t.$parent != null) {
            t = t.$parent;
            i.shift();
        }
        let s = t;
        if (i[0] === "$index" && this.objectHas(s, "$index")) return {
            target: s,
            property: i[0]
        };
        if (this.objectHas(s, "$model")) s = t.$model;
        while (i.length > 1) s = s[i.shift()];
        return {
            target: s,
            property: i[0]
        };
    }
    static resolveValue(t, e) {
        let i = 0;
        do {
            const {target: i, property: s} = this.resolveProperty(t, e);
            if (i != null && this.objectHas(i, s)) return i[s];
            t = t.$parent;
        } while (t != null && i++ < 1e3);
        if (e in this.registrations) return this.registrations[e];
    }
    static initializeLoadPromise() {
        if (this.loadPromise == null) {
            this.loadPromise = new Promise((t => this.loadResolve = t));
            document.defaultView?.addEventListener("load", this.loaded);
        }
    }
    static hoist(t = document, e = document) {
        if (t !== e) {
            (e.querySelectorAll("style") ?? []).forEach((e => {
                t.head.appendChild(e.cloneNode(true));
            }));
            (e.querySelectorAll("template") ?? []).forEach((e => {
                t.head.appendChild(e.cloneNode(true));
            }));
        }
        const i = e.querySelectorAll('object[type="text/pui"]') ?? [];
        let s = i.length > 0;
        i.forEach((e => {
            s = this.hoist(t, e.contentDocument) || s;
        }));
        return s;
    }
    static objectHas(t, e) {
        try {
            return e in t;
        } catch (t) {
            return false;
        }
    }
    static parentElement(t, e) {
        const i = t.parentElement;
        if (i != null) return i;
        while (e != null && (e.element == null || e.element === t)) e = e.parent;
        return e?.element;
    }
    static parentNode(t, e) {
        const i = t.parentNode;
        if (i != null) return i;
        while (e != null && (e.element == null || e.element === t)) e = e.parent;
        return e?.element;
    }
    static prepare(t) {
        let e = t;
        t = "";
        let i = e.match(this.regexReplace);
        while (i != null) {
            const [s, n, h, r] = i;
            if (h.match(/\S\s*===/)) t += `${n.trimEnd()}br PUI.${this.bindingCounter++}="${h}"`; else t += `${n} PUI.${this.bindingCounter++}="${h}" `;
            e = r;
            i = e.match(this.regexReplace);
        }
        t += e;
        return t;
    }
    static parseAttribute(t, e, i, s, n, h) {
        const r = h.match(this.regexAttribute);
        let [o, l, u, a, c] = r;
        let f;
        let p;
        let d = false;
        if (u !== "@") {
            const i = l.match(/^'(.*?)'$/);
            if (i != null) {
                f = i[1];
                t.setAttribute("value", f);
                l = t.nodeName.toLowerCase() === "option" ? "selected" : "checked";
                a = t => t ? f : void 0;
                u = t => t === f;
            } else if (l === "") if (a === ">") {
                const {target: i, property: s} = this.resolveProperty(e, c);
                i[s] = t;
                return [];
            } else {
                const e = document.createComment(n);
                this.parentNode(t, s).insertBefore(e, t);
                this.parentNode(t, s).removeChild(t);
                t.removeAttribute(n);
                p = t;
                t = e;
                l = u === "=";
                u = true;
                if (a === "|") d = true;
            } else if (a === "=" && u === "=") {
                const e = this.parentNode(t, s);
                if (e.nodeType !== 8) {
                    const i = document.createComment(n);
                    e.insertBefore(i, t);
                    e.removeChild(t);
                    t.removeAttribute(n);
                    t = i;
                } else t = e;
                p = l;
                d = true;
                u = true;
            } else if (a === "*") {
                const e = document.createComment(n);
                this.parentNode(t, s).insertBefore(e, t);
                this.parentNode(t, s).removeChild(t);
                t.removeAttribute(n);
                p = t;
                t = e;
            } else if (a === "|") d = true; else if (l !== "checked") t.setAttribute(l, "");
        }
        return [ this.bind({
            selector: t,
            attribute: l,
            value: f,
            object: e,
            property: c,
            template: p,
            toUI: typeof u === "string" ? u === "<" : u,
            fromUI: typeof a === "string" ? a === ">" : a,
            atEvent: u === "@",
            parent: i,
            oneTime: d
        }) ];
    }
    static registerWebComponent(t, e) {
        t ?? (t = e.webComponent);
        class WebComponentWrapper extends HTMLElement {
            constructor() {
                super();
                this.webComponentComponent = e;
                this.webComponentUIView = null;
                this.attachShadow({
                    mode: "open"
                });
            }
            connectedCallback() {
                this.initialize();
            }
            disconnectedCallback() {
                this.terminate();
            }
            attributeChangedCallback(t, e, i) {
                this.initialize();
                this.webComponentUIView.model[t] = i;
            }
            initialize() {
                if (this.webComponentUIView == null) {
                    const t = "create" in this.webComponentComponent ? this.webComponentComponent.create() : new this.webComponentComponent;
                    t.webComponentHost = this;
                    this.webComponentUIView = s.create(this.shadowRoot, t, this.webComponentComponent.template, {
                        host: this.shadowRoot?.host
                    });
                }
            }
            terminate() {
                if (this.webComponentUIView != null) this.webComponentUIView.destroy();
            }
        }
        WebComponentWrapper.observedAttributes = e.observedAttributes ?? [];
        WebComponentWrapper.observedProperties = e.observedProperties ?? WebComponentWrapper.observedAttributes;
        const i = [ ...new Set([ ...WebComponentWrapper.observedAttributes, ...WebComponentWrapper.observedProperties ]) ];
        for (const t of i) Object.defineProperty(WebComponentWrapper.prototype, t, {
            configurable: true,
            enumerable: false,
            get() {
                return this.webComponentUIView.model[t];
            },
            set(e) {
                if (WebComponentWrapper.observedAttributes.includes(t)) this.setAttribute(t, e); else {
                    this.initialize();
                    this.webComponentUIView.model[t] = e;
                }
            }
        });
        customElements.define(t, WebComponentWrapper);
        return WebComponentWrapper;
    }
}

t = _UI;

_UI.initialized = false;

_UI.id = 0;

_UI.views = [];

_UI.destroyed = [];

_UI.globals = new UIView;

_UI.registrations = {};

_UI.leaveAttributes = false;

_UI.regexReplace = /([\S\s]*?)\\?\$\{([^}]*?[<=@!]=[*=>|][^}]*?)\}([\S\s]*)/m;

_UI.regexAttribute = /^\s*(\S*?)\s*([<=@!])=([*=>|])\s*(\S*?)\s*$/;

_UI.regexValue = /(?<before>[\S\s]*?)\\?\$\{\s*(?<property>[\s\S]*?)\s*\}(?<after>[\S\s]*)/m;

_UI.regexConditionalValue = /^\s*(.+?)\s*([=!])\s*(\S+)/;

_UI.regexSplitConditionalValue = /^(.+?)([=!])(.*)/;

_UI.bindingCounter = 0;

_UI.i = [];

_UI.t = [];

_UI.loaded = () => {
    t.loadResolve();
    document.defaultView?.removeEventListener("load", t.loaded);
};

function e() {
    let t = window;
    let e = window;
    while (true) try {
        if (t.parent === t) {
            e = t;
            break;
        } else if (t.parent.UI !== "guarantee-condition-always-true") t = t.parent;
    } catch (t) {
        break;
    }
    return e;
}

const i = e();

if (!("UI" in i)) i.UI = _UI;

const s = i.UI;

export { s as UI, UIView };
//# sourceMappingURL=index.mjs.map
