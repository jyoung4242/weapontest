class UIView {
    constructor() {
        this.state = 'created';
        this.host = null;
        this.bindings = [];
        this.views = [];
        this.animations = [];
        this.animationQueue = [];
        this.destroyed = '';
        this.moved = '';
    }
    static create(parent, model = {}, template, options = { parent: null, prepare: true, sibling: null }) {
        const view = new UIView();
        view.model = model;
        view.element = template ?? parent;
        view.parent = (options.parent ?? UI);
        view.host = options.host ?? view.parent.host;
        if (template instanceof HTMLTemplateElement || template?.tagName === 'TEMPLATE') {
            const content = template.content.cloneNode(true);
            if (content.children.length === 1) {
                return UI.create(parent, model, content.firstElementChild, options);
            }
            view.views = [...content.children].map(child => UI.create(parent, model, child, { ...options, ...{ parent: view } }));
            view.state = 'rendered';
        }
        else {
            view.bindings.push(...UI.parse(view.element, model, view, options.parent));
        }
        view.parentElement = template != null ? parent : parent.ownerDocument.documentElement;
        view.sibling = options.sibling;
        if (view.views.length > 1) {
            view.attached = Promise.all(view.views.map(v => v.attached));
        }
        else {
            view.attached = new Promise((resolve) => {
                view.attachResolve = resolve;
            });
        }
        return view;
    }
    destroy() {
        this.views.forEach(view => view.destroy());
        this.element.classList.add('pui-removing');
        this.destroyed = 'queue';
        UI.destroyed.push(this);
    }
    terminate() {
        void Promise.all(this.getAnimations()).then(() => {
            this.element.parentElement?.removeChild(this.element);
            this.bindings.forEach(binding => binding.unbind());
            const index = this.parent.views.findIndex((view) => view === this);
            if (index > -1) {
                this.parent.views.splice(index, 1);
            }
        });
        this.destroyed = 'destroyed';
    }
    move(sibling) {
        this.moved = 'queue';
        this.element.classList.add('pui-moving');
        this.sibling = sibling;
    }
    play(animation, element) {
        if (typeof animation === 'string') {
            animation = this.animations.find(anim => anim.name === animation).clone();
        }
        animation.element = element;
        animation.state = 'pending';
        this.animationQueue.push(animation);
        this.updateAnimations(performance.now());
        return animation;
    }
    updateFromUI() {
        this.views.forEach(view => view.updateFromUI());
        this.bindings.forEach(binding => binding.updateFromUI());
    }
    updateToUI() {
        this.views.forEach(view => view.updateToUI());
        this.bindings.forEach(binding => binding.updateToUI());
        switch (this.state) {
            case 'created':
                this.element.classList.add('pui-adding');
                if (!this.element.hasAttribute('PUI-UNRENDERED')) {
                    (this.parentElement ?? UI.parentElement(this.element, this.parent)).insertBefore(this.element, this.sibling?.nextSibling ?? null);
                }
                this.attachResolve();
                this.state = 'attaching';
                break;
            case 'attaching':
                if (this.getAnimations(false).length === 0) {
                    this.element.classList.remove('pui-adding');
                    this.state = 'attached';
                }
                break;
            case 'attached':
                this.state = 'rendered';
                break;
        }
    }
    updateAtEvents() {
        this.views.forEach(view => view.updateAtEvents());
        this.bindings.forEach(binding => binding.updateAtEvents());
    }
    updateAnimations(now) {
        while (this.animationQueue[0]?.state === 'finished' ?? false) {
            const finished = this.animationQueue.shift();
            finished.destroy();
        }
        for (let i = 0; i < this.animationQueue.length; i++) {
            const animation = this.animationQueue[i];
            if (animation.state !== 'pending') {
                continue;
            }
            if (animation.isBlocked(now)) {
                continue;
            }
            animation.state = 'playing';
            animation.startTime = now;
            animation.animation = animation.element.animate(animation.keyframes, animation.options);
            animation.finished = animation.animation.finished;
            void animation.finished.then(() => {
                animation.state = 'finished';
                this.updateAnimations(performance.now());
            });
        }
    }
    updateMove() {
        switch (this.moved) {
            case 'queue':
                this.moved = 'move';
                break;
            case 'move':
                if (this.getAnimations().length === 0) {
                    const parent = UI.parentElement(this.element, this.parent);
                    parent.insertBefore(this.element, this.sibling.nextSibling);
                    this.element.classList.remove('pui-moving');
                    this.moved = '';
                    this.sibling = null;
                }
                break;
        }
        this.bindings.forEach(binding => binding.updateMove());
    }
    getAnimations(subtree = true) {
        return this.element.getAnimations({ subtree })
            .filter(animation => animation.playState !== 'finished' && animation.effect?.getTiming().iterations !== Infinity)
            .map(animation => animation.finished);
    }
}

class UIBinding {
    constructor() {
        this.fromUI = false;
        this.toUI = true;
        this.atEvent = false;
        this.oneTime = false;
        this.views = [];
        this.firstUpdate = true;
        this.events = [];
        this.triggerAtEvent = (event) => {
            if (event.type === 'change') {
                this.events.push(event);
            }
            else {
                const callback = UI.resolveValue(this.object, this.property);
                callback.call(this.object.$model, event, this.object.$model, this.element, this.attribute, this.object);
            }
        };
        this.twoWayBindingEvent = (event) => {
            const { target, property } = UI.resolveProperty(this.object, this.property);
            const uiValue = event.detail;
            if (uiValue !== this.lastUIValue) {
                let value = uiValue;
                if (value !== undefined && value !== this.lastValue) {
                    if (UI.resolveValue(this.object, this.property) === 'number' && !isNaN(value)) {
                        value = +value;
                    }
                    target[property] = value;
                }
                else {
                    target[property] = value;
                }
            }
        };
        this.id = ++UI.id;
    }
    get element() {
        if (this.$element == null) {
            this.$element = typeof this.selector === 'string' ? this.context.querySelector(this.selector) : this.selector;
        }
        return this.$element;
    }
    set element(element) {
        this.$element = element;
    }
    static create(options) {
        const binding = new UIBinding();
        const args = options.property?.split(':') ?? [];
        const property = args.shift();
        binding.object = '$model' in options.object ? options.object : { $model: options.object };
        binding.property = property;
        binding.arguments = args;
        binding.context = options.context ?? document;
        binding.selector = options.selector;
        binding.attribute = options.attribute ?? 'innerText';
        binding.value = options.value ?? binding.value;
        binding.template = options.template ?? binding.template;
        binding.fromUI = options.fromUI ?? binding.fromUI;
        binding.toUI = options.toUI ?? binding.toUI;
        binding.atEvent = options.atEvent ?? binding.atEvent;
        binding.oneTime = options.oneTime ?? binding.oneTime;
        binding.parent = options.parent ?? UI;
        binding.addListener();
        if (typeof binding.fromUI !== 'boolean') {
            binding.fromUI = binding.fromUI.bind(binding);
        }
        if (typeof binding.toUI !== 'boolean') {
            binding.toUI = binding.toUI.bind(binding);
        }
        return binding;
    }
    destroy() {
        this.element = null;
        this.removeListener();
        this.views.forEach(view => view.destroy());
    }
    unbind() {
        UI.unbind(this);
    }
    addListener() {
        if (this.atEvent) {
            this.toUI = false;
            this.fromUI = false;
            this.element.addEventListener(this.attribute, this.triggerAtEvent);
        }
        if (this.toUI && this.fromUI && customElements.get(this.element.tagName.toLowerCase()) != null) {
            this.element.addEventListener(this.attribute, this.twoWayBindingEvent);
        }
    }
    removeListener() {
        if (this.atEvent) {
            this.element.removeEventListener(this.attribute, this.triggerAtEvent);
        }
        if (this.toUI && this.fromUI && customElements.get(this.element.tagName.toLowerCase()) != null) {
            this.element.removeEventListener(this.attribute, this.twoWayBindingEvent);
        }
    }
    updateFromUI() {
        if (this.fromUI === false || this.firstUpdate) {
            this.firstUpdate = false;
            this.views.forEach(view => view.updateFromUI());
            return;
        }
        const { target, property } = UI.resolveProperty(this.element, this.attribute);
        const uiValue = target[property];
        if (uiValue !== this.lastUIValue) {
            let value = this.fromUI !== true ? this.fromUI(uiValue, this.lastUIValue, this.property, this.object) : uiValue;
            this.lastUIValue = uiValue;
            if (value !== undefined && value !== this.lastValue) {
                this.lastValue = value;
                const { target, property } = UI.resolveProperty(this.object, this.property);
                if (UI.resolveValue(this.object, this.property) === 'number' && !isNaN(value)) {
                    value = +value;
                }
                target[property] = value;
            }
            else {
                this.lastValue = value;
            }
            this.parent.host?.dispatchEvent(new CustomEvent(property, { detail: value }));
        }
        this.views.forEach(view => view.updateFromUI());
    }
    updateToUI() {
        if (this.toUI === false) {
            this.views.forEach(view => view.updateToUI());
            return;
        }
        let value = UI.resolveValue(this.object, this.property);
        if (this.template != null) {
            if (this.template instanceof HTMLElement) {
                if (typeof this.attribute === 'boolean') {
                    value = (value ?? false) === false ? false : true;
                    if (value !== this.lastValue) {
                        const uiValue = this.toUI !== true ? this.toUI(value, this.lastValue, this.property, this.object, this.value) : value;
                        if (uiValue !== undefined && uiValue !== this.lastUIValue) {
                            if (uiValue === this.attribute) {
                                this.views.push(UIView.create(this.element.parentElement, this.object, this.template.cloneNode(true), { parent: this, prepare: false, sibling: this.element }));
                            }
                            else {
                                const view = this.views.pop();
                                view?.destroy();
                            }
                            this.lastValue = value;
                            this.lastUIValue = uiValue;
                        }
                    }
                }
                else {
                    let listChanged = false;
                    let listItemsChanged = false;
                    if (value == null) {
                        value = [];
                    }
                    const key = this.arguments[0];
                    const lastValue = this.lastValue ?? [];
                    if (value.length !== lastValue.length) {
                        listChanged = true;
                    }
                    else {
                        for (let i = 0, ii = value.length; i < ii; i++) {
                            let v, lv;
                            if (key == null) {
                                if (value[i] !== lastValue[i]) {
                                    listChanged = true;
                                    listItemsChanged = true;
                                }
                            }
                            else {
                                v = UI.resolveValue(value[i] ?? {}, key);
                                lv = UI.resolveValue(lastValue[i] ?? {}, key);
                                if (v !== lv) {
                                    listChanged = true;
                                }
                                if (value[i] !== lastValue[i]) {
                                    listItemsChanged = true;
                                }
                            }
                        }
                    }
                    if (!listChanged) {
                        if (!listItemsChanged) {
                            return this.updateViews();
                        }
                        else {
                            const uiValue = this.toUI !== true ? this.toUI(value, lastValue, this.property, this.object, this.value) : value;
                            return this.updateViews(value, uiValue);
                        }
                    }
                    const uiValue = this.toUI !== true ? this.toUI(value, lastValue, this.property, this.object, this.value) : value;
                    if (uiValue == null) {
                        return this.updateViews();
                    }
                    const lastUIValue = this.lastUIValue ?? [];
                    let same = 0;
                    for (let i = 0, ii = uiValue.length, j = 0; i < ii; i++, j++) {
                        let v, lv;
                        if (key == null) {
                            v = uiValue[i];
                            lv = lastUIValue[j];
                        }
                        else {
                            v = UI.resolveValue(uiValue[i] ?? {}, key);
                            lv = UI.resolveValue(lastUIValue[j] ?? {}, key);
                        }
                        if (v === lv) {
                            same++;
                        }
                        else {
                            break;
                        }
                    }
                    if (same === uiValue.length && uiValue.length === lastUIValue.length) {
                        return this.updateViews(value, uiValue);
                    }
                    const views = this.views.splice(0, same);
                    let lastDoneUI = views[views.length - 1];
                    for (let i = same, ii = uiValue.length, j = same; i < ii; i++, j++) {
                        const item = uiValue[i];
                        const view = this.views.shift();
                        if (view == null) {
                            const model = { $model: { [this.attribute]: item }, $parent: this.object };
                            const view = UIView.create(this.element.parentElement, model, this.template.cloneNode(true), { parent: this, prepare: false, sibling: lastDoneUI?.element ?? this.element });
                            views.push(view);
                            lastDoneUI = view;
                            continue;
                        }
                        const itemKey = key == null ? item : UI.resolveValue(item ?? {}, key);
                        const uiItem = view?.model.$model[this.attribute];
                        const uiItemKey = key == null ? uiItem : UI.resolveValue(uiItem ?? {}, key);
                        if (itemKey === uiItemKey) {
                            views.push(view);
                            view.move(lastDoneUI?.element ?? this.element);
                            lastDoneUI = view;
                            continue;
                        }
                        if (!uiValue.slice(i)
                            .map((value) => key == null ? value : UI.resolveValue(value ?? {}, key))
                            .includes(uiItemKey)) {
                            view.destroy();
                            i--;
                            lastDoneUI = view;
                            continue;
                        }
                        this.views.unshift(view);
                        let found = false;
                        for (let j = 0, jj = this.views.length; j < jj; j++) {
                            const view = this.views[j];
                            const uiItem = view?.model.$model[this.attribute];
                            const uiItemKey = key == null ? uiItem : UI.resolveValue(uiItem ?? {}, key);
                            if (itemKey === uiItemKey) {
                                views.push(...this.views.splice(j, 1));
                                view.move(lastDoneUI?.element ?? this.element);
                                found = true;
                                lastDoneUI = view;
                                break;
                            }
                        }
                        if (!found) {
                            const model = { $model: { [this.attribute]: item }, $parent: this.object };
                            const view = UIView.create(this.element.parentElement, model, this.template.cloneNode(true), { parent: this, prepare: false, sibling: lastDoneUI?.element ?? this.element });
                            views.push(view);
                            lastDoneUI = view;
                        }
                    }
                    this.views.forEach(view => view.destroy());
                    this.views = views;
                    return this.updateViews(value, uiValue);
                }
            }
            else {
                const component = UI.resolveValue(this.object, this.attribute);
                if ((value ?? component) == null || (value ?? component) !== this.lastValue) {
                    if (this.lastUIValue != null) {
                        this.lastUIValue.destroy();
                        this.lastUIValue = null;
                    }
                    const model = value == null ? component : component.create(value);
                    const template = component.template;
                    this.lastValue = value ?? component;
                    const parentElement = this.element.nodeType === 8 ? this.element.parentElement : this.element;
                    const sibling = this.element.nodeType === 8 ? this.element : null;
                    this.lastUIValue = UI.create(parentElement, model, template, { parent: this, prepare: true, sibling });
                    this.views.push(this.lastUIValue);
                }
            }
        }
        else {
            if (value !== this.lastValue) {
                const uiValue = this.toUI !== true ? this.toUI(value, this.lastValue, this.property, this.object, this.value) : value;
                if (uiValue !== undefined && uiValue !== this.lastUIValue) {
                    const { target, property } = UI.resolveProperty(this.element, this.attribute);
                    target[property] = uiValue;
                    if ('setAttribute' in this.element) {
                        this.element.setAttribute(this.attribute, uiValue);
                    }
                    this.lastValue = value;
                    this.lastUIValue = uiValue;
                }
            }
        }
        this.updateViews();
    }
    updateAtEvents() {
        let event = this.events.shift();
        while (event != null) {
            const callback = UI.resolveValue(this.object, this.property);
            callback.call(this.object.$model, event, this.object.$model, this.element, this.attribute, this.object);
            event = this.events.shift();
        }
        this.views.forEach(view => view.updateAtEvents());
    }
    updateMove() {
        this.views.forEach(view => view.updateMove());
    }
    updateViews(value, uiValue) {
        if (value == null) {
            this.views.forEach(view => view.updateToUI());
        }
        else {
            this.views.forEach((view, index) => {
                const item = uiValue[index];
                if (typeof item === 'object') {
                    item.$index = index;
                }
                view.model.$model[this.attribute] = item;
                view.model.$index = index;
                view.updateToUI();
            });
            this.lastValue = [...value];
            this.lastUIValue = [...uiValue];
        }
        if (this.oneTime) {
            this.toUI = false;
            this.fromUI = false;
        }
    }
}

var _a;
class _UI {
    static initialize(rafOrInterval = true) {
        if (this.initialized) {
            return;
        }
        this.initialized = true;
        this.initializeLoadPromise();
        if (rafOrInterval === false) {
            return;
        }
        if (rafOrInterval === true) {
            const tick = () => {
                this.update();
                requestAnimationFrame(tick);
            };
            requestAnimationFrame(tick);
            return;
        }
        setInterval(() => this.update(), 1000 / rafOrInterval);
    }
    static import(src) {
        this.initializeLoadPromise();
        document.body.insertAdjacentHTML(`afterbegin`, `<object type="text/pui" data="${src}"></object>`);
    }
    static ready() {
        this.initialize();
        return this.loadPromise.then(() => {
            if (this.hoist()) {
                document.head.insertAdjacentHTML('beforeend', '<style> object[type="text/pui"] { height: 0; position: absolute; } </style>');
            }
            return this.registrations;
        });
    }
    static create(parent = document.body, model = {}, template = null, options = { parent: null, prepare: true, sibling: null }) {
        if (typeof parent === 'string') {
            parent = document.querySelector(parent);
        }
        if (typeof model === 'string' || model instanceof HTMLElement) {
            console.warn('Old parameter order to UI.create!');
            [model, template] = [template, model];
        }
        if (typeof template === 'string') {
            const doc = parent?.ownerDocument?.defaultView != null ? parent.ownerDocument : document;
            if (template.startsWith('#')) {
                template = doc.querySelector(template);
            }
            else {
                const container = doc.createElement('template');
                container.innerHTML = options.prepare ? this.prepare(template) : template;
                template = container;
            }
        }
        const view = UIView.create(parent, model, template, options);
        if (view.parent === UI) {
            this.views.push(view);
        }
        this.initialize();
        return view;
    }
    static play(animation, element) {
        if (typeof animation === 'string') {
            animation = this.globals.animations.find(anim => anim.name === animation).clone();
            return animation.play(element);
        }
        return animation.play();
    }
    static queue(func) {
        this._nextQueue.push(func);
    }
    static register(nameOrWebComponent, classOrName) {
        if (typeof nameOrWebComponent === 'string') {
            this.registrations[nameOrWebComponent] = classOrName;
            return;
        }
        this.registerWebComponent(classOrName, nameOrWebComponent);
    }
    static parse(element, object, view, parent) {
        const bindings = [];
        if (element instanceof Comment) {
            return [];
        }
        if (element instanceof HTMLTemplateElement || element.tagName === 'TEMPLATE') {
            return [];
        }
        if (element.nodeType === 3) {
            let text = element.textContent;
            let match = text.match(this.regexValue);
            while (match != null) {
                const first = match[1];
                let property = match[2];
                text = match[3];
                let oneTime = false;
                if (property.startsWith('|')) {
                    oneTime = true;
                    property = property.slice(1).trimStart();
                }
                const propertyMatch = property.match(this.regexConditionalValue);
                let value;
                let toUI = true;
                if (property.startsWith('(')) {
                    const newProperty = `_pui${this.bindingCounter++}`;
                    Object.defineProperty(object, newProperty, {
                        get: new Function(`return ${property}`)
                    });
                    property = newProperty;
                }
                else if (propertyMatch) {
                    property = propertyMatch[3];
                    value = `${propertyMatch[2]}${propertyMatch[1]}`;
                    toUI = function (value, _lastValue, property, _object, fixedValue) {
                        const truthy = fixedValue[0] === '=';
                        fixedValue = fixedValue.slice(2, -1);
                        return !!value === truthy ? fixedValue : '';
                    };
                }
                let clone = element.cloneNode();
                element.textContent = first;
                this.parentElement(element, parent).insertBefore(clone, element.nextSibling);
                bindings.push(this.bind({ selector: clone, attribute: 'textContent', object, property, parent: view, oneTime, value, toUI }));
                element = clone;
                clone = element.cloneNode();
                clone.textContent = text;
                this.parentElement(element, parent).insertBefore(clone, element.nextSibling);
                element = clone;
                match = text.match(this.regexValue);
            }
        }
        else {
            const puiAttribute = element.getAttribute('pui') ?? '';
            if (puiAttribute.trim().length > 0) {
                const puiBindings = puiAttribute.split(';');
                for (let puiBinding of puiBindings) {
                    puiBinding = puiBinding.trim();
                    if (puiBinding.length > 0) {
                        element.setAttribute(`pui.${this.bindingCounter++}`, puiBinding);
                    }
                }
            }
            element.removeAttribute('pui');
            bindings.push(...Object.keys(element.attributes ?? []).reverse().map((attribute) => {
                const bindings = [];
                if (element instanceof Comment) {
                    return [];
                }
                const attr = element.attributes[attribute];
                if (attr.name.startsWith('pui.')) {
                    const match = attr.value.match(this.regexAttribute);
                    let [_ignore, name, toUI, fromUI, value] = match;
                    let fixedValue;
                    let template;
                    let oneTime = false;
                    if (toUI !== '@') {
                        const fixed = name.match(/^'(.*?)'$/);
                        if (fixed != null) {
                            fixedValue = fixed[1];
                            element.setAttribute('value', fixedValue);
                            name = element.nodeName.toLowerCase() === 'option' ? 'selected' : 'checked';
                            fromUI = ((value) => value ? fixedValue : undefined);
                            toUI = ((value) => value === fixedValue);
                        }
                        else if (name === '') {
                            if (fromUI === '>') {
                                const { target, property } = this.resolveProperty(object, value);
                                target[property] = element;
                                return [];
                            }
                            else {
                                const comment = document.createComment(attr.name);
                                this.parentNode(element, parent).insertBefore(comment, element);
                                this.parentNode(element, parent).removeChild(element);
                                element.removeAttribute(attr.name);
                                template = element;
                                element = comment;
                                name = (toUI === '=');
                                toUI = true;
                                if (fromUI === '|') {
                                    oneTime = true;
                                }
                            }
                        }
                        else if (fromUI === '=' && toUI === '=') {
                            if (!element.tagName.includes('-')) {
                                element.setAttribute('pui-unrendered', '');
                                const parentNode = this.parentNode(element, parent);
                                if (parentNode.nodeType !== 8) {
                                    const comment = document.createComment(attr.name);
                                    parentNode.insertBefore(comment, element);
                                    parentNode.removeChild(element);
                                    element.removeAttribute(attr.name);
                                    element = comment;
                                }
                                else {
                                    element = parentNode;
                                }
                            }
                            template = name;
                            toUI = true;
                        }
                        else if (fromUI === '*') {
                            const comment = document.createComment(attr.name);
                            this.parentNode(element, parent).insertBefore(comment, element);
                            this.parentNode(element, parent).removeChild(element);
                            element.removeAttribute(attr.name);
                            template = element;
                            element = comment;
                        }
                        else if (fromUI === '|') {
                            oneTime = true;
                        }
                        else if (name !== 'checked') {
                            element.setAttribute(name, element.getAttribute?.(name) ?? '');
                        }
                    }
                    return [this.bind({
                            selector: element, attribute: name, value: fixedValue, object, property: value, template: template,
                            toUI: typeof toUI === 'string' ? toUI === '<' : toUI,
                            fromUI: typeof fromUI === 'string' ? fromUI === '>' : fromUI,
                            atEvent: toUI === '@',
                            parent: view,
                            oneTime,
                        })];
                }
                const parts = [attr.value];
                let index = 0;
                let match = parts[index].match(this.regexValue);
                while (match != null) {
                    let { before, property, after } = match.groups;
                    let oneTime = false;
                    if (property.startsWith('|')) {
                        oneTime = true;
                        property = property.slice(1).trimStart();
                    }
                    const propertyMatch = property.match(this.regexConditionalValue);
                    let value;
                    if (propertyMatch) {
                        property = propertyMatch[3];
                        value = `${propertyMatch[2]}${propertyMatch[1]}`;
                    }
                    bindings.push(this.bind({
                        selector: element,
                        attribute: attr.name,
                        object, property, oneTime,
                        toUI(newValue, _oldValue, name, model, fixedValue) {
                            if (this.oneTime) {
                                const index = parts.indexOf(name);
                                if (index > -1) {
                                    parts[index] = UI.resolveValue(model, name);
                                    parts[index - 1] += parts[index] + parts[index + 1];
                                    parts.splice(index, 2);
                                }
                            }
                            const value = parts.map((part, index) => {
                                if (index % 2 === 0) {
                                    return part;
                                }
                                const match = part.match(UI.regexSplitConditionalValue);
                                if (match) {
                                    const value = part === `${name}${fixedValue}` ? newValue : UI.resolveValue(model, match[1]);
                                    const truthy = match[2] === '=';
                                    return !!value === truthy ? match[3].slice(1, -1) : '';
                                }
                                return part === name ? newValue : UI.resolveValue(model, part);
                            }).join('');
                            element.setAttribute(attr.name, value);
                            return value;
                        },
                        parent: view,
                        value,
                    }));
                    parts[index++] = before;
                    parts[index++] = `${property}${value ?? ''}`;
                    parts[index] = after;
                    match = parts[index].match(this.regexValue);
                }
                return bindings;
            }).flat());
            if (element instanceof Comment) {
                return bindings.filter(binding => {
                    if (binding.template != null) {
                        return true;
                    }
                    binding.unbind();
                    return false;
                });
            }
            if (!this.leaveAttributes) {
                for (let i = Object.keys(element.attributes ?? []).length - 1; i >= 0; i--) {
                    const attr = element.attributes[Object.keys(element.attributes ?? [])[i]];
                    if (attr.name.startsWith('pui.')) {
                        element.removeAttribute(attr.name);
                    }
                }
            }
            bindings.push(...Array.from(element.childNodes).map(child => this.parse(child, object, view, parent)).flat());
        }
        return bindings;
    }
    static bind(options) {
        const binding = UIBinding.create(options);
        return binding;
    }
    static unbind(binding) {
        binding.destroy();
        if (binding.parent !== UI) {
            const bindings = binding.parent.bindings;
            const index = bindings.indexOf(binding);
            if (index > -1) {
                bindings.splice(index, 1);
            }
        }
    }
    static update() {
        this._queue.forEach(item => item());
        this._queue = this._nextQueue;
        this._nextQueue = [];
        this.views.forEach(view => view.updateToUI());
        this.views.forEach(view => view.updateFromUI());
        this.views.forEach(view => view.updateAtEvents());
        const now = performance.now();
        [...this.views, this.globals].forEach(view => view.updateAnimations(now));
        this.views.forEach(view => {
            view.updateMove();
        });
        this.destroyed.forEach(view => {
            switch (view.destroyed) {
                case 'queue':
                    if (view.state === 'rendered') {
                        view.destroyed = 'destroy';
                    }
                    else {
                        view.updateToUI();
                    }
                    break;
                case 'destroy': {
                    view.terminate();
                    const index = this.destroyed.findIndex(destroyed => view === destroyed);
                    if (index > -1) {
                        this.destroyed.splice(index, 1);
                    }
                }
            }
        });
    }
    static resolveProperty(object, property) {
        property = property.replace('[', '.').replace(']', '.');
        const properties = property.split('.').filter(prop => (prop ?? '').length > 0);
        while (properties[0] === '$parent' && object.$parent != null) {
            object = object.$parent;
            properties.shift();
        }
        let target = object;
        if (properties[0] === '$index' && this.objectHas(target, '$index')) {
            return { target, property: properties[0] };
        }
        if (this.objectHas(target, '$model')) {
            target = object.$model;
        }
        while (properties.length > 1) {
            target = target[properties.shift()];
        }
        return { target, property: properties[0] };
    }
    static resolveValue(object, prop) {
        let guard = 0;
        do {
            const { target, property } = this.resolveProperty(object, prop);
            if (target != null && this.objectHas(target, property)) {
                return target[property];
            }
            object = object.$parent;
        } while (object != null && guard++ < 1000);
        if (prop in this.registrations) {
            return this.registrations[prop];
        }
    }
    static initializeLoadPromise() {
        if (this.loadPromise == null) {
            this.loadPromise = new Promise(res => this.loadResolve = res);
            document.defaultView?.addEventListener('load', this.loaded);
        }
    }
    static hoist(to = document, doc = document) {
        if (to !== doc) {
            (doc.querySelectorAll('style') ?? []).forEach(style => {
                to.head.appendChild(style.cloneNode(true));
            });
            (doc.querySelectorAll('template') ?? []).forEach(template => {
                to.head.appendChild(template.cloneNode(true));
            });
        }
        const components = doc.querySelectorAll('object[type="text/pui"]') ?? [];
        let hoisted = components.length > 0;
        components.forEach(component => {
            hoisted = this.hoist(to, component.contentDocument) || hoisted;
        });
        return hoisted;
    }
    static objectHas(target, property) {
        try {
            return property in target;
        }
        catch (e) {
            return false;
        }
    }
    static parentElement(element, parent) {
        const parentElement = element.parentElement;
        if (parentElement != null) {
            return parentElement;
        }
        while (parent != null && (parent.element == null || parent.element === element)) {
            parent = parent.parent;
        }
        return parent?.element;
    }
    static parentNode(element, parent) {
        const parentNode = element.parentNode;
        if (parentNode != null) {
            return parentNode;
        }
        while (parent != null && (parent.element == null || parent.element === element)) {
            parent = parent.parent;
        }
        return parent?.element;
    }
    static prepare(template) {
        let remaining = template;
        template = '';
        let match = remaining.match(this.regexReplace);
        while (match != null) {
            const [_ignore, before, binding, after] = match;
            if (binding.match(/\S\s*===/)) {
                template += `${before.trimEnd()}br PUI.${this.bindingCounter++}="${binding}"`;
            }
            else {
                template += `${before} PUI.${this.bindingCounter++}="${binding}" `;
            }
            remaining = after;
            match = remaining.match(this.regexReplace);
        }
        template += remaining;
        return template;
    }
    static parseAttribute(element, object, view, parent, attrName, attrValue) {
        const match = attrValue.match(this.regexAttribute);
        let [_ignore, name, toUI, fromUI, value] = match;
        let fixedValue;
        let template;
        let oneTime = false;
        if (toUI !== '@') {
            const fixed = name.match(/^'(.*?)'$/);
            if (fixed != null) {
                fixedValue = fixed[1];
                element.setAttribute('value', fixedValue);
                name = element.nodeName.toLowerCase() === 'option' ? 'selected' : 'checked';
                fromUI = ((value) => value ? fixedValue : undefined);
                toUI = ((value) => value === fixedValue);
            }
            else if (name === '') {
                if (fromUI === '>') {
                    const { target, property } = this.resolveProperty(object, value);
                    target[property] = element;
                    return [];
                }
                else {
                    const comment = document.createComment(attrName);
                    this.parentNode(element, parent).insertBefore(comment, element);
                    this.parentNode(element, parent).removeChild(element);
                    element.removeAttribute(attrName);
                    template = element;
                    element = comment;
                    name = (toUI === '=');
                    toUI = true;
                    if (fromUI === '|') {
                        oneTime = true;
                    }
                }
            }
            else if (fromUI === '=' && toUI === '=') {
                const parentNode = this.parentNode(element, parent);
                if (parentNode.nodeType !== 8) {
                    const comment = document.createComment(attrName);
                    parentNode.insertBefore(comment, element);
                    parentNode.removeChild(element);
                    element.removeAttribute(attrName);
                    element = comment;
                }
                else {
                    element = parentNode;
                }
                template = name;
                oneTime = true;
                toUI = true;
            }
            else if (fromUI === '*') {
                const comment = document.createComment(attrName);
                this.parentNode(element, parent).insertBefore(comment, element);
                this.parentNode(element, parent).removeChild(element);
                element.removeAttribute(attrName);
                template = element;
                element = comment;
            }
            else if (fromUI === '|') {
                oneTime = true;
            }
            else if (name !== 'checked') {
                element.setAttribute(name, '');
            }
        }
        return [this.bind({
                selector: element, attribute: name, value: fixedValue, object, property: value, template: template,
                toUI: typeof toUI === 'string' ? toUI === '<' : toUI,
                fromUI: typeof fromUI === 'string' ? fromUI === '>' : fromUI,
                atEvent: toUI === '@',
                parent: view,
                oneTime,
            })];
    }
    static registerWebComponent(name, component) {
        name ?? (name = component.webComponent);
        class WebComponentWrapper extends HTMLElement {
            constructor() {
                super();
                this.webComponentComponent = component;
                this.webComponentUIView = null;
                this.attachShadow({ mode: 'open' });
            }
            connectedCallback() {
                this.initialize();
            }
            disconnectedCallback() {
                this.terminate();
            }
            attributeChangedCallback(name, oldVal, newVal) {
                this.initialize();
                this.webComponentUIView.model[name] = newVal;
            }
            initialize() {
                if (this.webComponentUIView == null) {
                    const component = 'create' in this.webComponentComponent ? this.webComponentComponent.create() : new this.webComponentComponent();
                    component.webComponentHost = this;
                    this.webComponentUIView = UI.create(this.shadowRoot, component, this.webComponentComponent.template, { host: this.shadowRoot?.host });
                }
            }
            terminate() {
                if (this.webComponentUIView != null) {
                    this.webComponentUIView.destroy();
                }
            }
        }
        WebComponentWrapper.observedAttributes = component.observedAttributes ?? [];
        WebComponentWrapper.observedProperties = component.observedProperties ?? WebComponentWrapper.observedAttributes;
        const properties = [...new Set([...WebComponentWrapper.observedAttributes, ...WebComponentWrapper.observedProperties])];
        for (const property of properties) {
            Object.defineProperty(WebComponentWrapper.prototype, property, {
                configurable: true,
                enumerable: false,
                get() {
                    return this.webComponentUIView.model[property];
                },
                set(v) {
                    if (WebComponentWrapper.observedAttributes.includes(property)) {
                        this.setAttribute(property, v);
                    }
                    else {
                        this.initialize();
                        this.webComponentUIView.model[property] = v;
                    }
                }
            });
        }
        customElements.define(name, WebComponentWrapper);
        return WebComponentWrapper;
    }
}
_a = _UI;
_UI.initialized = false;
_UI.id = 0;
_UI.views = [];
_UI.destroyed = [];
_UI.globals = new UIView();
_UI.registrations = {};
_UI.leaveAttributes = false;
_UI.regexReplace = /([\S\s]*?)\\?\$\{([^}]*?[<=@!]=[*=>|][^}]*?)\}([\S\s]*)/m;
_UI.regexAttribute = /^\s*(\S*?)\s*([<=@!])=([*=>|])\s*(\S*?)\s*$/;
_UI.regexValue = /(?<before>[\S\s]*?)\\?\$\{\s*(?<property>[\s\S]*?)\s*\}(?<after>[\S\s]*)/m;
_UI.regexConditionalValue = /^\s*(.+?)\s*([=!])\s*(\S+)/;
_UI.regexSplitConditionalValue = /^(.+?)([=!])(.*)/;
_UI.bindingCounter = 0;
_UI._queue = [];
_UI._nextQueue = [];
_UI.loaded = () => {
    _a.loadResolve();
    document.defaultView?.removeEventListener('load', _a.loaded);
};
function getTopWindow() {
    let current = window;
    let top = window;
    while (true) {
        try {
            if (current.parent === current) {
                top = current;
                break;
            }
            else {
                if (current.parent.UI !== 'guarantee-condition-always-true') {
                    current = current.parent;
                }
            }
        }
        catch (e) {
            break;
        }
    }
    return top;
}
const topWindow = getTopWindow();
if (!('UI' in topWindow)) {
    topWindow.UI = _UI;
}
const UI = topWindow.UI;

export { UI, UIView };
//# sourceMappingURL=index.dev.mjs.map
