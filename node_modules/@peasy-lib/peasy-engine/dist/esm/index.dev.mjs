class Engine {
    constructor(interval, callback) {
        this.interval = interval;
        this.callback = callback;
        this.started = false;
        this.paused = false;
        this.destroyed = false;
        this.lastTime = 0;
        this.resetThreshold = 1000;
        this.timeSinceLast = 0;
        this.accTime = 0;
        this.oneTime = false;
        this.isolated = false;
        this.doStart = (timestamp) => {
            this.started = true;
            this.startTime = timestamp;
            this.lastTime = timestamp;
            this.accTime = 0;
            requestAnimationFrame(this.tick);
        };
        this.tick = (timestamp) => {
            if (!this.started || this.paused) {
                return;
            }
            const deltaTime = timestamp - this.lastTime;
            this.lastTime = timestamp;
            if (deltaTime > this.resetThreshold) {
                console.log(`Too long since last tick: ${deltaTime}ms. Resetting.`);
                this.timeSinceLast = 0;
                requestAnimationFrame(this.tick);
                return;
            }
            this.timeSinceLast += deltaTime;
            const result = this.call();
            if (result instanceof Promise) {
                void result.then(() => requestAnimationFrame(this.tick));
            }
            else {
                requestAnimationFrame(this.tick);
            }
        };
        this.call = () => {
            if (this.timeSinceLast >= this.interval) {
                const result = this.callback(this.interval, this.accTime);
                this.accTime += this.interval;
                this.timeSinceLast -= this.interval;
                if (this.oneTime) {
                    this.destroy();
                }
                if (result instanceof Promise) {
                    return result.then(() => this.call());
                }
                else {
                    void this.call();
                }
                return true;
            }
            return false;
        };
    }
    static create(options) {
        if (typeof options === 'function') {
            options = { callback: options };
        }
        const interval = options.ms ?? 1000 / (options.fps ?? 60);
        const engine = new Engine(interval, options.callback);
        engine.resetThreshold = options.resetThreshold ?? engine.resetThreshold;
        engine.oneTime = options.oneTime ?? engine.oneTime;
        engine.isolated = options.isolated ?? engine.isolated;
        if (!engine.isolated) {
            Engine.engines.push(engine);
        }
        if (options.started ?? true) {
            engine.start();
        }
        return engine;
    }
    static start() {
        return Engine.engines.map(engine => engine.start());
    }
    static stop() {
        return Engine.engines.map(engine => engine.stop());
    }
    static pause() {
        return Engine.engines.map(engine => engine.pause());
    }
    static destroy() {
        Engine.engines.forEach(engine => engine.destroy());
    }
    start() {
        if (this.started && !this.paused) {
            return false;
        }
        requestAnimationFrame(this.paused ? this.tick : this.doStart);
        this.paused = false;
        return true;
    }
    stop() {
        if (!this.started) {
            return false;
        }
        this.started = false;
        this.paused = false;
        return true;
    }
    pause() {
        if (!this.started) {
            return false;
        }
        this.paused = true;
        return true;
    }
    destroy() {
        this.destroyed = true;
        this.stop();
        const index = Engine.engines.indexOf(this);
        if (index >= 0) {
            Engine.engines.splice(index, 1);
        }
    }
}
Engine.engines = [];

export { Engine };
//# sourceMappingURL=index.dev.mjs.map
