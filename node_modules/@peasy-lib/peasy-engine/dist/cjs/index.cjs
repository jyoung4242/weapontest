"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

class Engine {
    constructor(t, s) {
        this.interval = t;
        this.callback = s;
        this.started = false;
        this.paused = false;
        this.destroyed = false;
        this.lastTime = 0;
        this.resetThreshold = 1e3;
        this.timeSinceLast = 0;
        this.accTime = 0;
        this.oneTime = false;
        this.isolated = false;
        this.doStart = t => {
            this.started = true;
            this.startTime = t;
            this.lastTime = t;
            this.accTime = 0;
            requestAnimationFrame(this.tick);
        };
        this.tick = t => {
            if (!this.started || this.paused) return;
            const s = t - this.lastTime;
            this.lastTime = t;
            if (s > this.resetThreshold) {
                console.log(`Too long since last tick: ${s}ms. Resetting.`);
                this.timeSinceLast = 0;
                requestAnimationFrame(this.tick);
                return;
            }
            this.timeSinceLast += s;
            const i = this.call();
            if (i instanceof Promise) void i.then((() => requestAnimationFrame(this.tick))); else requestAnimationFrame(this.tick);
        };
        this.call = () => {
            if (this.timeSinceLast >= this.interval) {
                const t = this.callback(this.interval, this.accTime);
                this.accTime += this.interval;
                this.timeSinceLast -= this.interval;
                if (this.oneTime) this.destroy();
                if (t instanceof Promise) return t.then((() => this.call())); else void this.call();
                return true;
            }
            return false;
        };
    }
    static create(t) {
        if (typeof t === "function") t = {
            callback: t
        };
        const s = t.ms ?? 1e3 / (t.fps ?? 60);
        const i = new Engine(s, t.callback);
        i.resetThreshold = t.resetThreshold ?? i.resetThreshold;
        i.oneTime = t.oneTime ?? i.oneTime;
        i.isolated = t.isolated ?? i.isolated;
        if (!i.isolated) Engine.engines.push(i);
        if (t.started ?? true) i.start();
        return i;
    }
    static start() {
        return Engine.engines.map((t => t.start()));
    }
    static stop() {
        return Engine.engines.map((t => t.stop()));
    }
    static pause() {
        return Engine.engines.map((t => t.pause()));
    }
    static destroy() {
        Engine.engines.forEach((t => t.destroy()));
    }
    start() {
        if (this.started && !this.paused) return false;
        requestAnimationFrame(this.paused ? this.tick : this.doStart);
        this.paused = false;
        return true;
    }
    stop() {
        if (!this.started) return false;
        this.started = false;
        this.paused = false;
        return true;
    }
    pause() {
        if (!this.started) return false;
        this.paused = true;
        return true;
    }
    destroy() {
        this.destroyed = true;
        this.stop();
        const t = Engine.engines.indexOf(this);
        if (t >= 0) Engine.engines.splice(t, 1);
    }
}

Engine.engines = [];

exports.Engine = Engine;
//# sourceMappingURL=index.cjs.map
